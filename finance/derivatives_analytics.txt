Derivatives
  Analytics
with Python
For other titles in the Wiley Finance series
    please see www.wiley.com/finance
          Derivatives
            Analytics
          with Python
Data Analysis, Models, Simulation,
         Calibration and Hedging



              YVES HILPISCH
This edition first published 2015
¬© 2015 John Wiley & Sons Ltd
Registered office
John Wiley & Sons Ltd, The Atrium, Southern Gate, Chichester, West Sussex, PO19 8SQ, United
Kingdom

For details of our global editorial offices, for customer services and for information about how to apply
for permission to reuse the copyright material in this book please see our website at www.wiley.com.

All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or
transmitted, in any form or by any means, electronic, mechanical, photocopying, recording or
otherwise, except as permitted by the UK Copyright, Designs and Patents Act 1988, without the prior
permission of the publisher.

Wiley publishes in a variety of print and electronic formats and by print-on-demand. Some material
included with standard print versions of this book may not be included in e-books or in
print-on-demand. If this book refers to media such as a CD or DVD that is not included in the version
you purchased, you may download this material at http://booksupport.wiley.com. For more information
about Wiley products, visit www.wiley.com.

Designations used by companies to distinguish their products are often claimed as trademarks. All
brand names and product names used in this book are trade names, service marks, trademarks or
registered trademarks of their respective owners. The publisher is not associated with any product or
vendor mentioned in this book.

Limit of Liability/Disclaimer of Warranty: While the publisher and author have used their best efforts
in preparing this book, they make no representations or warranties with respect to the accuracy or
completeness of the contents of this book and specifically disclaim any implied warranties of
merchantability or fitness for a particular purpose. It is sold on the understanding that the publisher is
not engaged in rendering professional services and neither the publisher nor the author shall be liable
for damages arising herefrom. If professional advice or other expert assistance is required, the services
of a competent professional should be sought.

Library of Congress Cataloging-in-Publication Data
Hilpisch, Yves J.
   Derivatives analytics with Python : data analysis, models, simulation, calibration and hedging /
Yves Hilpisch.‚Äî1
      pages cm.‚Äî(The Wiley finance series)
   Includes bibliographical references and index.
   ISBN 978-1-119-03799-6 (hardback)
  1. Derivative securities. 2. Hedging (Finance) 3. Python (Computer program language)
I. Title.
   HG6024.A3H56 2015
   332.64‚Ä≤ 5702855133‚Äîdc23                                                             2015010191

A catalogue record for this book is available from the British Library.

ISBN 978-1-119-03799-6 (hardback) ISBN 978-1-119-03793-4 (ebk)
ISBN 978-1-119-03800-9 (ebk)      ISBN 978-1-119-03801-6 (obk)

Cover Design: Wiley
Cover Images: Top image (c)iStock.com/agsandrew; Bottom image (c)iStock.com/stocksnapper

Set in 10/12pt Times by Aptara Inc., New Delhi, India
Printed in Great Britain by TJ International Ltd, Padstow, Cornwall, UK
                                                 Contents


List of Tables                                            xi

List of Figures                                         xiii

Preface                                                 xvii
CHAPTER 1
  A Quick Tour                                              1
  1.1     Market-Based Valuation                            1
  1.2     Structure of the Book                             2
  1.3     Why Python?                                       3
  1.4     Further Reading                                   4


PART ONE
  The Market
CHAPTER 2
  What is Market-Based Valuation?                           9
  2.1     Options and their Value                         9
  2.2     Vanilla vs. Exotic Instruments                 13
  2.3     Risks Affecting Equity Derivatives             14
          2.3.1 Market Risks                             14
          2.3.2 Other Risks                              15
  2.4     Hedging                                        16
  2.5     Market-Based Valuation as a Process            17

CHAPTER 3
  Market Stylized Facts                                  19
  3.1     Introduction                                   19
  3.2     Volatility, Correlation and Co.                19
  3.3     Normal Returns as the Benchmark Case           21




                                                            v
vi                                                    CONTENTS


     3.4   Indices and Stocks                              25
           3.4.1 Stylized Facts                            25
           3.4.2 DAX Index Returns                         26
     3.5   Option Markets                                  30
           3.5.1 Bid/Ask Spreads                           31
           3.5.2 Implied Volatility Surface                31
     3.6   Short Rates                                     33
     3.7   Conclusions                                     36
     3.8   Python Scripts                                  37
           3.8.1 GBM Analysis                              37
           3.8.2 DAX Analysis                              40
           3.8.3 BSM Implied Volatilities                  41
           3.8.4 EURO STOXX 50 Implied Volatilities        43
           3.8.5 Euribor Analysis                          45


PART TWO
     Theoretical Valuation
CHAPTER 4
  Risk-Neutral Valuation                                   49
      4.1 Introduction                                     49
      4.2 Discrete-Time Uncertainty                        50
      4.3 Discrete Market Model                            54
           4.3.1 Primitives                                54
           4.3.2 Basic Definitions                         55
      4.4 Central Results in Discrete Time                 57
      4.5 Continuous-Time Case                             61
      4.6 Conclusions                                      66
      4.7 Proofs                                           66
           4.7.1 Proof of Lemma 1                          66
           4.7.2 Proof of Proposition 1                    67
           4.7.3 Proof of Theorem 1                        68

CHAPTER 5
  Complete Market Models                                   71
      5.1 Introduction                                     71
      5.2 Black-Scholes-Merton Model                       72
           5.2.1 Market Model                              72
           5.2.2 The Fundamental PDE                       72
           5.2.3 European Options                          74
      5.3 Greeks in the BSM Model                          76
      5.4 Cox-Ross-Rubinstein Model                        81
      5.5 Conclustions                                     84
      5.6 Proofs and Python Scripts                        84
           5.6.1 ItoÃÇ‚Äôs Lemma                              84
Contents                                                     vii


            5.6.2   Script for BSM Option Valuation          85
            5.6.3   Script for BSM Call Greeks               88
            5.6.4   Script for CRR Option Valuation          92

CHAPTER 6
  Fourier-Based Option Pricing                               95
    6.1    Introduction                                      95
    6.2    The Pricing Problem                               96
    6.3    Fourier Transforms                                97
    6.4    Fourier-Based Option Pricing                      98
            6.4.1 Lewis (2001) Approach                      98
            6.4.2 Carr-Madan (1999) Approach                101
    6.5    Numerical Evaluation                             103
            6.5.1 Fourier Series                            103
            6.5.2 Fast Fourier Transform                    105
    6.6    Applications                                     107
            6.6.1 Black-Scholes-Merton (1973) Model         107
            6.6.2 Merton (1976) Model                       108
            6.6.3 Discrete Market Model                     110
    6.7    Conclusions                                      114
    6.8    Python Scripts                                   114
            6.8.1 BSM Call Valuation via Fourier Approach   114
            6.8.2 Fourier Series                            119
            6.8.3 Roots of Unity                            120
            6.8.4 Convolution                               121
            6.8.5 Module with Parameters                    122
            6.8.6 Call Value by Convolution                 123
            6.8.7 Option Pricing by Convolution             123
            6.8.8 Option Pricing by DFT                     124
            6.8.9 Speed Test of DFT                         125

CHAPTER 7
  Valuation of American Options by Simulation               127
    7.1 Introduction                                        127
    7.2 Financial Model                                     128
    7.3 American Option Valuation                           128
         7.3.1 Problem Formulations                         128
         7.3.2 Valuation Algorithms                         130
    7.4 Numerical Results                                   132
         7.4.1 American Put Option                          132
         7.4.2 American Short Condor Spread                 135
    7.5 Conclusions                                         136
    7.6 Python Scripts                                      137
         7.6.1 Binomial Valuation                           137
         7.6.2 Monte Carlo Valuation with LSM               139
         7.6.3 Primal and Dual LSM Algorithms               140
viii                                                           CONTENTS


PART THREE
       Market-Based Valuation
CHAPTER 8
  A First Example of Market-Based Valuation                        147
        8.1   Introduction                                         147
        8.2   Market Model                                         147
        8.3   Valuation                                            148
        8.4   Calibration                                          149
        8.5   Simulation                                           149
        8.6   Conclusions                                          155
        8.7   Python Scripts                                       155
               8.7.1 Valuation by Numerical Integration            155
               8.7.2 Valuation by FFT                              157
               8.7.3 Calibration to Three Maturities               160
               8.7.4 Calibration to Short Maturity                 163
               8.7.5 Valuation by MCS                              165

CHAPTER 9
  General Model Framework                                          169
        9.1 Introduction                                           169
        9.2 The Framework                                          169
        9.3 Features of the Framework                              170
        9.4 Zero-Coupon Bond Valuation                             172
        9.5 European Option Valuation                              173
             9.5.1 PDE Approach                                    173
             9.5.2 Transform Methods                               175
             9.5.3 Monte Carlo Simulation                          176
        9.6 Conclusions                                            177
        9.7 Proofs and Python Scripts                              177
             9.7.1 ItoÃÇ‚Äôs Lemma                                    177
             9.7.2 Python Script for Bond Valuation                178
             9.7.3 Python Script for European Call Valuation       180

CHAPTER 10
  Monte Carlo Simulation                                           187
       10.1   Introduction                                         187
       10.2   Valuation of Zero-Coupon Bonds                       188
       10.3   Valuation of European Options                        192
       10.4   Valuation of American Options                        196
              10.4.1 Numerical Results                             198
              10.4.2 Higher Accuracy vs. Lower Speed               201
       10.5   Conclusions                                          203
       10.6   Python Scripts                                       204
              10.6.1 General Zero-Coupon Bond Valuation            204
              10.6.2 CIR85 Simulation and Valuation                205
Contents                                                                    ix


           10.6.3   Automated Valuation of European Options by Monte
                    Carlo Simulation                                       209
           10.6.4   Automated Valuation of American Put Options by Monte
                    Carlo Simulation                                       215


CHAPTER 11
  Model Calibration                                                        223
   11.1    Introduction                                                    223
   11.2    General Considerations                                          223
           11.2.1 Why Calibration at All?                                  224
           11.2.2 Which Role Do Different Model Components Play?           226
           11.2.3 What Objective Function?                                 227
           11.2.4 What Market Data?                                        228
           11.2.5 What Optimization Algorithm?                             229
   11.3    Calibration of Short Rate Component                             230
           11.3.1 Theoretical Foundations                                  230
           11.3.2 Calibration to Euribor Rates                             231
   11.4    Calibration of Equity Component                                 233
           11.4.1 Valuation via Fourier Transform Method                   235
           11.4.2 Calibration to EURO STOXX 50 Option Quotes               236
           11.4.3 Calibration of H93 Model                                 236
           11.4.4 Calibration of Jump Component                            237
           11.4.5 Complete Calibration of BCC97 Model                      239
           11.4.6 Calibration to Implied Volatilities                      240
   11.5    Conclusions                                                     243
   11.6    Python Scripts for Cox-Ingersoll-Ross Model                     243
           11.6.1 Calibration of CIR85                                     243
           11.6.2 Calibration of H93 Stochastic Volatility Model           248
           11.6.3 Comparison of Implied Volatilities                       251
           11.6.4 Calibration of Jump-Diffusion Part of BCC97              252
           11.6.5 Calibration of Complete Model of BCC97                   256
           11.6.6 Calibration of BCC97 Model to Implied Volatilities       258


CHAPTER 12
  Simulation and Valuation in the General Model Framework                  263
   12.1    Introduction                                                    263
   12.2    Simulation of BCC97 Model                                       263
   12.3    Valuation of Equity Options                                     266
           12.3.1 European Options                                         266
           12.3.2 American Options                                         268
   12.4    Conclusions                                                     268
   12.5    Python Scripts                                                  269
           12.5.1 Simulating the BCC97 Model                               269
           12.5.2 Valuation of European Call Options by MCS                274
           12.5.3 Valuation of American Call Options by MCS                275
x                                                             CONTENTS



CHAPTER 13
  Dynamic Hedging                                                 279
    13.1   Introduction                                           279
    13.2   Hedging Study for BSM Model                            280
    13.3   Hedging Study for BCC97 Model                          285
    13.4   Conclusions                                            289
    13.5   Python Scripts                                         289
           13.5.1 LSM Delta Hedging in BSM (Single Path)          289
           13.5.2 LSM Delta Hedging in BSM (Multiple Paths)       293
           13.5.3 LSM Algorithm for American Put in BCC97         295
           13.5.4 LSM Delta Hedging in BCC97 (Single Path)        300

CHAPTER 14
  Executive Summary                                               303

APPENDIX A
  Python in a Nutshell                                            305
    A.1 Python Fundamentals                                       305
         A.1.1 Installing Python Packages                         305
         A.1.2 First Steps with Python                            306
         A.1.3 Array Operations                                   310
         A.1.4 Random Numbers                                     313
         A.1.5 Plotting                                           314
    A.2 European Option Pricing                                   316
         A.2.1 Black-Scholes-Merton Approach                      316
         A.2.2 Cox-Ross-Rubinstein Approach                       318
         A.2.3 Monte Carlo Approach                               323
    A.3 Selected Financial Topics                                 325
         A.3.1 Approximation                                      325
         A.3.2 Optimization                                       328
         A.3.3 Numerical Integration                              329
    A.4 Advanced Python Topics                                    330
         A.4.1 Classes and Objects                                330
         A.4.2 Basic Input-Output Operations                      332
         A.4.3 Interacting with Spreadsheets                      334
    A.5 Rapid Financial Engineering                               336

Bibliography                                                      341
Index                                                             347
                                                            List of Tables


3.1    Option bid/ask spreads for call options on stocks of the DJIA index           31
3.2    Option bid/ask spreads for put options on stocks of the DJIA index            32
5.1    Valuation results from the CRR binomial algorithm for the European call
       option; upper panel index level process, lower panel option value process     82
7.1    Valuation results from the LSM and DUAL algorithms for the American put
       option from 25 different simulation runs with base case parametrization      134
7.2    Valuation results from the LSM and DUAL algorithms for the Short Condor
       Spread from 25 different simulation runs with base case parametrization      135
10.1   Valuation results for European call and put options in H93 model for
       parametrizations from Medvedev and Scaillet (2010) and M0 = 50,
       I = 100,000. Performance yardsticks are PY1 = 0.025 and PY1 = 0.015.         195
10.2   Valuation results for European call and put options in H93 model for
       parametrizations from Medvedev and Scaillet (2010) and M0 = 50,
       I = 100,000. Performance yardsticks are PY1 = 0.025 and PY1 = 0.015.         197
10.3   Valuation results for American put options in H93 and CIR85 model for
       parametrizations from Medvedev and Scaillet (2010). Performance yardsticks
       are PY1 = 0.025 and PY1 = 0.015                                              200
10.4   Valuation results for American put options in H93 and CIR85 model for
       parametrizations from Medvedev and Scaillet (2010). Performance yardsticks
       are PY1 = 0.025 and PY1 = 0.015.                                             202
10.5   Valuation results for American put options in H93 and CIR85 model for
       parametrizations from Medvedev and Scaillet (2010). Performance yardsticks
       are PY1 = 0.01 and PY1 = 0.01                                                203




                                                                                     xi
                                                           List of Figures


2.1    Inner value of a European call option on a stock index with strike of 8,000
       dependent on the index level at maturity                                        10
2.2    Black-Scholes-Merton value of a European call option on a stock index with
       K = 9000, T = 1.0, r = 0.025 and ùúé = 0.2 dependent on the initial index
       level S0 ; for comparison, the undiscounted inner value is also shown           12
3.1    A single simulated path for the geometric Brownian motion over a 10-year
       period with daily log returns                                                   22
3.2    Histogram of the daily log returns (bars) and for comparison the probability
       density function of the normal distribution with the sample mean and
       volatility (line)                                                               22
3.3    Quantile-quantile plot of the daily log returns of the geometric Brownian
       motion                                                                          23
3.4    Realized volatility for the simulated path of the geometric Brownian motion     24
3.5    Rolling mean log return (252 days), rolling volatility (252 days) and rolling
       correlation between both (252 days) for geometric Brownian motion; dashed
       lines are averages over the whole period shown                                  25
3.6    DAX index level quotes and daily log returns over the period from 01.
       October 2004 to 30. September 2014                                              27
3.7    Histogram of the daily log returns of the DAX over the period from 01.
       October 2004 to 30. September 2014 (bars) and for comparison the
       probability density function of the normal distribution with the sample mean
       and volatility (line)                                                           27
3.8    Quantile-quantile plot of the daily log returns of the DAX over the period
       from 01. October 2004 to 30. September 2014                                     28
3.9    Realized volatility for the DAX over the period from 01. October 2004 to 30.
       September 2014                                                                  29
3.10   Rolling mean log return (252 days), rolling volatility (252 days) and rolling
       correlation between both (252 days); dashed lines are averages over the
       whole period shown                                                              30
3.11   Implied volatilities from European call options on the EURO STOXX 50 on
       30. September 2014                                                              33
3.12   Daily quotes of 1 week Euribor and daily log changes over the period from
       01. January 1999 to 30. September 2014                                          34
3.13   Histogram of daily log changes in 1 week Euribor in comparison to a normal
       distribution with same mean and standard deviation (line)                       35
3.14   Quantile-quantile plot of the daily log changes in the 1 week Euribor           35


                                                                                       xiii
xiv                                                                          LIST OF FIGURES


3.15   Daily quotes of 1 week (dotted), 1 month (dot-dashed), 6 months (dashed)
       and 1 year Euribor (solid line) over the period from 01. January 1999 to 30.
       September 2014                                                                     36
5.1    Value of the example European call option for varying strike K, maturity date
       T, short rate r and volatility ùúé                                                   76
5.2    Value of the example European put option for varying strike K, maturity date
       T, short rate r and volatility ùúé                                                   77
5.3    The delta of the European call option with respect to maturity date T and
       strike K                                                                           78
5.4    The gamma of the European call option with respect to maturity date T and
       strike K                                                                           79
5.5    The theta of the European call option with respect to maturity date T and
       strike K                                                                           79
5.6    The rho of the European call option with respect to maturity date T and strike
       K                                                                                  80
5.7    The vega of the European call option with respect to maturity date T and
       strike K                                                                           80
5.8    European call option values from the CRR model for increasing number of
       time intervals M‚Äîstep size of 20 intervals                                         83
5.9    European call option values from the CRR model for increasing number of
       time intervals M‚Äîstep size of 25 intervals                                         83
6.1    Fourier series approximation of function f (x) = |x| of order 1 (left) and of
       order 5 (right)                                                                   106
6.2    Valuation accuracy of Lewis‚Äô integral approach in comparison to BSM
       analytical formula; parameter values are S0 = 100, T = 1.0, r = 0.05, ùúé = 0.2     108
6.3    Valuation accuracy of CM99 FFT approach in comparison to BSM analytical
       formula; parameter values are S0 = 100, T = 1.0, r = 0.05, ùúé = 0.2,
       N = 4,096, ùúñ = 150‚àí1                                                              109
6.4    Series with roots of unity for n = 5 and n = 30 plotted in the imaginary plane    111
7.1    Valuation results for the American put option from 25 simulation runs with
       M = 75 time intervals; AV = average of primal (LSM) and dual (DUAL)
       values; dashed line = true value                                                  134
7.2    Valuation results for the American Short Condor Spread from 25 simulation
       runs with M = 75 time intervals; AV = average of primal (LSM) and dual
       (DUAL) values; dashed line = true value                                           136
8.1    Results of the calibration of Merton‚Äôs jump-diffusion model to market quotes
       for three maturities; lines = market quotes, dots = model prices                  150
8.2    Results of the calibration of Merton‚Äôs jump-diffusion model to a small subset
       of market quotes (i.e. a single maturity only; here: shortest maturity); line =
       market quotes, dots = model prices, bars = difference between model values
       and market quotes                                                                 151
8.3    Comparison of European call option values from Lewis formula (line), from
       Carr-Madan formula (triangles) and Monte Carlo simulation (dots)                  152
10.1   Twenty simulated paths for the CIR85 short rate process                           190
10.2   Values for a ZCB maturing at T = 2; line = analytical values, dots = Monte
       Carlo simulation estimates from the exact scheme for M = 50 and I = 50,000        191
List of Figures                                                                          xv


10.3     Values for a ZCB maturing at T = 2; line = analytical values, dots = Monte
         Carlo simulation estimates from the Euler scheme for M = 50 and I = 50,000     191
10.4     Boxplot of Monte Carlo valuation errors without and with moment matching       196
11.1     Euribor term structure up to 12 months (incl. Eonia rate); points = market
         quotes from 30. September 2014, line = interpolated curve, dashed line = 1st
         derivative of term structure curve                                             233
11.2     Market and model implied forward rates for Euribor; line = market forward
         rates from 30. September 2014, dots = model implied forward rates; bars =
         the difference between the model and market forward rates                      234
11.3     Unit zero-coupon bond values at time t maturing at time T = 2                  234
11.4     Results of H93 model calibration to EURO STOXX 50 option quotes; line =
         market quotes from 30. September, red dots = model values after calibration    237
11.5     Implied volatilities from H93 model calibration to EURO STOXX 50 option
         quotes from 30. September 2014                                                 238
11.6     Results of BCC97 jump-diffusion part calibration to five European call
         options on the EURO STOXX 50 with 17 days maturity; market quotes from
         30. September 2014                                                             240
11.7     Results of simultaneous BCC97 jump-diffusion and stochastic volatility part
         calibration to 15 European call options on the EURO STOXX 50 with 17, 80
         and 171 days maturity, respectively; quotes from 30. September 2014            241
11.8     Implied volatilities from BCC97 model calibration to EURO STOXX 50
         option quotes from 30. September 2014                                          242
11.9     Results of BCC97 calibration to 15 market implied volatilities of EURO
         STOXX 50 European call options with 17, 80 and 171 days maturity,
         respectively; market quotes from 30. September 2014                            243
11.10    Implied volatilities from BCC97 model calibration to EURO STOXX 50
         implied volatilities from 30. September 2014                                   244
12.1     Ten simulated short rate paths from calibrated CIR85 model for a time
         horizon of 1 year (starting 30. September 2014) and 25 time intervals          264
12.2     Ten simulated volatility paths from calibrated BCC97 model for a time
         horizon of 1 year (starting 30. September 2014) and 25 time intervals          264
12.3     Ten simulated EURO STOXX 50 level paths from calibrated BCC97 model
         for a time horizon of 1 year (starting 30. September 2014) and 25 time
         intervals                                                                      265
12.4     Histogram of simulated EURO STOXX 50 levels from calibrated BCC97
         model after a time period of 1 year (i.e. on 30. September 2015)               265
13.1     Dynamic replication of American put option in BSM model with profit at
         exercise                                                                       281
13.2     Dynamic replication of American put option in BSM model with loss at
         exercise                                                                       283
13.3     Frequency distribution of (discounted) P&L at exercise date of 10,000
         dynamic replications of American put option in BSM model                       284
13.4     Frequency distribution of (discounted) P&L at exercise date of 10,000
         dynamic replications of American put option in BSM model with more time
         steps and paths used                                                           285
13.5     Dynamic replication of American put option in BCC97 with profit at maturity    287
13.6     Dynamic replication of American put option in BCC97 with loss at maturity      288
xvi                                                                       LIST OF FIGURES


13.7   Frequency distribution of (discounted) P&L at exercise date of 10,000
       dynamic replications of American put option in general market model BCC97     288
13.8   Dynamic replication of American put option in BCC97 with huge loss at
       exercise due to an index jump                                                 289
A.1    Example of figure with matplotlib‚Äîhere: line                                  314
A.2    Example of figure with matplotlib‚Äîhere: dots and bars                         315
A.3    Histogram of simulated stock index levels at T                                324
A.4    Approximation of cosine function (line) by constant regression (crosses),
       linear regression (dots) and quadratic regression (triangles)                 326
A.5    Approximation of cosine function (line) by cubic splines interpolation (red
       dots)                                                                         327
A.6    Sample spreadsheet in Excel format with DAX quotes (here shown with
       LibreOffice)                                                                  335
A.7    Historic DAX index levels                                                     336
A.8    DAX index quotes from 03. January 2005 to 28. November 2014 and daily
       log returns                                                                   339
                                                                             Preface


T   his book is an outgrowth of diverse activities of myself and colleagues of mine in the fields
    of financial engineering, computational finance and Python programming at our company
The Python Quants GmbH on the one hand and of teaching mathematical finance at Saarland
University on the other hand.
     The book is targeted at practitioners, researchers and students interested in the market-
based valuation of options from a practical perspective, i.e. the single numerical and technical
implementation steps that make up such an effort. It is also for those who want to learn how
Python can be used for derivatives analytics and financial engineering. However, apart from
being primarily practical and implementation-oriented, the book also provides the necessary
theoretical foundations and numerical tools.
     My hope is that the book will contribute to the increasing acceptance of Python in
the financial community, and in particular in the analytics space. If you are interested in
getting the Python scripts and IPython Notebooks accompanying the book, you should visit
http://wiley.quant-platform.com where you can register for the Quant Platform which allows
browser-based, interactive and collaborative financial analytics. Further resources are found on
the website http://derivatives-analytics-with-python.com. You should also check out the open
source library DX Analytics under http://dx-analytics.com which implements the concepts
and methods presented in the book in standardized, reusable fashion.
     I thank my family‚Äîand in particular my wife Sandra‚Äîfor their support and understanding
that such a project requires many hours of solitude. I also want to thank my colleague Michael
Schwed for his continuous help and support. In addition, I thank Alain Ledon and Riaz Ahmad
for their comments and feedback. Discussions with participants of seminars and my lectures
at Saarland University also helped the project significantly. Parts of this book have benefited
from talks I have given at diverse Python and finance conferences over the years.
     I dedicate this book to my lovely son Henry Nikolaus whose direct approach to living and
clear view of the world I admire.

                                                                      Yves Hilpisch
                                                                      Saarland, February 2015




                                                                                             xvii
                                                                          CHAPTER         1
                                                                   A Quick Tour


1.1 MARKET-BASED VALUATION

This book is about the market-based valuation of (stock) index options. In the domain of
derivatives analytics this is an important task which every major investment bank and buy-side
decision maker in the financial market is concerned with on a daily basis. While theoretical
valuation approaches develop a model, parametrize it and then derive values for options, the
market-based approach works the other way round. Prices from liquidly traded options are
taken as given (i.e. they are inputs instead of outputs) and one tries to parametrize a market
model in a way that replicates the observed option prices as well as possible. This activity is
generally referred to as model calibration. Being equipped with a calibrated model, one then
proceeds with the task at hand, be it valuation, trading, investing, hedging or risk management.
A bit more specifically, one might be interested in pricing and hedging an exotic derivative
instrument with such a model‚Äîhoping that the results are in line with the overall market
(i.e. arbitrage-free and even ‚Äúfair‚Äù) due to the previous calibration to more simple, vanilla
instruments.
      To accomplish a market-based valuation, four areas have to be covered:


 1. market: knowledge about market realities is a conditio sine qua non for any sincere
    attempt to develop market-consistent models and to accomplish market-based valuation
 2. theory: every valuation must be grounded on a sound market model, ensuring, for exam-
    ple, the absence of arbitrage opportunities and providing means to derive option values
    from observed quantities
 3. numerics: one cannot hope to work with analytical results only; numerical techniques,
    like Monte Carlo simulation, are generally required in different steps of a market-based
    valuation process
 4. technology: to implement numerical techniques efficiently, one is dependent on appro-
    priate technology (hard- and software)


     This book covers all of these areas in an integrated manner. It uses equity index options
as the prime example for derivative instruments throughout. This, among others, allows to
abstract from dividend related issues.


                                                                                              1
2                                                           DERIVATIVES ANALYTICS WITH PYTHON


1.2 STRUCTURE OF THE BOOK

The book is divided into three parts. The first part is concerned with market-based valuation
as a process and empirical findings about market realities. The second part covers a number
of topics for the theoretical valuation of options and derivatives. It also develops tools much
needed during a market-based valuation. The third part finally covers the major aspects related
to a market-based valuation and also hedging strategies in such a context.
     Part I ‚ÄúThe Market‚Äù comprises two chapters:

     Chapter 2: this chapter contains a discussion of topics related to market-based valuation,
      like risks affecting the value of equity index options
     Chapter 3: this chapter documents empirical and anecdotal facts about stocks, stock

      indices and in particular volatility (e.g. stochasticity, clustering, smiles) as well as about
      interest rates

        Part II ‚ÄúTheoretical Valuation‚Äù comprises four chapters:

     Chapter 4: this chapter covers arbitrage pricing theory and risk-neutral valuation in
      discrete time (in some detail) and continuous time (on a higher level) according to the
      Harrison-Kreps-Pliska paradigm (cf. Harrison and Kreps (1979) and Harrison and Pliska
      (1981))
     Chapter 5: the topic of this chapter is the complete market models of Black-Scholes-

      Merton (BSM, cf. Black and Scholes (1973), Merton (1973)) and Cox-Ross-Rubinstein
      (CRR, cf. Cox et al. (1979)) that are generally considered benchmarks for option valuation
     Chapter 6: Fourier-based approaches allow us to derive semi-analytical valuation formu-

      las for European options in market models more complex and realistic than the BSM/CRR
      models; this chapter introduces the two popular methods of Carr-Madan (cf. Carr and
      Madan (1999)) and Lewis (cf. Lewis (2001))
     Chapter 7: the valuation of American options is more involved than with European

      options; this chapter analyzes the respective problem and introduces algorithms for Amer-
      ican option valution via binomial trees and Monte Carlo simulation; at the center stands the
      Least-Squares Monte Carlo algorithm of Longstaff-Schwartz (cf. Longstaff and Schwartz
      (2001))

        Finally, Part III ‚ÄúMarket-Based Valuation‚Äù has seven chapters:

     Chapter 8: before going into details, this chapter illustrates the whole process of a market-
      based valuation effort in the simple, but nevertheless still useful, setting of Merton‚Äôs
      jump-diffusion model (cf. Merton (1976))
     Chapter 9: this chapter introduces the general market model used henceforth, which

      is from Bakshi-Cao-Chen (cf. Bakshi et al. (1997)) and which accounts for stochastic
      volatility, jumps and stochastic short rates
     Chapter 10: Monte Carlo simulation is generally the method of choice for the valuation

      of exotic/complex index options and derivatives; this chapter therefore discusses in some
      detail the discretization and simulation of the stochastic volatility model by Heston
A Quick Tour                                                                                     3


    (cf. Heston (1993)) with constant as well as stochastic short rates according to Cox-
    Ingersoll-Ross (cf. Cox et al. (1985))
   Chapter 11: model calibration stays at the center of market-based valuation; the chapter

    considers several general aspects associated with this topic and then proceeds with the
    numerical calibration of the general market model to real market data
   Chapter 12: this chapter combines the results from the previous two to value European

    and American index options via Monte Carlo simulation in the calibrated general market
    model
   Chapter 13: this chapter analyzes dynamic delta hedging strategies for American options

    by Monte Carlo simulation in different settings, from a simple one to the calibrated market
    model
   Chapter 14: this brief chapter provides a concise summary of central aspects related to

    the market-based valuation of index options

      In addition, the book has an Appendix with one chapter:

     Appendix A: the appendix introduces some of the most important Python concepts and
      libraries in a nutshell; the selection of topics is clearly influenced by the requirements of
      the rest of the book; those not familiar with Python or looking for details should consult
      the more comprehensive treatment of all relevant topics by the same author (cf. Hilpisch
      (2014))


1.3 WHY PYTHON?

Although Python has established itself in the financial industry as a powerful programming
language with an elaborate ecosystem of tools and libraries, it is still not often used for
financial, derivatives or risk analytics purposes. Languages like C++, C, C#, VBA or Java and
toolboxes like Matlab or domain-specific languages like R often dominate this area. However,
we see a number of good reasons to choose Python even for computationally demanding
analytics tasks; the following are the most important ones we want to mention, in no particular
order, (see also chapter 1 in Hilpisch (2014)):

   open source: Python and the majority of available libraries are completely open source;
    this allows an entry to this technology at no cost, something particularly important for
    students, academics or other individuals
   syntax: Python programming is easy to learn, the code is quite compact and in general

    highly readable; at universities it is increasingly used as an introduction to programming
    in general; when it comes to numerical or financial algorithm implementation, the syntax
    is pretty close to the mathematics in general (e.g. due to code vectorization approaches)
   multi-paradigm: Python is as good for procedural programming (which suffices for the

    purposes of this book) as well as at object-oriented programming (which is necessary in
    more complex/professional contexts); it also has some functional programming features
    to offer
   interpreted: Python is an interpreted language which makes rapid prototyping and devel-

    opment in general a bit more convenient, especially for beginners; tools like IPython
4                                                            DERIVATIVES ANALYTICS WITH PYTHON


       Notebook and libraries like pandas for time series analysis allow for efficient and produc-
       tive interactive analytics workflows
      libraries: nowadays, there is a wealth of powerful libraries available and the supply grows

       steadily; there is hardly a problem that cannot be easily tackled with an existing library,
       be it a numerical problem, a graphical one or a data-related problem
      speed: a common prejudice with regard to interpreted languages‚Äîcompared to compiled

       ones like C++ or C‚Äîis the slow speed of code execution; however, financial applications
       are more or less all about matrix and array manipulations and operations which can be
       done at the speed of C code with the essential Python library NumPy for array-based
       computing; other performance libraries, like Numba for dynamic code compiling, can
       also be used to improve performance
      market: in the London area (mainly financial services) the number of Python developer

       contract offerings was 485 in the third quarter of 2012; the comparable figure in the same
       period 2013 was already 864;1 large financial institutions like Bank of America, Merrill
       Lynch and J.P. Morgan have millions of lines of Python code in production, mainly in
       risk management; Python is also really popular in the hedge fund industry

     All in all, Python seems to be a good choice for our purposes. The cover story ‚ÄúPython
Takes a Bite‚Äù in the March 2010 issue of Wilmott magazine (cf. Lee (2010)) also illustrates
that Python is gaining ground in the financial world. A modern introduction into Python for
finance is given by Hilpisch (2014).
     One of the easiest ways to get started with Python is to register on the Quant Platform
which allows for browser-based, interactive and collaborative financial analytics and devel-
opment (cf. http://quant-platform.com). This platform offers all you need to do efficient and
productive financial analytics as well as financial application building with Python. It also pro-
vides, for instance, integration with R, the free software environment for statistical computing
and graphics.



1.4 FURTHER READING

The book covers a great variety of aspects which comes at the cost of depth of exposition and
analysis in some places. Our aim is to emphasize the red line and to guide the reader easily
through the different topics. However, this inevitably leads to uncovered aspects, omitted
proofs and unanswered questions. Fortunately, a number of good sources in book form are
available which may be consulted on the different topics:

        market: cf. Bittmann (2009) to learn about options fundamentals, the main microstructure
         elements of their markets and the specific lingo; Gatheral (2006) is a concise reference
         about option and volatility modeling in practice; Rebonato (2004) is a book that com-
         prehensively covers option markets, their empirical specialities and the models used in
         theory and practice


1
    Source: www.itjobswatch.co.uk/contracts/london/python.do on 07. October 2014.
A Quick Tour                                                                                    5


     theory: Pliska (1997) is a comprehensive source for discrete market models; the book
      by Delbaen and Schachermayer (2004) covers the general arbitrage theory in continuous
      time and is quite advanced; less advanced, but still comprehensive, treatments of arbitrage
      pricing are BjoÃàrk (2004) for continuous processes based on Brownian motion and Cont
      and Tankov (2004a) for continuous processes with jumps; Wilmott et al. (1995) offers a
      detailed discussion of the seminal Black-Scholes-Merton model
     numerics: Cherubini et al. (2009) is a book-length treatment of the Fourier-based option

      pricing approach; Glasserman (2004) is the standard textbook on Monte Carlo simulation
      in financial applications; Brandimarte (2006) covers a wide range of numerical techniques
      regularly applied in mathematical finance and offers implementation examples in Matlab2
     implementation: probably the best introduction to Python for the purposes of this book

      is another book by same author (cf. Hilpisch (2014)) which is called Python for Finance;
      that book covers the main tools and libraries needed for this book, like IPython, NumPy,
      matplotlib, PyTables and pandas, in a detailed fashion and with a wealth of concrete
      financial examples; the excellent book by McKinney (2012) about data analysis with
      Python should also be consulted; good general introductions to Python from a scientific
      perspective are Haenel et al. (2013) and Langtangen (2009); Fletcher and Gardener
      (2009) provides an introduction to the language also from a financial perspective, but
      mainly from the angle of modeling, capturing and processing financial trades; London
      (2005) is a larger book that covers a great variety of financial models and topics and shows
      how to implement them in C++; in addition, there is a wealth of Python documentation
      available for free on the Internet.

        This concludes the Quick Tour.




2
 Python in combination with NumPy comes quite close to the syntax of Matlab such that translations
are generally straightforward.
      PART
     One
The Market
                                                                          CHAPTER         2
                     What is Market-Based Valuation?


2.1 OPTIONS AND THEIR VALUE

An equity option represents the right to buy (call) or sell (put) a unit of the underlying stock
at a prespecified price (strike) at a predetermined date (European option) or over a determined
period of time (American option). Some options are settled in actual stocks; most options, like
those on an index, are settled in cash. People or institutions selling options are called option
writers. Those buying options are called option holders.
     For a European call option on an index with strike 8,000 and index level of 8,200
at maturity, the option holder receives the difference 8,200 ‚àí 8,000 = 200 (e.g. in EUR or
USD) from the option writer. If the index level is below the strike, say at 7,800, the option
expires worthless and the writer does not have to pay anything. We can formalize this via
the so-called inner value (or intrinsic value or payoff)‚Äîfrom the holder‚Äôs viewpoint‚Äîof
the option

                                  hT (S, K) = max[ST ‚àí K, 0]

where T is the maturity date of the option, ST the index level at this date and K represents the
strike price. We can now use Python for the first time and plot this inner value function.
     A script could look like:


#
# European Call Option Inner Value Plot
# 02_MBV/inner_value_plot.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rcParams['font.family'] = 'serif'




                                                                                              9
10                                                        DERIVATIVES ANALYTICS WITH PYTHON


# Option Strike
K = 8000


# Graphical Output
S = np.linspace(7000, 9000, 100) # index level values
h = np.maximum(S - K, 0) # inner values of call option


plt.figure()
plt.plot(S, h, lw=2.5)       # plot inner values at maturity
plt.xlabel('index level $S_t$ at maturity')
plt.ylabel('inner value of European call option')
plt.grid(True)



    The output of this script is shown in Figure 2.1.
    Three scenarios have to be distinguished with regard to the so-called moneyness of an
option:

   in-the-money (ITM): a call (put) is in-the-money if S > K (S < K)
   at-the-money (ATM): an option, call or put, is at-the-money if S ‚âà K
   out-of-the-money (OTM): a call (put) is out-of-the-money if S < K (S > K)




     However, what influences the present value of such a call option today? Here are some
factors:




         FIGURE 2.1 Inner value of a European call option on a stock index with strike
         of 8,000 dependent on the index level at maturity
What is Market-Based Valuation?                                                                    11


     initial index level: of course, it is important what the current index level is since this
      influences how probable it is that the index level exceeds the strike at maturity; if the
      index level is 7,900 it should be much more probable that the call option expires with
      positive value than if the level was at 7,500
     volatility of the index: put simply, (annualized) volatility is a measure for the randomness

      of the index‚Äôs returns over a year; suppose the extreme case that the index is at 7,900
      and there is no risk/no movement at all‚Äîthen the index would not surpass the strike at
      maturity; however, if the index is at 7,900 and fluctuating strongly then there is a chance
      that the option will expire with positive value‚Äîand the bigger the fluctuations (the higher
      the volatility) the better from the option holder‚Äôs viewpoint
     time-to-maturity: again suppose the index is at 7,900; if time-to-maturity is only one

      day then the probability of the option being valuable at maturity is much lower than if
      time-to-maturity was 1 month or even 1 year
     interest rate: cash flows from a European option occur at maturity only which represents

      a future date; these cash flows have to be discounted to today to derive a present value

     These heuristic insights are formalized in the seminal work of Black-Scholes-Merton (cf.
Black and Scholes (1973) and Merton (1973)) who for the first time derived a closed option
pricing formula for a parsimonious set of input parameters. Their formula says mainly the
following

                                      C0‚àó = CBSM (S0 , K, T, r, ùúé)


In words, the fair present value of a European call option C0‚àó is given by their formula CBSM (‚ãÖ)
which takes as input parameters:

    1. S0 the current index level
    2. K the strike price of the option
    3. T the maturity date (equals time-to-maturity viewed from the present date)
    4. r the constant risk-less short rate
    5. ùúé the volatility of the index, i.e. the standard deviation of the index level returns

     The Black-Scholes-Merton formula can also be plotted and the result is shown in Fig-
ure 2.2.1 The present value of the option is always above the (undiscounted) inner value. The
difference between the two is generally referred to as the time value of the option. In this sense,
the option‚Äôs present value is composed of the inner value plus the time value. Time value is
suggestive of the fact that the option still has time to get in-the-money or to get even more
in-the-money.
     Here is the Python script that generates Figure 2.2.


1
 Cf. Chapter 5 for a treatment of the Black-Scholes-Merton model and their pricing formula, reproduced
there as equation (5.7). The Python script in sub-section 5.6.2, which we have used to generate Figure
2.2, implements the formula for calls and puts.
12                                                          DERIVATIVES ANALYTICS WITH PYTHON




        FIGURE 2.2 Black-Scholes-Merton value of a European call option on a
        stock index with K = 9000, T = 1.0, r = 0.025 and ùúé = 0.2 dependent on the
        initial index level S0 ; for comparison, the undiscounted inner value is also shown




#
# European Call Option Value Plot
# 02_mbv/BSM_value_plot.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rcParams['font.family'] = 'serif'


# Import Valuation Function from Chapter 5
import sys
sys.path.append('05_com')
from BSM_option_valuation import BSM_call_value

# Model and Option Parameters
K = 8000 # strike price
T = 1.0 # time-to-maturity
r = 0.025 # constant, risk-less short rate
vol = 0.2   # constant volatility

# Sample Data Generation
S = np.linspace(4000, 12000, 150)           # vector of index level values
What is Market-Based Valuation?                                                                          13


h = np.maximum(S - K, 0) # inner value of option
C = [BSM_call_value(S0, K, 0, T, r, vol) for S0 in S]
  # calculate call option values


# Graphical Output
plt.figure()
plt.plot(S, h, 'b-.', lw=2.5, label='inner value')
  # plot inner value at maturity
plt.plot(S, C, 'r', lw=2.5, label='present value')
  # plot option present value
plt.grid(True)
plt.legend(loc=0)
plt.xlabel('index level $S_0$')
plt.ylabel('present value $C(t=0)$')




2.2 VANILLA VS. EXOTIC INSTRUMENTS

Financial markets distinguish between plain vanilla or flow equity derivatives, like European
call options written on an equity index, and exotic equity derivatives, like options on an equity
index with Asian features, barriers and/or American exercise.2 In general, there exist liquid
markets for plain vanilla products but not for exotic ones. In contrast, exotic derivatives are
often tailored by financial institutions to specific client needs and are not traded at all (or ‚Äúonly
once‚Äù if you like).3
     Nevertheless, financial institutions writing exotic equity options (so-called sell side) or
clients buying these options (i.e. the buy side) must have a mechanism to derive fair values
regularly and transparently. In addition, option writers must be able to hedge their exposure. In
relation to exotic equity derivatives, sellers and buyers must often resort to numerical methods,
like Monte Carlo simulation, to come up with fair values and appropriate hedging strategies.
     Here we face for the first time what is meant by market in market-based valuation.
The market is represented by liquidly traded vanilla instruments (for example, European or
American call options) on the underlying in question. If I want to value a non-traded equity
derivative in a market-based manner then I should include in this process the information
available from the relevant vanilla options market. This requirement is based on a belief in
efficient markets and the claim that the market is always right.
     More formally, whatever model I use for the valuation and hedging of exotic equity
derivatives, a minimum requirement is that the model reproduce the values of liquidly traded
instruments sufficiently well. Two areas have to be considered carefully:

       qualitative features: given the underlying of the derivative to be valued and the options
        on this underlying liquidly traded, what qualitative features should the model exhibit? for

2
 Cf. de Weert (2008) for an overview and explanation of exotic options and their features.
3
 As a proxy of market liquidity you can think of the frequency with which option quotes are updated. For
plain vanilla instruments this might be in the range of seconds during trading hours; for exotic derivatives
this might be once a day or even once a week.
14                                                           DERIVATIVES ANALYTICS WITH PYTHON


       example, it would make sense to assume that an equity index will (positively) trend in the
       long term; however, this assumption is not appropriate if the underlying is an interest rate
       or volatility measure which tend to fluctuate around long-term equilibrium values
      quantitative features: given the basic qualitative features of the model, there are in

       general infinitely many possibilities to parametrize it; while in physics there are often
       universal constants to rely on, this is hardly ever the case in finance; on the positive side,
       this allows parameters to be set in a way that best fits model prices to market-observed
       prices from vanilla instruments (a task called calibration and central in what follows)

     In Chapter 3, we discuss a number of issues related to the question of what qualitative
features an appropriate model should exhibit. Part II of the book then explains how to build
such models theoretically. Part III of the book is mainly concerned with simulation, model
calibration (i.e. parameter specification), valuation and hedging.


2.3 RISKS AFFECTING EQUITY DERIVATIVES

This section focuses on market risks affecting the price of derivative instruments as well as
other risks that play a role in this context.


2.3.1 Market Risks
To come up with fair values for equity derivatives and sound hedging strategies, one has to
consider first which market risks influence their values. Among the market risks that influence
equity derivatives are:

      price risk: this relates to uncertain changes in the underlying‚Äôs price, like index or stock
       price movements
      volatility risk: volatility refers to the standard deviation of the underlying‚Äôs returns;

       however, volatility itself fluctuates over time, i.e. volatility is not constant but rather
       stochastic
      jump or crash risk: the stock market crashes of 1987, 1998, 2001 and 2008 as well as

       implied volatilities of stock index options (see the next chapter) indicate that there is a
       significantly positive probability for large market drops; such discontinuities may break
       down, for example, otherwise sound dynamic hedging strategies
      interest rate risk: although equity derivatives generally do not rely on interest rates

       or bonds directly4 their value is indirectly influenced by interest rates via risk-neutral
       discounting with the short rate
      correlation risk: simply spoken, correlation measures the co-movement of two or more

       assets/quantities; correlation may change over time and become close to 1, i.e. perfect,
       among asset classes during times of stress
      liquidity risk: dynamic and static hedging strategies depend on market liquidity; for

       example, if certain options are not liquidly traded a desired hedge may not be executable


4
    Otherwise they would be classified as hybrids.
What is Market-Based Valuation?                                                                        15


     default risk: in case of the default of a company represented in the underlying assets,
      stocks and/or bonds of this company depreciate in value (often to zero)

    In what follows, the discussion addresses all market risks mentioned above, apart from
default and liquidity risk. Default risk does not play a significant role since the discussion
mainly focuses on benchmark indices where the possibility of default of a single company is
generally negligible.5
    Liquidity risk is more oriented towards the implementation of hedging programs and in that
sense ‚Äúonly‚Äù an important operational aspect depending on the specific market environment
an option seller or buyer operates in. In addition, the focus of this book is mainly on stock
index derivatives where liquidity risk seldom is a problem‚Äîindex futures, for example, are
among the most liquid instruments. Although an active area of research,6 a broadly accepted
theoretical approach to incorporate liquidity in financial models is still missing. Cetin et al.
(2004) point out:

      ‚ÄúFrom a financial engineering perspective, the need is paramount for a simple yet
      robust method that incorporates liquidity risk into arbitrage pricing theory.‚Äù

     They propose what they call the ‚Äúliquidity risk arbitrage pricing theory‚Äù with a stochastic
supply curve for a security‚Äôs price as a function of trade size.7 As long as there is no solution
to this, one has to keep in mind what The New York Times summarizes as follows:

      ‚ÄúThat failure [of risk models] suggests new frontiers for financial engineering and
      risk management, including trying to model the mechanics of panic and the patterns
      of human behavior.
           ‚ÄòWhat wasn‚Äôt recognized was the importance of a different species of risk‚Äî
      liquidity risk,‚Äô said Stephen Figlewski, a professor of finance at the Leonard N. Stern
      School of Business at New York University.‚Ä¶‚Äù8


2.3.2 Other Risks
In addition to market risks, there are other sources of risk like, for instance, models and
operations. Model risk refers to the risk that valuation and risk management finally rely on the
specific model used. Even if your model addresses, say, volatility risk you may nevertheless
address it in a harmful way‚Äîi.e. via the wrong model generating inappropriate hedging strate-
gies. Operational risk refers to all aspects of implementing valuation and risk management
processes as well as risks related to IT systems used. For example, knowledge of the right

5
  Gatheral (2006), ch. 6, analyzes default risk in the context of options on single stocks. Duffie and
Singleton (2003) analyze default risk in a broader context and more comprehensively.
6
  Frey (2000) analyzes market illiquidity as a source of model risk in the context of dynamic hedging.
Hilpisch (2001) provides a survey of research addressing valuation and dynamic hedging in imperfectly
liquid markets.
7
  Cf. Jarrow (2005) for a discussion of this theory‚Äôs implications in terms of valuation, hedging and risk
measurement.
8
  The New York Times (13. September 2009): ‚ÄúWall Street‚Äôs Math Wizards Forgot a Few Variables.‚Äù
16                                                        DERIVATIVES ANALYTICS WITH PYTHON


hedging program is surely of great importance‚Äîbut the timely and correct execution of the
program is at least equally important.


2.4 HEDGING

Hedging describes the activity of minimizing or even eliminating risks resulting from option
positions. Getting back to our previous example, an option writer who faces the risk of paying
out 200 EUR to an option holder might want to set up a hedge program that pays her the exact
amount in the exact case‚Äîleaving her with net debt of zero. The program should also pay
300 EUR or 100 EUR or whatever might be the amount due to writing the index option. In
such a way, the writer would completely eliminate the risks attached to the short position in
the option. In general, option writers do exactly this since as market participants they are not
speculators but rather want to earn a steady income from their activities.
     A hedge program can be either dynamic or static or a combination of both. Assume
the equity index option of the example has time-to-maturity of 1 year. In order to hedge the
option dynamically‚Äîin general with positions in the underlying‚Äîthe writer sets up a hedge
portfolio at the date of writing the option and then adjusts the portfolio frequently. A static
hedge program‚Äîin general with positions in other options‚Äîwould be set up at issuance
and hold constant until maturity. More sophisticated hedge strategies generally combine both
elements.
     In general, there is neither a unique objective nor a unique set of principles for setting up
hedge programs. For example, Gilbert et al. (2007) report three main objectives of variable
annuities providers, i.e. life insurers, when implementing hedging programs:

 1. accounting level
 2. accounting volatility and
 3. economic risks

     This book focuses on economic risks only since accounting issues are highly dependent
on the concrete reporting standards and may therefore vary from country to country. In that
sense, the perspective of this book is cash flow driven and intentionally neglects accounting
issues. The approach is that of arbitrage or risk-neutral pricing/hedging as comprehensively
explained in BjoÃàrk (2004) for models with continuous price processes and in Cont and Tankov
(2004a) for models where price processes may jump.
     Generally speaking, the main goal of a hedging program in economic or cash terms is
to perfectly replicate the hedged derivative‚Äôs payoff and thus eliminate all risk. However, in
practice this is seldom realized due to two main issues. The first is the frequency of hedge
rebalancings. In theory, dynamic hedging requires continuous rebalancings but practice only
allows discrete rebalancings due to transaction costs and other market microstructure elements.
This leads to a sequence of hedge errors which might add up over time or which may cancel
each other out to some extent. The second is market incompleteness. If jumps of the underlying
are possible, for example, markets become incomplete in the sense that risks cannot be hedged
away since an infinite number of hedge instruments would be necessary to do so. One must
rather resort to a risk minimization program where an (expected) hedge error, for example, is
minimized. Another possibility would be to super-replicate the derivative‚Äîa strategy that can
be rather costly.
What is Market-Based Valuation?                                                             17


    In summary, if markets are sufficiently complete, hedgers generally strive to completely
eliminate all cash flow risks resulting from options. If they are incomplete, hedgers can often
only try to minimize the (expected) hedge error.


2.5 MARKET-BASED VALUATION AS A PROCESS

This book mainly takes the perspective of a corporate or financial institution investing or
trading in‚Äîpossibly exotic‚Äîequity derivatives. A canonical example might be a quantitative
hedge fund. In order to make profound decisions and to build a sustainable business around
equity derivatives, the institution must consider the following fundamental aspects:

 1. market realities: what characterizes the market of the underlying and of the liquidly
    traded options on the underlying?
 2. market model: the institution should apply a theoretical market model which is capable
    of providing a realistic framework for valuation and hedging purposes in the specific
    underlying and option market
 3. vanilla instrument valuation: there should be available efficient methods to price vanilla
    instruments on a large scale
 4. model calibration: a minimum requirement the market model must fulfill is that it
    reproduce prices of actively traded vanilla instruments reasonably well; to this end, the
    model parameters have to be calibrated to market data
 5. exotic instrument valuation: there must be available flexible numerical methods to value
    exotic derivatives based on the calibrated market model; the most flexible method in this
    regard is Monte Carlo simulation (MCS)
 6. hedging: as a general rule, if you can value a derivative instrument you can derive infor-
    mation needed to hedge this instrument; regarding exotic equity derivatives, numerical
    methods also have to be applied more often than not to come up with hedge parameters,
    like the delta of an option

     This book addresses all six aspects. However, it abstracts in general from market
microstructure aspects like bid/ask spreads, market liquidity, transaction costs, trade exe-
cution, etc. and also from dividends (which may be justified by the focus on index options).
     Being equipped with an understanding of what characterizes the market-based valuation
process, the next chapter reproduces some of the most important stylized facts with regard to
stock indices and index options.
                                                                                CHAPTER         3
                                                    Market Stylized Facts

3.1 INTRODUCTION

In science one often takes the route from the specific to the general‚Äîfrom a number of
real world observations to a theory or model describing the phenomenon in general fashion.
This chapter therefore mainly conducts an analysis of real world data as a basis for the further
modeling and implementation efforts. Our main objects of analysis are the DAX stock index‚Äî
composed of stocks of large German companies‚Äîand European call options on the EURO
STOXX 50 stock index‚Äîcomposed of stocks of large European companies.
     The chapter first introduces some notions central to equity markets and equity derivatives,
like volatility and correlation. It then conducts a simulation study in a laboratory fashion
based on the benchmark geometric Brownian motion model of Black-Scholes-Merton (BSM).
However, the main part of the chapter is concerned with the analysis of a financial time series
of daily DAX index level movements. This is done in a tutorial style where the simplicity and
replicability of results (with the provided Python scripts) are the main objectives. The chapter
then turns to equity options markets in section 3.5. Here, pricing conventions and practices,
the volatility smile/skew and its term structure are the main topics. Section 3.6 then rather
briefly takes a look at market realities with regard to short rates.

3.2 VOLATILITY, CORRELATION AND CO.

Volatility may be the most central notion in option and derivatives analytics. There is not a
single volatility concept but rather a family of concepts related to the notion of an ‚Äúundirected
dispersion/risk measure‚Äù. For our purposes, we need to distinguish between the following
different‚Äîbut somehow related‚Äîvolatility concepts (always in relation to a stochastic process
or a financial time series):
       historical volatility: this refers to the standard deviation of log returns of a financial time
        series; suppose we observe N (past) log returns1 rn , n ‚àà {1, ‚Ä¶ , N}, with mean return

                                                       1 ‚àë
                                                         N
                                                ùúáÃÇ =        r
                                                       N n=1 n

1
 Assume a time series with quotes Sn , n ‚àà {0, ‚Ä¶ , N}. The log return for n > 0 is defined by rn ‚â°
log Sn ‚àí log Sn‚àí1 = log(Sn ‚àïSn‚àí1 ).


                                                                                                    19
20                                                              DERIVATIVES ANALYTICS WITH PYTHON


        the historical volatility ùúéÃÇ is then given by2
                                                ‚àö
                                                ‚àö
                                                ‚àö 1 ‚àë     N
                                           ùúéÃÇ = ‚àö           (r ‚àí ùúá)
                                                                 ÃÇ 2
                                                   N ‚àí 1 n=1 n

       instantaneous volatility: this refers to the volatility factor of a diffusion process; for
        example, in the Black-Scholes-Merton model the instantaneous volatility ùúé is found in
        the respective (risk-neutral) stochastic differential equation (SDE)
                                            dSt = rSt dt + ùúéSt dZt
       implied volatility: this is the volatility that, if put into the Black-Scholes-Merton option
        pricing formula, gives the market-observed price of an option; suppose we observe today
        a price of C0‚àó for a European call option; the implied volatility ùúé imp is the quantity that
        solves ceteris paribus the implicit equation3

                                        C0‚àó = CBSM (S0 , K, T, r, ùúé imp )

    These volatilities all have squared counterparts which are then named variance. For
example, in some financial models where volatility is stochastic‚Äîin contrast to the BSM
assumption‚Äîthe variance is modeled instead of the volatility.
    Two other (sample) moments of distribution are of importance:
       skewness: this is a measure of the location of sample values relative to the mean (‚Äúmore
        to the left or more to the right‚Äù)4 ; again suppose we observe N (past) log returns rn , n ‚àà
        {1, ‚Ä¶ , N}, with mean return ùúá; ÃÇ the (sample) skewness sÃÇ is
                                                  1 ‚àëN
                                                  N  n=1 (rn ‚àí ùúá)
                                                               ÃÇ 3
                                        sÃÇ = (                      )3‚àï2
                                                 1 ‚àëN
                                                 N  n=1 (rn ‚àí ùúá)
                                                              ÃÇ 2

       kurtosis: this is a measure for the peakedness of a distribution and/or the size of the tails
        of the distribution (‚Äúfat tails‚Äù are implied by a high kurtosis); again suppose we observe
                                                                    ÃÇ the (sample) kurtosis kÃÇ is
        N (past) log returns rn , n ‚àà {1, ‚Ä¶ , N}, with mean return ùúá;
                                                 1 ‚àëN
                                                    n=1 (rn ‚àí ùúá)
                                                              ÃÇ 4
                                       kÃÇ = ( N                   )2 ‚àí 3
                                              1 ‚àëN
                                              N  n=1 (rn ‚àí ùúá)
                                                           ÃÇ 2

        here 3 is subtracted such that the (standard) normal distribution has a kurtosis of 0

2
  This formula is often called the corrected (or unbiased) sample standard deviation in contrast to the
case of the uncorrected (or biased) sample standard deviation where the multiplier is 1‚àïN instead of
1‚àï(N ‚àí 1). Note that in Python and in particular NumPy, the uncorrected sample standard deviation is
generally implemented.
3
  Implied volatility could in principle also be defined with respect to a different model. However, through-
out this book implied always means ‚Äúimplied by the Black-Scholes-Merton formula‚Äù.
4
  For the normal distribution the skewness is 0, implying a symmetric distribution around the mean.
Market Stylized Facts                                                                                   21


    Another important statistical notion is correlation. We mainly need to distinguish two
types5 :

        historical correlation: this refers to a measure for the co-movement of two financial
         time series; suppose we observe from two series a and b a total of N (past) pairs of log
         returns (rna , rnb ), n ‚àà {1, ‚Ä¶ , N}, with mean returns ùúáÃÇ a and ùúáÃÇ b ; the historical (or sample)
         correlation ùúåÃÇ is then defined as
                                         ‚àëN ( a           )( b         )
                                            n=1 rn ‚àí ùúáÃÇ      rn ‚àí ùúáÃÇ b
                                                        a
                                  ùúåÃÇ = ‚àö
                                        ‚àëN ( a        ) ‚àëN (
                                                     a 2
                                                                          )
                                                                         b 2
                                         n=1 rn ‚àí ùúáÃÇ        n=1 rn ‚àí ùúáÃÇ
                                                                   b


        instantaneous correlation: suppose we are given two standard Brownian motions Z a , Z b ;
         the instantaneous correlation ùúå between both is then given by ‚ü®Z a , Z b ‚ü©t = ùúåt where ‚ü®‚ãÖ‚ü©t
         denotes the quadratic variation process (cf. Protter (2005), pp. 66‚Äì77); one can also write
         dZ a dZ b = ùúådt where the meaning of ‚Äúinstantaneous‚Äù becomes more evident

    Equipped with this set of definitions we can now proceed and apply (some of) them to
both artificial data and real data.


3.3 NORMAL RETURNS AS THE BENCHMARK CASE

As the benchmark case, we consider the geometric Brownian motion model of BSM given by
the SDE

                                           dSt = rSt dt + ùúéSt dZt

A discrete version, which can easily be simulated, is given by the difference equation
                                                    (            )    ‚àö
                                                        r‚àí 12 ùúé 2 Œît+ùúé Œîtzt
                                       St = St‚àíŒît e

for times t ‚àà {Œît, 2Œît, ‚Ä¶ , T} and the zt being standard normally distributed random variables.
      We parametrize the model with S0 = 100, T = 10.0, r = 0.05, ùúé = 0.2. The Python script
in sub-section 3.8.1 contains these parameters and a simulation algorithm as well as imple-
menting a number of test routines. In addition, it generates a variety of graphical plots.6
      Figure 3.1 presents a simulated path for the index level in combination with the daily log
returns. From first inspection, the index development seems realistic and indistinguishable from
typical charts seen in the financial press. Figure 3.2 shows the frequency of daily log returns
and compares these to a normal distribution. The fit seems quite good‚Äîa fact to be expected
since the characteristic feature of geometric Brownian motion is normally distributed returns.
      Similary, Figure 3.3 illustrates the normality of the returns by a so-called quantile-quantile
plot or Q-Q plot. All return realizations lie on the straight line in such a case.

5
    Cf. Rebonato (2004) for an in-depth discussion of correlation in the context of option pricing.
6
    The script assumes 252 business days per year for the artificial data.
22                                                        DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 3.1 A single simulated path for the geometric Brownian motion over a 10-year period with
daily log returns




FIGURE 3.2 Histogram of the daily log returns (bars) and for comparison the probability density
function of the normal distribution with the sample mean and volatility (line)
     Market Stylized Facts                                                                       23




                 FIGURE 3.3 Quantile-quantile plot of the daily log returns of the geometric
                 Brownian motion


          However, statistical tests may help in gaining further confirmation of the graphical evi-
     dence. To this end, the Python script calculates several sample statistics and conducts a total
     of three tests. For the particular process shown in Figure 3.1, the statistics are:


 1    RETURN SAMPLE STATISTICS
 2    ---------------------------------------------
 3    Mean of Daily Log Returns 0.000078
 4    Std of Daily Log Returns            0.012746
 5    Mean of Annua. Log Returns          0.019689
 6    Std of Annua. Log Returns           0.202336
 7    ---------------------------------------------
 8    Skew of Sample Log Returns -0.024305
 9    Skew Normal Test p-value    0.617420
10    ---------------------------------------------
11    Kurt of Sample Log Returns 0.127744
12    Kurt Normal Test p-value    0.190342
13    ---------------------------------------------
14    Normal Test p-value         0.374472
15    ---------------------------------------------
16    Realized Volatility                 0.202340
17    Realized Variance                   0.040941



          Some comments on the results:

      1. volatility: the annualized standard deviation of the log returns equals almost exactly the
         instantaneous volatility ùúé = 0.2 of the geometric Brownian motion
24                                                               DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 3.4        Realized volatility for the simulated path of the geometric Brownian motion


    2. skewness: the skewness is almost zero and the high p-value of the normal skewness test
       indicates that the distribution of the log returns is normal
    3. kurtosis: although the kurtosis is slightly positive, the p-value of the normal kurtosis test
       nevertheless also indicates normal distribution
    4. normality: finally, the joint test for normality indicates a normal distribution with a
       p-value of 0.426

     All in all, we can conclude that the simulated index level path exhibits, as desired, normally
distributed log returns. The sample annualized volatility also coincides with the instantaneous
volatility of the BSM model.
     What about realized volatility and variance? To begin with, realized volatility is a special
form of historical volatility and can be seen as a process. While historical volatility is computed
for a fixed time window or a fixed number of observations, realized volatility evolves over
time. Assume we started in January 2004 with say five observations and compute the sample
volatility for the first time. Now, one day later when the 6th observation is available we update
the volatility value to include the 6th observation as well. In this fashion, realized volatility is
constantly updated.7
     Figure 3.4 illustrates the evolution of realized volatility over time. It obviously converges
to the above reported value of 0.202 which is almost the same as the instantaneous volatility.
     Finally, Figure 3.5 shows the rolling mean return and the rolling (realized) volatility for
time windows of 252 days, i.e. 1 year. In addition, the figure also displays the rolling correlation
between the two over a time window of same length. Even though the realized volatility and the
sample volatility for all returns coincide with the constant instantaneous volatility, the rolling

7
    Cf. Andersen and Benzoni (2009) for a survey of realized volatility and related research.
Market Stylized Facts                                                                             25




FIGURE 3.5 Rolling mean log return (252 days), rolling volatility (252 days) and rolling correlation
between both (252 days) for geometric Brownian motion; dashed lines are averages over the whole
period shown


volatility varies strongly around the level of 20%. The volatility and return measures are
sometimes positively correlated (move in the same direction) and sometimes negatively‚Äîon
average the correlation is ùúåÃÇ = ‚àí0.0529.


3.4 INDICES AND STOCKS

Before turning to options, this section reproduces stylized facts of stock indices and stocks.

3.4.1 Stylized Facts
In this sub-section, we briefly list and describe some stylized facts about stock index returns.
Stylized facts can be described as follows (cf. Cont (2001), p. 223):

     ‚ÄúA set of [statistical] properties, common across many instruments, markets and time
     periods, has been observed by independent studies and classified as ‚Äòstylized facts‚Äô.‚Äù

    Below we list a selection of stylized facts. The emphasis is on comparing these facts
with the benchmark case of BSM where volatility is constant and returns are normally
    26                                                          DERIVATIVES ANALYTICS WITH PYTHON


    distributed. Among those stylized facts about index returns that are important for our
    purposes are8 :

       stochastic volatility: volatility is neither constant nor deterministic; there is no mechanism
        to forecast volatility at a high confidence level
       volatility clustering: empirical data suggests that high volatility events seem to cluster

        in time; there is often a positive autocorrelation of volatility measures
       volatility mean reversion: volatility is a mean-reverting quantity‚Äîit never reaches zero

        nor does it go to infinity; however, the mean can change over time
       leverage effect: studies suggest that volatility is negatively correlated with asset returns;

        if return measures increase, volatility measures often decrease and vice versa
       fat tails: compared to a normal distribution large positive and negative index returns are

        more frequent
       jumps: index levels may move by magnitudes that cannot be explained within a Gaussian,

        i.e. normal, diffusion setting; some jump component may be necessary to explain certain
        large moves


    3.4.2 DAX Index Returns
    We will now test whether we can identify evidence for the stylized facts of the previous sub-
    section in the log returns of the DAX index. We analyze the period from 01. October 2004 to
    30. September 2014.9 The following is a small selection of the raw data used. All results and
    graphics reported hereafter are based on the adjusted close numbers from Yahoo! Finance.


1                    index           returns        rea_var         rea_vol
2    Date
3    2014-09-24      9661.97          0.006952      0.047792        0.218614
4    2014-09-25      9510.01         -0.015853      0.047798        0.218628
5    2014-09-26      9490.55         -0.002048      0.047780        0.218586
6    2014-09-29      9422.91         -0.007153      0.047766        0.218555
7    2014-09-30      9474.30          0.005439      0.047751        0.218519



         Figure 3.6 shows the index levels and the daily log returns graphically. On first inspection,
    the development of the index is not too different from the picture for the geometric Brownian
    motion. However, the daily log returns speak quite a different language: the (average) ampli-
    tudes change over time indicating at least time-varying volatility and there also seems to be
    volatility clustering.
         Figure 3.7 compares the sample frequency of log returns with a normal distribution that
    has the same mean and standard deviation. The sample distribution has both a higher peak

    8
      Cf. Cont (2001) for a concise survey. Cf. Rebonato (2004), in particular chapter 7, for a wealth of
    information regarding empirical findings about equity markets and equity options.
    9
      Source of DAX index quotes http://finance.yahoo.com. We use the data as delivered by the site, no
    adjustments have been made.
Market Stylized Facts                                                                         27




FIGURE 3.6 DAX index level quotes and daily log returns over the period from 01. October 2004 to
30. September 2014




FIGURE 3.7 Histogram of the daily log returns of the DAX over the period from 01. October 2004 to
30. September 2014 (bars) and for comparison the probability density function of the normal
distribution with the sample mean and volatility (line)
     28                                                          DERIVATIVES ANALYTICS WITH PYTHON




                FIGURE 3.8     Quantile-quantile plot of the daily log returns of the DAX over
                the period from 01. October 2004 to 30. September 2014



     and heavier tails. However, skewness seems comparable‚Äîthere is neither ‚Äúleft-leaning‚Äù nor
     ‚Äúright-leaning‚Äù of the sample distribution.
          Finally, Figure 3.8 shows the Q-Q plot for the DAX log returns. This also illustrates well
     the deviation from the normal distribution.
          We can also test our findings more rigorously, at least with respect to the obviously
     non-normal distribution. Here is the output of the Python script of sub-section 3.8.2:


 1    RETURN SAMPLE STATISTICS
 2    ---------------------------------------------
 3    Mean of Daily Log Returns 0.000348
 4    Std of Daily Log Returns            0.013761
 5    Mean of Annua. Log Returns          0.087656
 6    Std of Annua. Log Returns           0.218449
 7    ---------------------------------------------
 8    Skew of Sample Log Returns 0.025083
 9    Skew Normal Test p-value    0.603591
10    ---------------------------------------------
11    Kurt of Sample Log Returns 7.205877
12    Kurt Normal Test p-value    0.000000
13    ---------------------------------------------
14    Normal Test p-value         0.000000
15    ---------------------------------------------
16    Realized Volatility         0.218519
17    Realized Variance           0.047751
18
Market Stylized Facts                                                                          29




FIGURE 3.9 Realized volatility for the DAX over the period from 01. October 2004 to 30.
September 2014



     Over the sample period, the DAX index generates an annualized return of about 8.7%.
The historical/realized volatility is about 21.9%. All test results say that the null hypothesis
that ‚Äúthe sample distribution is normal‚Äù can be rejected with high significance. The impression
about the kurtosis is also supported by the high value of 7.2‚Äîwe have fat tails.
     What about realized volatility over time? Figure 3.9 illustrates that the realized volatility
varies over time and that it does not seem to converge (at least not strongly). In the beginning,
it goes down to below 15%, rises again to about 24% to drop and rise again for a bit. This
provides further evidence that volatility is time varying.
     The last point is even better illustrated in Figure 3.10 which shows a rolling yearly
volatility measure. This measure varies between 11% and about 40%. These large deviations
are much stronger than the deviations observed in Figure 3.5 for the geometric Brownian
motion. This holds true for both deviations from the average and with respect to the difference
between maxima and minima. Nevertheless, volatility obviously is mean reverting.
     What about the leverage effect? Comparison of the upper and middle sub-plots of Fig-
ure 3.10 indeed indicates a negative correlation. This is supported by the negative average
(line) in the lower sub-plot. However, the yearly rolling correlation measure in the lower
sub-plot varies strongly taking almost extreme values in regular cycles. Regularly, correlation
even comes quite close to +1.0 or ‚àí1.0.
     So far, we have found evidence for time-varying/stochastic volatility, clustering, mean
reversion, leverage effect and fat tails. What about jumps? If we say, somehow arbitrarily, that
a jump is a daily log return of more than ¬±5%, we have a total of 31 jumps in the historical DAX
data. Assuming a normal distribution with the DAX log returns‚Äô sample mean and standard
deviation, the probabilities are P(rn < ‚àí0.05) = 0.0002911 and P(rn > ‚àí0.05) = 0.0003402
for observing such extraordinary returns given a specific return observation rn . Multiplying
these probabilities with the sample size of 2,557 we could expect 0.74 returns lower than ‚àí5%
30                                                          DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 3.10 Rolling mean log return (252 days), rolling volatility (252 days) and rolling
correlation between both (252 days); dashed lines are averages over the whole period shown



and 0.87 returns higher than +5%. Again, we see evidence for fat tails and can interpret these
figures also as hints towards the existence of jumps.10
     All in all, if we want to model an index like the DAX realistically, the model should take
account of:

 1. autocorrelated stochastic volatility
 2. mean reversion of volatility
 3. leverage effect, i.e. negative correlation between returns and volatility
 4. fat tails of and jumps in the index returns



3.5 OPTION MARKETS

This section now turns to options markets, in particular to bid/ask spreads in these markets
and implied volatilities.


10
   These considerations are quite heuristic in nature and are lacking a sound conceptual grounding.
For example, a central question is how to assess the distinct contributions of the jump and diffusion
component, respectively, to observed index movements in a jump-diffusion model. Cf. KloÃàssner (2010)
for a survey of econometric tests for jumps in financial time series.
Market Stylized Facts                                                                            31


3.5.1 Bid/Ask Spreads
A market-based valuation of equity derivatives, both vanilla and exotic, should yield suffi-
ciently accurate values. However, markets are far from being perfect and a number of so-called
market microstructure elements influences prices directly or indirectly. With regard to valua-
tion accuracy it is important that there is in general not a single quote for an option but at least
two: a bid quote at which market makers would buy the option and an ask quote at which they
would sell the option.
     Table 3.1 reports average option quote spreads for call options on stocks in the Dow
Jones Industrial Average (DJIA) index for the period from 1996 to 2010. For the total sample
of about 1.1 mn options, the average spread is 0.227 USD or 7.92% relative to the average
mid-price. These values vary with maturity of the call options and moneyness levels. The
smallest absolute spread with 0.136 USD is observed for out-of-the-money options with short
maturity. The smallest relative spread emerges with 3.7% for in-the-money options with long
maturity. Table 3.2 paints a consistent picture for put option quotes and spreads.
     To put these observations differently, one cannot in general expect to reach a market-based
valuation accuracy of say ‚Äú1 cent or better‚Äù or ‚Äú1% or better‚Äù. The market itself does not quote
options in such a manner and exchanges generally have tick sizes‚Äîi.e. minimum allowed
changes of the price of an option‚Äîmuch higher than 1 cent. For example, in Tables 3.1 and
3.2 the tick size for options with bid quotes below 3 USD is 5 cents. For options with bid
quotes above 3 USD the tick size is 10 cents.

3.5.2 Implied Volatility Surface
Recall that the implied volatility of a European call option with market quote C0‚àó is the value
ùúé imp that solves the implicit equation

                                   C0‚àó = CBSM (S0 , K, T, r, ùúé imp )                          (3.1)

given the BSM call option formula. Chapter 5 discusses the model, the formula and the
sensitivity of the formula with respect to the input volatility (the so-called vega) in detail. At


TABLE 3.1     Option bid/ask spreads for call options on stocks of the DJIA indexa

Category        Type       Number          Maturity         Mid-Price       Spread     Rel. Spread

All              All       1,095,327          96.60           5.185          0.227         7.92%
Short           OTM          125,575          44.26           1.069          0.136        18.72%
Short           ATM          118,027          44.74           2.956          0.184         7.44%
Short           ITM          173,607          44.30           6.561          0.265         4.74%
Long            OTM          191,127         127.57           1.593          0.147        12.63%
Long            ATM          203,790         129.63           4.563          0.226         5.72%
Long            ITM          283,201         128.81           9.967          0.318         3.70%
a
  Data for the period 1996‚Äì2010; OTM, ATM, ITM = out-of-the, at-the, in-the-money options; number =
number of call options included in the sample; maturity = average option maturity in days; mid-
price = middle of bid and ask quotes in USD; spread = USD difference of bid and ask quote; relative
spread = spread relative to mid-price.
Source: Chaudhury (2014).
    32                                                           DERIVATIVES ANALYTICS WITH PYTHON


    TABLE 3.2     Option bid/ask spreads for put options on stocks of the DJIA indexa

    Category        Type        Number         Maturity        Mid-Price       Spread        Rel. Spread

    All              All       1,105,028           96.07          5.093         0.229           7.80%
    Short           OTM          158,486           44.55          1.339         0.148          15.98%
    Short           ATM          120,257           44.63          3.443         0.204           7.12%
    Short           ITM          146,979           43.86          6.858         0.279           4.91%
    Long            OTM          267,847          128.80          2.238         0.172          10.26%
    Long            ATM          201,100          129.33          5.769         0.255           5.18%
    Long            ITM          210,359          127.34         10.621         0.317           3.50%
    a
     Data for the period 1996‚Äì2010; OTM, ATM, ITM = out-of-the, at-the, in-the-money options; number =
    number of put options included in the sample; maturity = average option maturity in days; mid-
    price = middle of bid and ask quotes in USD; spread = USD difference of bid and ask quote; relative
    spread = spread relative to mid-price.
    Source: Chaudhury (2014).


    this stage, it is only important to know, that the vega, i.e. the first derivative of the formula with
    respect to volatility, is strictly positive implying a bijective relationship between call values
    and volatilities and therewith a unique solution to equation (3.1). Sub-section 3.8.3 provides
    a Python script implementing the BSM formula for calls and a numerical routine to solve the
    implicit equation (3.1).
         Equipped with this knowledge, we now want to briefly analyze a real volatility surface.
    Volatility surface means the volatilities implied for different option strikes and different option
    maturities on the same underlying. Our objects of study will be implied volatilities from
    European call options on the EURO STOXX 50 stock index.
         As with index returns, there are some stylized facts about the volatility surface for stock
    indices (cf. Rebonato (2004), chapter 7):

         smiles: option implied volatilities exhibit a smile form, i.e. for calls the OTM implied
          volatilities are higher than the ATM ones; sometimes they rise again for ITM options; this
          is a phenomenon present in the financial markets mainly since the market crash of 1987
         term structure: smiles are more pronounced for short-term options than for longer-term

          options; a phenomenon sometimes called volatility term structure

        The script in sub-section 3.8.4 uses a set of option quotes for different strikes and different
    option maturities. Options are European call options on the EURO STOXX 50 index and the
    quotes are from 30. September 2014. The following is a small excerpt from the data used.

1                Date           Strike     Call      Maturity       Put
2       498      2014-09-30     3750       27.4      2015-09-18     635.9
3       499      2014-09-30     3800       21.8      2015-09-18     680.3
4       500      2014-09-30     3850       17.2      2015-09-18     725.7
5       501      2014-09-30     3900       13.4      2015-09-18     772.0
6       502      2014-09-30     3950       10.4      2015-09-18     818.9


        The script calculates the implied volatilities of the different options and generates a
    graphical output as shown in Figure 3.11. The results reflect the stylized facts rather well.
Market Stylized Facts                                                                                33




FIGURE 3.11         Implied volatilities from European call options on the EURO STOXX 50 on 30.
September 2014


3.6 SHORT RATES

Short rates and associated discount factors are not only important for the valuation of options.
Short rates are, in a sense, the least common denominator of all asset pricing models‚Äîbe it for
primary asset classes (e.g. stocks, bonds, commodities) or derivative assets, be it in complete
or incomplete market models (cf. Hansen and Renault (2009)). As intensively discussed in
Chapter 4, short rates and their corresponding discount factors are a basic building block for
the risk-neutral valuation approach and the Fundamental Theorem of Asset Pricing.
     However, empirical evidence about the dynamics of short rates is not as clear as one would
wish. A recent empirical study by Bali-Wu opens with the words (cf. Bali and Wu (2006),
pp. 1269‚Äì1270):

         ‚ÄúThe short-term interest rate is a fundamental variable in both theoretical and empir-
         ical finance because of its central role in asset pricing. An enormous amount of work
         has been directed towards the understanding of the stochastic behavior of short-term
         interest rates. Nevertheless, based on different data sets and/or different parametric or
         non-parametric specifications, these studies have generated confusing and sometimes
         conflicting conclusions.‚Äù

   Nevertheless, some stylized facts are also worth reporting with respect to short rates.11
Those that are most important in terms of financial modeling requirements are:

        positivity: (nominal) interest rates are positive in general; a formal model should take
         this into account

11
  Cf. BjoÃàrk (2009) for a concise survey of interest rate types and modeling. Cf. Brigo and Mercurio
(2006) for a comprehensive treatment of current interest rate modeling.
34                                                              DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 3.12 Daily quotes of 1 week Euribor and daily log changes over the period from 01.
January 1999 to 30. September 2014


      stochasticity: interest rates in general and short rates in particular move in random fashion;
       there are no means to forecast interest rates movements with high confidence
      mean reversion: interest rates can neither trend to zero nor infinity in the long term such

       that there must always be the phenomenon of mean reversion
      term structure: yields of benchmark bonds‚Äîlike German bunds‚Äîas well as rates in

       interbank lending vary with time to maturity implying different (instantaneous) forward
       rates, i.e. different future short rate levels

     The Euribor, which stands for ‚ÄúEuro InterBank Offered Rate‚Äù, is a benchmark rate for
interbank lending. There are Euribor rates for different maturities, starting with 1 week and
ranging to 1 year. Figure 3.12 shows the daily quotes of the 1 week Euribor from January 1999
to the end of September 2014 as well as the daily log changes. With regard to the daily changes
there are a number of outliers and we can also observe something like volatility clustering.
The figure also provides support for the first three stylized facts. This figure has been produced
with the Python script found in sub-section 3.8.5. This script uses an Excel workbook which
contains the whole Euribor dataset from 1999 to September 2014.12 Figure 3.13 shows the
histogram of the daily log changes in comparison to a normal distribution with same mean
and standard deviation. The histogram has a relatively high peak.
     Figure 3.14 illustrates the deviation of the daily log change distribution from normality
by a Q-Q plot.
     Figure 3.15 shows the daily quotes of the Euribor for 1 week, 1 month, 6 months and 1 year
in comparison. The general picture is one with a normal term structure (longer horizons show

12
     Source: http://www.euribor-ebf.eu/euribor-org/euribor-rates.html.
Market Stylized Facts                                                                           35




FIGURE 3.13 Histogram of daily log changes in 1 week Euribor in comparison to a normal
distribution with same mean and standard deviation (line)




        FIGURE 3.14     Quantile-quantile plot of the daily log changes in the 1 week Euribor
36                                                       DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 3.15 Daily quotes of 1 week (dotted), 1 month (dot-dashed), 6 months (dashed) and 1 year
Euribor (solid line) over the period from 01. January 1999 to 30. September 2014


higher rates) but there are also periods with inverted term structure where short-term borrowing
becomes more expensive than long-term borrowing. The financial crisis of 2008/2009 caused
a large drop in the overall level of Euribor rates accompanied by a widening of the spreads
(steeper term structure).


3.7 CONCLUSIONS

A realistic market model ‚Ä¶

   ‚Ä¶ has to take into account that index volatility
    ‚Äì varies over time (stochasticity, mean reversion, clustering)
    ‚Äì is negatively correlated with returns (leverage effect)
    ‚Äì varies for different option strikes (volatility smile)
    ‚Äì varies for different option maturities (volatility term structure)
   ‚Ä¶ has to account for jumps in the index development
   ‚Ä¶ has to take into account that interest rates

    ‚Äì vary over time (positivity, stochasticity, mean reversion)
    ‚Äì vary for different time horizons (term structure)

Such a model therefore comprises (at least)

   a stochastic volatility component
   a jump component and
   a stochastic short rate component
Market Stylized Facts                                                    37


3.8 PYTHON SCRIPTS

3.8.1 GBM Analysis

#
# Analyzing Returns from Geometric Brownian Motion
# 03_stf/GBM_returns.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
import pandas as pd
import scipy.stats as scs
import statsmodels.api as sm
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rcParams['font.family'] = 'serif'


#
# Helper Function
#



def dN(x, mu, sigma):
     ''' Probability density function of a normal random variable x.


     Parameters
     ==========
     mu: float
           expected value
     sigma: float
           standard deviation


     Returns
     =======
     pdf: float
           value of probability density function
     '''
     z = (x - mu) / sigma
     pdf = np.exp(-0.5 * z ** 2) / math.sqrt(2 * math.pi * sigma ** 2)
     return pdf



#
# Simulate a Number of Years of Daily Stock Quotes
#
38                                                      DERIVATIVES ANALYTICS WITH PYTHON


def simulate_gbm():
     # model parameters
     S0 = 100.0     # initial index level
     T = 10.0     # time horizon
     r = 0.05     # risk-less short rate
     vol = 0.2     # instantaneous volatility


     # simulation parameters
     np.random.seed(250000)
     gbm_dates = pd.DatetimeIndex(start='30-09-2004',
                                      end='30-09-2014',
                                      freq='B')
     M = len(gbm_dates)       # time steps
     I = 1   # index level paths
     dt = 1 / 252.     # fixed for simplicity
     df = math.exp(-r * dt)      # discount factor


     # stock price paths
     rand = np.random.standard_normal((M, I))         # random numbers
     S = np.zeros_like(rand)       # stock matrix
     S[0] = S0     # initial values
     for t in range(1, M):      # stock price paths
         S[t] = S[t - 1] * np.exp((r - vol ** 2 / 2) * dt
                           + vol * rand[t] * math.sqrt(dt))


     gbm = pd.DataFrame(S[:, 0], index=gbm_dates, columns=['index'])
     gbm['returns'] = np.log(gbm['index'] / gbm['index'].shift(1))



     # Realized Volatility (eg. as defined for variance swaps)
     gbm['rea_var'] = 252 * np.cumsum(gbm['returns'] ** 2) / np.arange(len(gbm))
     gbm['rea_vol'] = np.sqrt(gbm['rea_var'])
     gbm = gbm.dropna()
     return gbm


# Return Sample Statistics and Normality Tests


def print_statistics(data):
     print "RETURN SAMPLE STATISTICS"
     print "---------------------------------------------"
     print "Mean of Daily      Log Returns %9.6f" % np.mean(data['returns'])
     print "Std    of Daily    Log Returns %9.6f" % np.std(data['returns'])
     print "Mean of Annua. Log Returns %9.6f" % (np.mean(data['returns']) * 252)
     print "Std    of Annua. Log Returns %9.6f" % \
                   (np.std(data['returns']) * math.sqrt(252))
     print "---------------------------------------------"
     print "Skew of Sample Log Returns %9.6f" % scs.skew(data['returns'])
     print "Skew Normal Test p-value         %9.6f" % scs.skewtest(data['returns'])[1]
     print "---------------------------------------------"
Market Stylized Facts                                                           39


     print "Kurt of Sample Log Returns %9.6f" % scs.kurtosis(data['returns'])
     print "Kurt Normal Test p-value     %9.6f" % \
                    scs.kurtosistest(data['returns'])[1]
     print "---------------------------------------------"
     print "Normal Test p-value          %9.6f" % \
                    scs.normaltest(data['returns'])[1]
     print "---------------------------------------------"
     print "Realized Volatility          %9.6f" % data['rea_vol'].iloc[-1]
     print "Realized Variance            %9.6f" % data['rea_var'].iloc[-1]

#
# Graphical Output
#

# daily quotes and log returns
def quotes_returns(data):
     ''' Plots quotes and returns. '''
     plt.figure(figsize=(9, 6))
     plt.subplot(211)
     data['index'].plot()
     plt.ylabel('daily quotes')
     plt.grid(True)
     plt.axis('tight')

     plt.subplot(212)
     data['returns'].plot()
     plt.ylabel('daily log returns')
     plt.grid(True)
     plt.axis('tight')

# histogram of annualized daily log returns
def return_histogram(data):
     ''' Plots a histogram of the returns. '''
     plt.figure(figsize=(9, 5))
     x = np.linspace(min(data['returns']), max(data['returns']), 100)
     plt.hist(np.array(data['returns']), bins=50, normed=True)
     y = dN(x, np.mean(data['returns']), np.std(data['returns']))
     plt.plot(x, y, linewidth=2)
     plt.xlabel('log returns')
     plt.ylabel('frequency/probability')
     plt.grid(True)

# Q-Q plot of annualized daily log returns
def return_qqplot(data):
     ''' Generates a Q-Q plot of the returns.'''
     plt.figure(figsize=(9, 5))
     sm.qqplot(data['returns'], line='s')
     plt.grid(True)
     plt.xlabel('theoretical quantiles')
     plt.ylabel('sample quantiles')
40                                               DERIVATIVES ANALYTICS WITH PYTHON


# realized volatility
def realized_volatility(data):
     ''' Plots the realized volatility. '''
     plt.figure(figsize=(9, 5))
     data['rea_vol'].plot()
     plt.ylabel('realized volatility')
     plt.grid(True)


# mean return, volatility and correlation (252 days moving = 1 year)
def rolling_statistics(data):
     ''' Calculates and plots rolling statistics (mean, std, correlation). '''
     plt.figure(figsize=(11, 8))


     plt.subplot(311)
     mr = pd.rolling_mean(data['returns'], 252) * 252
     mr.plot()
     plt.grid(True)
     plt.ylabel('returns (252d)')
     plt.axhline(mr.mean(), color='r', ls='dashed', lw=1.5)


     plt.subplot(312)
     vo = pd.rolling_std(data['returns'], 252) * math.sqrt(252)
     vo.plot()
     plt.grid(True)
     plt.ylabel('volatility (252d)')
     plt.axhline(vo.mean(), color='r', ls='dashed', lw=1.5)
     vx = plt.axis()


     plt.subplot(313)
     co = pd.rolling_corr(mr, vo, 252)
     co.plot()
     plt.grid(True)
     plt.ylabel('correlation (252d)')
     cx = plt.axis()
     plt.axis([vx[0], vx[1], cx[2], cx[3]])
     plt.axhline(co.mean(), color='r', ls='dashed', lw=1.5)




3.8.2 DAX Analysis

#
# Analyzing DAX Index Quotes and Returns
# Source: http://finance.yahoo.com
# 03_stf/DAX_returns.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
Market Stylized Facts                                                             41


import pandas.io.data as web
from GBM_returns import *


# Read Data for DAX from the Web
def read_dax_data():
     ''' Reads historical DAX data from Yahoo! Finance, calculates log returns,
     realized variance and volatility.'''
     DAX = web.DataReader('ÀÜGDAXI', data_source='yahoo',
                        start='30-09-2004', end='30-09-2014')
     DAX.rename(columns={'Adj Close' : 'index'}, inplace=True)
     DAX['returns'] = np.log(DAX['index'] / DAX['index'].shift(1))
     DAX['rea_var'] = 252 * np.cumsum(DAX['returns'] ** 2) / np.arange(len(DAX))
     DAX['rea_vol'] = np.sqrt(DAX['rea_var'])
     DAX = DAX.dropna()
     return DAX


def count_jumps(data, value):
     ''' Counts the number of return jumps as defined in size by value. '''
     jumps = np.sum(np.abs(data['returns']) > value)
     return jumps




3.8.3 BSM Implied Volatilities

#
# Valuation of European Call Options in BSM Model
# and Numerical Derivation of Implied Volatility
# 03_stf/BSM_imp_vol.py
#
# (c) Dr. Yves J. Hilpisch
# from Hilpisch, Yves (2014): Python for Finance, O'Reilly.
#
from math import log, sqrt, exp
from scipy import stats
from scipy.optimize import fsolve

class call_option(object):
     ''' Class for European call options in BSM Model.

     Attributes
     ==========
     S0:    float
           initial stock/index level
     K:    float
           strike price
     t:    datetime/Timestamp object
           pricing date
42                                                DERIVATIVES ANALYTICS WITH PYTHON


     M:    datetime/Timestamp object
           maturity date
     r:    float
         constant risk-free short rate
     sigma: float
         volatility factor in diffusion term


     Methods
     =======
     value: float
         return present value of call option
     vega: float
         return vega of call option
     imp_vol: float
           return implied volatility given option quote
     '''


     def __init__(self, S0, K, t, M, r, sigma):
         self.S0 = float(S0)
         self.K = K
           self.t = t
           self.M = M
           self.r = r
           self.sigma = sigma

     def update_ttm(self):
           ''' Updates time-to-maturity self.T. '''
           if self.t > self.M:
               raise ValueError("Pricing date later than maturity.")
           self.T = (self.M - self.t).days / 365.


     def d1(self):
         ''' Helper function. '''
         d1 = ((log(self.S0 / self.K)
               + (self.r + 0.5 * self.sigma ** 2) * self.T)
               / (self.sigma * sqrt(self.T)))
           return d1


     def value(self):
         ''' Return option value. '''
           self.update_ttm()
           d1 = self.d1()
           d2 = ((log(self.S0 / self.K)
               + (self.r - 0.5 * self.sigma ** 2) * self.T)
               / (self.sigma * sqrt(self.T)))
           value = (self.S0 * stats.norm.cdf(d1, 0.0, 1.0)
               - self.K * exp(-self.r * self.T) * stats.norm.cdf(d2, 0.0, 1.0))
           return value
Market Stylized Facts                                                    43


     def vega(self):
         ''' Return Vega of option. '''
         self.update_ttm()
          d1 = self.d1()
          vega = self.S0 * stats.norm.pdf(d1, 0.0, 1.0) * sqrt(self.T)
          return vega

     def imp_vol(self, C0, sigma_est=0.2):
         ''' Return implied volatility given option price. '''
         option = call_option(self.S0, self.K, self.t, self.M,
                               self.r, sigma_est)
          option.update_ttm()
          def difference(sigma):
              option.sigma = sigma
              return option.value() - C0
          iv = fsolve(difference, sigma_est)[0]
          return iv




3.8.4 EURO STOXX 50 Implied Volatilities

#
# Black-Scholes-Merton Implied Volatilities of
# Call Options on the EURO STOXX 50
# Option Quotes from 30. September 2014
# Source: www.eurexchange.com, www.stoxx.com
# 03_stf/ES50_imp_vol.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import numpy as np
import pandas as pd
from BSM_imp_vol import call_option
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rcParams['font.family'] = 'serif'

# Pricing Data
pdate = pd.Timestamp('30-09-2014')

#
# EURO STOXX 50 index data
#

# URL of data file
es_url = 'http://www.stoxx.com/download/historical_values/hbrbcpe.txt'
# column names to be used
44                                             DERIVATIVES ANALYTICS WITH PYTHON


cols = ['Date', 'SX5P', 'SX5E', 'SXXP', 'SXXE',
        'SXXF', 'SXXA', 'DK5F', 'DKXF', 'DEL']
# reading the data with pandas
es = pd.read_csv(es_url, # filename
                 header=None, # ignore column names
                 index_col=0, # index column (dates)
                  parse_dates=True, # parse these dates
                  dayfirst=True, # format of dates
                  skiprows=4, # ignore these rows
                 sep=';', # data separator
                 names=cols) # use these column names
# deleting the helper column
del es['DEL']
S0 = es['SX5E']['30-09-2014']
r = -0.05

#
# Option Data
#
data = pd.HDFStore('./03_stf/es50_option_data.h5', 'r')['data']


#
# BSM Implied Volatilities
#

def calculate_imp_vols(data):
     ''' Calculate all implied volatilities for the European call options
     given the tolerance level for moneyness of the option.'''
     data['Imp_Vol'] = 0.0
     tol = 0.30 # tolerance for moneyness
     for row in data.index:
         t = data['Date'][row]
         T = data['Maturity'][row]
         ttm = (T - t).days / 365.
         forward = np.exp(r * ttm) * S0
         if (abs(data['Strike'][row] - forward) / forward) < tol:
             call = call_option(S0, data['Strike'][row], t, T, r, 0.2)
             data['Imp_Vol'][row] = call.imp_vol(data['Call'][row])
     return data


#
# Graphical Output
#
markers = ['.', 'o', 'ÀÜ', 'v', 'x', 'D', 'd', '>', '<']
def plot_imp_vols(data):
    ''' Plot the implied volatilites. '''
     maturities = sorted(set(data['Maturity']))
     plt.figure(figsize=(10, 5))
Market Stylized Facts                                                             45


     for i, mat in enumerate(maturities):
         dat = data[(data['Maturity'] == mat) & (data['Imp_Vol'] > 0)]
         plt.plot(dat['Strike'].values, dat['Imp_Vol'].values,
                        'b%s' % markers[i], label=str(mat)[:10])
     plt.grid()
     plt.legend()
     plt.xlabel('strike')
     plt.ylabel('implied volatility')



3.8.5 Euribor Analysis

#
# Analyzing Euribor Interest Rate Data
# Source: http://www.emmi-benchmarks.eu/euribor-org/euribor-rates.html
# 03_stf/EURIBOR_analysis.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import pandas as pd
from GBM_returns import *


# Read Data for Euribor from Excel file
def read_euribor_data():
     ''' Reads historical Euribor data from Excel file, calculates log returns,
     realized variance and volatility.'''
     EBO = pd.read_excel('./03_stf/EURIBOR_current.xlsx',
                              index_col=0, parse_dates=True)
     EBO['returns'] = np.log(EBO['1w'] / EBO['1w'].shift(1))
     EBO = EBO.dropna()
     return EBO


# Plot the Term Structure
markers = [',', '-.', '‚Äì', '-']
def plot_term_structure(data):
     ''' Plot the term structure of Euribor rates. '''
     plt.figure(figsize=(10, 5))
     for i, mat in enumerate(['1w', '1m', '6m', '12m']):
          plt.plot(data[mat].index, data[mat].values,
                        'b%s' % markers[i], label=mat)
     plt.grid()
     plt.legend()
     plt.xlabel('strike')
     plt.ylabel('implied volatility')
     plt.ylim(0.0, plt.ylim()[1])
                 PART
              Two
Theoretical Valuation
                                                                         CHAPTER         4
                                              Risk-Neutral Valuation


4.1 INTRODUCTION

Every sincere attempt to value financial derivatives needs to be grounded on a sound theory,
formally represented in general by some kind of market model. A market model embodies
a simplifying mathematical description of a real financial market. A priori, it is not clear
what features a market model should have. These are mainly dictated by the market under
observation and the tasks to be accomplished (e.g. pricing, trading, hedging, risk management).
However, there is a minimum set of requirements a market model should obey. The most
important are the absence of arbitrage opportunities (NA) and no free lunches with vanishing
risk (NFLVR).
     A central result in mathematical finance is the Fundamental Theorem of Asset Pricing
which relates, for a given market model, the conditions of NA or NFLVR to the existence of
an equivalent martingale measure (EMM) making all discounted stochastic processes of the
market model martingales. A martingale is a stochastic process that does not change its value
on average (under some suitable conditions). An important corollary of this result is that the
(discounted) price processes of attainable, i.e. redundant, options are also martingales giving
rise to a pure probabilistic approach to option pricing. Namely, the value of a European option
maturing at some date in the future is simply its expected payoff at that date under the EMM
discounted back to today by the risk-free short rate.
     The market-based valuation of options is a mainly numerical discipline and therefore
works generally in discrete time and with discrete state spaces. This is due to computers being
able only to store discrete sets of quantities. However, in the valuation process analytical
results from continuous time, continuous state space models are used whenever appropriate.
Unfortunately, the mathematical machinery needed to establish the Fundamental Theorem for
such types of models is well beyond the scope of this book.
     We therefore take a typical‚Äîand for our purposes appropriate‚Äîroute by introducing
the main building blocks of the theory in discrete time and with discrete state space. The
mathematics needed remains on an undergraduate level. Nevertheless, all the fundamental
notions and results of arbitrage pricing and risk-neutral valuation can be presented in an
almost self-contained fashion. The intuitive grasp gained in this discrete model world should
then carry over to the continuous world with its numerous complications. In this setting, the
central results are only stated and references are given for the respective proofs.


                                                                                            49
50                                                                   DERIVATIVES ANALYTICS WITH PYTHON


     There is a large literature on the concepts and results presented in this chapter. Cf. Bhat-
tacharya and Waymire (2007) or Williams (1991) for the fundamental probabilistic concepts.
Cf. Protter (2005) for a comprehensive treatment of stochastic processes and stochastic inte-
gration needed for the continuous time, continuous state space context. The seminal paper
by Harrison and Pliska (1981) is still a highly readable source, in particular for the discrete
case. The book by Pliska (1997) coveres comprehensively arbitrage theory in discrete models
while the book by Delbaen and Schachermayer (2004) should be consulted on the general
theory. The article by Protter (2001) provides a concise survey of the general theory.
     Sections 4.2 through 4.4 cover the discrete time case. Section 4.5 considers continuous
time models. A number of proofs are provided in section 4.7.


4.2 DISCRETE-TIME UNCERTAINTY

In this section, we develop a mathematical model that can capture the notions of risk
and uncertainty in financial markets.1 We consider an economy over a fixed time interval
[0, T] ‚äÇ R+ . T is called the terminal date where we assume T ‚àà N, the set of natural numbers.
At date 0 there is uncertainty about the true state of the economy at the terminal date T. The
set of possible states, however, is known. The set of all possible states ùúî is denoted Œ© and
called the state space. Subsets of Œ© are called events. The family of sets that forms the set of
observable events is an algebra in Œ©.

Definition 1 (Algebra). A family Óà≤ of sets is an algebra in Œ© if:

    1. Œ© ‚àà Óà≤
    2. E ‚àà Óà≤ ‚áí Ec ‚àà Óà≤        ‚ãÉ
    3. E1 , E2 , ‚Ä¶ , EI ‚àà Óà≤ ‚áí Ii=1 Ei ‚àà Óà≤

     Ec denotes the complement of the set E. It is easy to see that the power set ‚Ñò(Œ©) of Œ©, i.e.
the set of all subsets of Œ©, is the largest algebra in Œ© and that the family {‚àÖ, Œ©} is the smallest
one. On the set of observable events Óà≤ , we can define a probability measure. The probability
measure carries information about the probability of observable events to occur.

Definition 2 (Probability Measure).            Let Óà≤ be an algebra in Œ©. A function P : Óà≤ ‚Üí [0, 1] is
a probability measure if:

    1. ‚àÄE( ‚àà Óà≤ : P(E)
                  ) ‚â•  0
          ‚ãÉI          ‚àëI
    2. P    i=1 Ei =   i=1 P(Ei ) for disjoint sets E1 , E2 , ‚Ä¶ , EI ‚àà Óà≤
    3. P(Œ©) = 1

     Two probability measures P and Q, defined on an algebra Óà≤ , are equivalent if they agree
on the same null-sets, P(E) = 0 ‚áî Q(E) = 0, where E ‚àà Óà≤ . A collection (Œ©, Óà≤ , P) of a state
space Œ©, a set of observable events Óà≤ , where Óà≤ is an algebra, and a probability measure P
defined on Óà≤ is called a probability space.

1
    The material of this section is standard, cf. Williams (1991).
Risk-Neutral Valuation                                                                           51


     In general, securities traded in financial markets are risky bets since their future prices are
uncertain. In our simple setup, a natural way to model securities with uncertain future prices
is via functions of the economy‚Äôs state at the terminal date. This motivates the introduction of
random variables and random vectors into the model.

Definition 3 (Random Variable).         Given a probability space (Œ©, Óà≤ , P), a random variable
S is a function

                                     S : Œ© ‚Üí R+ , ùúî ‚Ü¶ S(ùúî)

that is Óà≤ -measurable, i.e., for each E ‚àà {[a, b[: a, b ‚àà R, a < b} one has

                              S‚àí1 (E) ‚â° {ùúî ‚àà Œ© : S(ùúî) ‚àà E} ‚àà Óà≤

A function

                                     S : Œ© ‚Üí RK
                                              + , ùúî ‚Ü¶ S(ùúî)

is a random vector if its component functions

                           Sk : Œ© ‚Üí R+ , ùúî ‚Ü¶ Sk (ùúî), k ‚àà {1, ‚Ä¶ , K}

are Óà≤ -measurable. A random vector S is Óà≤ -measurable if all component functions Sk are
Óà≤ -measurable.

    It is sometimes convenient to write S‚ààÓà≤ for ‚ÄúS is Óà≤ -measurable‚Äô where S can be either a
random variable or a random vector.

Definition 4 (Expectation). Let a probability space (Œ©, Óà≤ , P) be given where Œ© is finite.
The expectation EP [S] of a random variable (or vector) S under a probability measure P is
defined as
                                               ‚àë
                                    EP [S] ‚â°         P(ùúî) ‚ãÖ S(ùúî)
                                               ùúî‚ààŒ©

The expectation of a random variable is real-valued whereas the expectation of a random
vector is again a vector.

     With respect to this definition, it is important to recall that we have defined random
variables as taking only positive values on the real line. Otherwise we ought to be more
careful.
     So far we have assumed that at date 0 there is uncertainty with regard to the state of the
economy at the terminal date T. It seems more realistic, however, to assume that uncertainty
resolves gradually over time. As before, let Œ© be the set of all possible states of the economy
at date T. Assume now that new information about the true state of the economy at date T
arrives at dates t ‚àà {0, 1, ‚Ä¶ , T}. This concept is general enough for us to interpret the time
52                                                                 DERIVATIVES ANALYTICS WITH PYTHON


interval [t, t + 1[, 0 ‚â§ t < T, between two consecutive dates as a week, a day, an hour or any
other unit of ‚Äúreal‚Äù time.2 We have:

Definition 5 (Filtration). A filtration F is a non-decreasing family of algebras in Œ©, i.e.
F ‚â° (Óà≤t )t‚àà{0,‚Ä¶,T} where Óà≤0 ‚äÜ Óà≤1 ‚äÜ ‚Ä¶ ‚äÜ Óà≤T‚àí1 ‚äÜ Óà≤T .

      We call the collection (Œ©, Óà≤ , F, P) a filtered probability space. In the present context, the
filtration is a model for the resolution of uncertainty over time. If an event E ‚äÜ Œ© is in Óà≤t , then
it is known at date t whether the event may happen or not. In other words, if E is in Óà≤t , one can
decide whether the true state ùúî is in E or not. Hence, Óà≤t can be interpreted as the information
set at date t. In general, we assume that Óà≤0 = {‚àÖ, Œ©} and Óà≤T = ‚Ñò(Œ©), the power set of Œ©.
Economically, this translates into ‚Äúnothing is known at the beginning of the economy‚Äù and
‚Äúeverything is known at the end of the economy‚Äù, respectively. The requirement that the Óà≤t be
non-decreasing means that information cannot be lost.
      In such a dynamic context, one can generalize the idea of a random variable (vector)
straightforwardly to obtain a stochastic (vector) process. This enables one eventually to model
price dynamics of securities.

Definition 6 (Stochastic Process). A stochastic (vector) process (St )t‚àà{0,‚Ä¶,T} is a date-
ordered sequence of random variables (random vectors) St , t ‚àà {0, ‚Ä¶ , T}.

     Suppose that (St )t‚àà{0,‚Ä¶,T} represents the price process of a security. Since the price of a
security at the terminal date depends on the state of the economy at this date, it is reasonable
to assume that its price at date t depends on the information Óà≤t available at date t. This gives
rise to the following concept.

Definition 7 (Adaptation). A stochastic (vector) process (St )t‚àà{0,‚Ä¶,T} is said to be adapted
to a filtration F = (Óà≤t )t‚àà{0,‚Ä¶,T} if ‚àÄt : St is Óà≤t -measurable.

     If security price processes are adapted to the filtration then the economy is informationally
efficient. The mathematical formulation here corresponds to weak form efficiency. In financial
models, one can sometimes find the opposite situation as well: information is generated by
security price processes. To handle such situations one needs yet another concept:

Definition 8 (Algebra Generation).          The algebra generated by a random variable (or
vector) S is denoted Óà≤ (S) and is the smallest algebra with respect to which S is measurable.
The algebra generated by a stochastic (vector) process (St )t‚àà{0,‚Ä¶,T} up to date t is denoted
Óà≤ (Si : i ‚àà {0, ‚Ä¶ , t}) and is the smallest algebra with respect to which all random variables
(vectors) Si , i ‚àà {0, ‚Ä¶ , t} are measurable.

      In light of this definition, a stochastic process (St )t‚àà{0,‚Ä¶,T} generates the filtration F =
(Óà≤t )t‚àà{0,‚Ä¶,T} where Óà≤t ‚â° Óà≤ (Si : i ‚àà {0, ‚Ä¶ , t}). Of course, the stochastic process is adapted to
the filtration it generates. We also need the following definition:


2
    Cases with varying length of the interval [t, t + 1[ can also be included.
Risk-Neutral Valuation                                                                                  53


Definition 9 (Stopping Time). Let (Œ©, Óà≤ , F, P) be fixed. A random variable ùúè : Œ© ‚Üí [0, T] ‚äÇ
R+ is a Óà≤t -stopping time if {ùúî : ùúè(ùúî) ‚â§ t} ‚àà Óà≤t for all 0 ‚â§ t ‚â§ T.

     We now turn to martingales. Heuristically, a martingale embodies the notion of a fair
investment. Consider a risk-neutral investor who plans to invest in a stock.3 This investor
would call the investment fair if the expected discounted price of the stock at some future
date equals its present price. The investor would deny buying the stock if the actual price is
higher. He would, however, always agree to buy if the price of the stock is below the expected
discounted price. A stock price process satisfying the condition that the expected discounted
price at any future date equals its price today is a so-called martingale.
     To formally define a martingale, the concept of conditional expectation is needed. Taking
expectations as proposed in the respective definition presumes that nothing is known about
the future state of the economy at the terminal date. In other words, the minimal algebra
{‚àÖ, Œ©} forms the information set. If uncertainty is gradually resolved, the information set
enlarges over time and allows better expectations to be taken. Here, better means that expec-
tations are taken conditional on a relatively enlarged information set. Formally, one has the
following.

Definition 10 (Conditional Expectation). Let (Œ©, Óà≤ , F, P) be given. The conditional expecta-
tion EPt [S] of a random variable (vector) S given information Óà≤t is the unique random variable
(vector) that satisfies:


    1. EPt [S] is Óà≤t -measurable
    2. ‚àÄE ‚àà Óà≤t : EP [EPt [S] ‚ãÖ 1E ] = EP [S ‚ãÖ 1E ]


    For notational simplicity, we denote the conditional expectation by EPt [‚ãÖ] instead of
EP [‚ãÖ|Óà≤t ]
         as often found in the literature. This eventually enables the definition of a
martingale.

Definition 11 (Martingale).         Let (Œ©, Óà≤ , F, Q) be given. A F-adapted stochastic process
(St )t‚àà{0,‚Ä¶,T} is a (vector) martingale under the probability measure Q if


                                 ‚àÄt, s ‚â• 0, t + s ‚â§ T : EQ
                                                         t [St+s ] = St


     A probability measure Q that makes a stochastic process‚Äîdefined on some filtered
probability space (Œ©, Óà≤ , F, P)‚Äîa martingale is called a martingale measure. Whenever Q is
P-equivalent, it is called a P-equivalent martingale measure.
     It may become necessary to change from one probability measure to an equivalent prob-
ability measure, say from P to Q. This is where the Radon-Nikodym derivative comes into
play.


3
 An investor is risk neutral if he/she is indifferent between a sure amount of money and a risky investment
with an expected (discounted) payoff equally as high.
54                                                               DERIVATIVES ANALYTICS WITH PYTHON


Definition 12    Let (Œ©, Óà≤ , P) be given where Œ© is finite. For a P-equivalent probabil-
ity measure Q, the Radon-Nikodym derivative L, which is actually a random variable, is
defined by
                                                    {
                                                        Q(ùúî)
                                                             for P(ùúî) ‚â† 0
                              ‚àÄùúî ‚àà Œ© : L(ùúî) ‚â°           P(ùúî)
                                                         0 for P(ùúî) = 0

     We conclude this section with a demonstration of how the Radon-Nikodym derivative
may be applied in computing expectations. Let two equivalent probability measures P and Q,
defined on an algebra Óà≤ in a finite state space Œ©, be given. It holds that EQ [S] = EP [LS] for
a random variable (vector) S defined on (Œ©, Óà≤ , P). Easy manipulations of EQ [S] verify this
claim:
                                         ‚àë
                              EQ [S] =       Q(ùúî) ‚ãÖ S(ùúî)
                                              ùúî‚ààŒ©

                                              ‚àë              Q(ùúî)
                                          =         P(ùúî) ‚ãÖ        ‚ãÖ S(ùúî)
                                              ùúî‚ààŒ©
                                                             P(ùúî)
                                              ‚àë
                                          =         P(ùúî) ‚ãÖ L(ùúî) ‚ãÖ S(ùúî)
                                              ùúî‚ààŒ©

                                          = EP [LS]


4.3 DISCRETE MARKET MODEL

4.3.1 Primitives
We consider a model of uncertainty as examined in the previous section. The model econ-
omy lasts for a fixed period [0, T], where T ‚àà N and T < ‚àû. A filtered probability space
(Œ©, ‚Ñò(Œ©), F, P) is fixed where Œ© is the finite state space of which each element ùúî ‚àà Œ© rep-
resents one possible state of the economy at the terminal date T. New information about the
true state of the economy at date T only arrives at dates t ‚àà {0, 1, ‚Ä¶ , T}.4 Economic activity
is also observed at these dates only. At date T all economic activity ends. A time interval
]t, t + 1[ belongs to each date t ‚â§ T ‚àí 1 where there is no economic activity. The filtration
F = (Óà≤t )t‚àà{0,‚Ä¶,T} satisfies Óà≤0 ‚â° {‚àÖ, Œ©} and Óà≤T ‚â° ‚Ñò(Œ©). The probability measure P is strictly
positive for all ùúî ‚àà Œ©, i.e. ‚àÄùúî ‚àà Œ© : P(ùúî) > 0. As a consequence, the probability measure P
is uniquely defined up to equivalence.
      There is a set S of K + 1 securities available in the marketplace whose price processes are
modeled by the vector process

                                    (St )t‚àà{0,‚Ä¶,T} , ‚àÄt : St ‚àà R++
                                                                K+1



4
 Typically, models in which information only arrives at certain points in time are referred to as discrete
time models.
Risk-Neutral Valuation                                                                                  55


The first security, k = 0, is called bond and its price process is denoted (St0 )t‚àà{0,‚Ä¶,T} . The
bond plays a special role since it is assumed to be risk-less and serves as numeraire, so we set
S00 ‚â° 1.5 Formally, risk-less means that the random variable

                                      St0 : Œ© ‚Üí R++ , ùúî ‚Ü¶ St0 (ùúî)

is Óà≤t‚àí1 -measurable, i.e. ‚àÄt ‚â• 1 : St0 ‚àà Óà≤t‚àí1 . In other words, the actual value of St0 is already
known at date t ‚àí 1. The remaining K securities are risky and modeled by a stochastic process
each. The price process of the k-th security, k ‚â• 1, is denoted (Stk )t‚àà{0,‚Ä¶,T} and is adapted to the
filtration F. Recall that adapted means that the random variables Stk : Œ© ‚Üí R++ , ùúî ‚Ü¶ Stk (ùúî)
are measurable with respect to Óà≤t , i.e. ‚àÄk, t : Stk (ùúî) ‚àà Óà≤t . In other words, the actual value of Stk
is not known until date t. Finally, we denote the discount process by (ùõΩt )t‚àà{0,‚Ä¶,T} and define
           ( )‚àí1
‚àÄt : ùõΩt ‚â° St0 .


4.3.2 Basic Definitions
We will now introduce several central expressions that are closely related to securities trading.

Definition 13 (Portfolio).       A portfolio ùúôt is a K + 1-dimensional vector ùúôt ‚àà RK+1 .

    A portfolio ùúôt = (ùúô0t , ‚Ä¶ , ùúôK
                                 t ) gives the number ùúôt of every security k ‚àà {0, ‚Ä¶ , K} held
                                                        k

by an agent at date t. For example, ùúô0t represents the number of bonds in the portfolio ùúôt at
date t. The portfolio ùúô0 has the natural interpretation of being the initial endowment of an
agent since agents will be allowed to form a new portfolio for the first time when prices S0 are
announced. This portfolio is then labeled ùúô1 , and has to be held during the time interval [0, 1[.

Definition 14 (Value of Portfolio). The market value Vt of a portfolio ùúôt in S at date t is
given by a function Vt : RK+1 √ó R++
                                 K+1
                                     ‚Üí R where

                                            {
                                                ùúô1 ‚ãÖ S0   for t = 0
                              Vt (ùúô, S) ‚â°
                                                ùúôt ‚ãÖ St   for t ‚àà {1, ‚Ä¶ , T}



Definition 15 (Predictability). ùúôt is predictable if it is Óà≤t‚àí1 -measurable, i.e. if ‚àÄt ‚â• 1 : ùúôt ‚àà
Óà≤t‚àí1 .

Predictability implies that the portfolio ùúôt be formed at t ‚àí 1 and kept constant during the
interval [t ‚àí 1, t]. At date t, when prices St are announced, the portfolio has a market value of
Vt (ùúô, S) = ùúôt ‚ãÖ St . This amount can then be used, for instance, to form a new portfolio ùúôt+1 ,
which is to be held constant over the interval [t, t + 1], and so forth.

5
 This assumption comes along with virtually no real loss of generality but it facilitates intuition consid-
erably.
56                                                         DERIVATIVES ANALYTICS WITH PYTHON


Definition 16 (Trading Strategy). A trading strategy is a predictable vector process

                                          (ùúôt )t‚àà{0,‚Ä¶,T}

with component processes (ùúôkt )t‚àà{0,‚Ä¶,T} , k ‚àà {0, ‚Ä¶ , K}. (ùúôt )t‚àà{0,‚Ä¶,T} is predictable if ‚àÄt ‚â•
1 : ùúôt is predictable.

      Two other processes are directly associated with each trading strategy.

Definition 17 (Value Process, Gains Process).        We have the following two important pro-
cesses:

 1. The value process (Vt (ùúô, S))t‚àà{0,‚Ä¶,T} of a trading strategy in S is a real-valued, F-adapted
    process where Vt (ùúô, S) is given by definition 14.
 2. The gains process (Gt (ùúô, S))t‚àà{0,‚Ä¶,T} of a trading strategy in S is a real-valued, F-
    adapted process where we set G0 ‚â° 0 and where Gt : RK+1 √ó RK+1      ++ ‚Üí R with Gt (ùúô, S) ‚â°
    ‚àët
      i=1 ùúôi ‚ãÖ (Si ‚àí Si‚àí1 ) for t ‚â• 1.

     In the analysis to follow, two classes of trading strategies are of particular interest: self-
financing and admissible trading strategies.

Definition 18 (Self-Financing Strategy). A trading strategy is self-financing if and only
if ‚àÄt : 1 ‚â§ t ‚â§ T ‚àí 1 : ùúôt ‚ãÖ St = ùúôt+1 ‚ãÖ St or equivalently if and only if ‚àÄt : 1 ‚â§ t ‚â§ T ‚àí 1 :
Vt (ùúô, S) = V0 (ùúô, S) + Gt (ùúô, S). Neither are funds withdrawn nor additional funds invested
at dates between t = 1 and t = T ‚àí 1.

Definition 19 (Admissible Strategy). A trading strategy ùúô in S is admissible if ùúô0 = 0
(no initial endowment/value), if it is self-financing and if its value process (Vt (ùúô, S))t‚àà{0,‚Ä¶,T}
is bounded from below, i.e. if it satisfies ‚àÄt : Vt (ùúô, S) ‚â• ‚àíùõº, ùõº > 0. T denotes the set of all
admissible trading strategies.

    Agents who can only implement admissible trading strategies are not allowed to produce
a position of too much debt. In other words, agents cannot implement trading strategies that
possibly lead to infinite debt (bankruptcy).
    To conclude this sub-section, assume that markets are perfect (i.e. no transaction costs,
complete and symmetric information, etc.) and perfectly liquid. In summary, one ends up with:

Definition 20 (Discrete Market Model).        A discrete market model Óàπ is a collection of:

   a finite state space Œ©
   a filtration F
   a strictly positive probability measure P defined on ‚Ñò(Œ©)
   a terminal date T ‚àà N, T < ‚àû and

   a set S ‚â° {(Sk )
                    t t‚àà{0,‚Ä¶,T} : k ‚àà {0, ‚Ä¶ , K}} of K + 1 strictly positive security price pro-
    cesses

      We write Óàπ = {(Œ©, ‚Ñò(Œ©), F, P), T, S}.
Risk-Neutral Valuation                                                                          57


4.4 CENTRAL RESULTS IN DISCRETE TIME

This section‚Äôs main objective is to state the Fundamental Theorem of Asset Pricing in a
discrete market model. In economic terms, central topics of this section are arbitrage-freeness,
arbitrage-free contingent claim prices and market completeness.
     A central problem in financial economics is the determination of fair contingent claim
prices. One can think of contingent claims as being derivative securities, consumption payoffs
or arbitrary claims payable at T. In order to proceed, however, a formal definition of a
contingent claim is needed.

                                                                            |Œ©|
Definition 21 (Contingent Claim).          A contingent claim AT ‚àà R+ is a non-negative random
variable

                                    AT : Œ© ‚Üí R+ , ùúî ‚Ü¶ AT (ùúî)

AT (ùúî) is the amount payable if state ùúî ‚àà Œ© unfolds.

     A natural question that arises is that of the attainability of contingent claims.

Definition 22 (Attainability). A contingent claim AT is attainable if there exists an admissible
trading strategy ùúô ‚àà T that generates its payoff at maturity6 , VT (ùúô) = AT , and if A0 ‚â° V0 (ùúô)
                                                               |Œ©|
is the price or value of the contingent claim at t = 0. A ‚äÜ R+ denotes the set of attainable
contingent claims.

     Another question is which contingent claims are super-replicable.

Definition 23 (Super-Replication). A contingent claim AT is super-replicable if there exists
an admissible trading strategy ùúô ‚àà T that generates a payoff dominating the contingent claim‚Äôs
payoff, VT (ùúô) ‚â• AT , and if A0 ‚â° V0 (ùúô) are the associated super-replication costs at t = 0.7
                                                                               |Œ©|
Such a trading strategy is said to super-replicate the contingent claim. A‚àó ‚äÜ R+ denotes the
set of super-replicable contingent claims.

    Obviously, the set of attainable contingent claims A is in general a sub-set of the set of
super-replicable contingent claims A‚àó .

Definition 24 (Linear Price System).            A linear price system is a positive linear function
ùúÅ : A ‚Üí R+ with
                                    {
                  ‚àÄa, b ‚àà R+ ,          ùúÅ (AT ) = 0 ‚áî AT = 0
                                :
                  ‚àÄAT , A‚Ä≤T ‚àà A         ùúÅ (a ‚ãÖ AT + b ‚ãÖ A‚Ä≤T ) = a ‚ãÖ ùúÅ (AT ) + b ‚ãÖ ùúÅ (A‚Ä≤T )


6
Here and in the following, we drop dependence on S in the notations Vt (ùúô, S) and Gt (ùúô, S).
7
Sometimes the definition includes the requirement that the trading strategy be chosen such that it
minimizes the super-replication costs A0 .
58                                                              DERIVATIVES ANALYTICS WITH PYTHON


P denotes the set of all price systems that are consistent with the market model Óàπ, i.e. where


                                ‚àÄùúÅ ‚àà P, ‚àÄùúô ‚àà T : ùúÅ (VT (ùúô)) = V0 (ùúô)


    To further analyze pricing issues, the formal concept of an arbitrage opportunity proves
useful.

Definition 25 (Arbitrage Opportunity). An arbitrage opportunity is a self-financing, admis-
sible trading strategy ùúô ‚àà T whose value process satisfies V0 (ùúô) = 0 and EP0 [VT (ùúô)] > 0.



Definition 26 (Weak Arbitrage Opportunity).         A weak arbitrage opportunity is a self-
financing strategy ùúô (not necessarily admissible) whose value process satisfies V0 (ùúô) = 0 and
VT (ùúô) ‚â• 0 with EP0 [VT (ùúô)] > 0.

     It should be clear that a security market where arbitrage opportunities exist cannot be in
equilibrium. An arbitrage opportunity arises, for example, if there are two or more different
prices for the same contingent claim. A simple arbitrage strategy would then be to sell
the contingent claim at a high price and to buy it at a lower price, thereby locking in the
difference as a risk-less profit. The profit is risk-less because the payoffs at date T of one
contingent claim long and one contingent claim short perfectly compensate each other. Of
course, every agent would try to achieve such a risk-less profit. Local non-satiation of agents
is a sufficient condition. Since agents‚Äô budget sets are unbounded in the presence of arbitrage
opportunities, markets would inevitably be in disequilibrium. That is why the absence of
arbitrage opportunities is a crucial property of equilibrium models. However, from an economic
point of view, the assumption of arbitrage-freeness is rather mild.8
     In light of the above considerations, establishing conditions that guarantee the absence
of arbitrage opportunities in the market model Óàπ is obviously of great importance, which is
what we will do next. To begin with, denote Q to be the set of all probability measures Q that
are equivalent to P and that make the discounted security (vector) price process (ùõΩt St )t‚àà{0,‚Ä¶,T}
a martingale. At this point, the main concepts for reproducing some of the central results of the
risk-neutral valuation approach‚Äîas originally formalized through the works of Harrison and
Kreps (1979) and of Harrison and Pliska (1981) (afterwards HK79 and HP81, respectively)‚Äî
are complete.

Lemma 1 (Weak Arbitrage implies Arbitrage) The existence of a weak arbitrage opportunity
ùúô implies the existence of an arbitrage opportunity.

     Refer to section 4.7 for a proof of this result and the following ones. The next proposition
is important from an economical point of view.


8
 For a discussion on this and other possible model assumptions (e.g. the law of one price) refer to section
1.2 of Pliska (1997).
Risk-Neutral Valuation                                                                        59


Proposition 1 (HP81, prop. 2.6). There is a one-to-one correspondence in the market
model Óàπ = {(Œ©, ‚Ñò(Œ©), F, P), T, S} between price systems ùúÅ ‚àà P and P-equivalent martingale
measures Q ‚àà Q via:

 a. ùúÅ (AT ) = EQ  [ùõΩ ‚ãÖ A ] and
               (0 0 T ) T
 b. Q(E) = ùúÅ ST 1E , E ‚àà ‚Ñò(Œ©)

     Proposition 1 states that there is a one-to-one correspondence between a completely eco-
nomic concept, a price system, and a completely probabilistic concept, a martingale measure.
It should not come as a surprise that this has important implications for the market model. The
importance is impressively illustrated by the following theorem:

Theorem 1 (Fundamental Theorem).          Consider the market model

                                 Óàπ = {(Œ©, ‚Ñò(Œ©), F, P), T, S}

The following three statements are equivalent:

 1. There are no arbitrage opportunities in the market model Óàπ.
 2. The set Q of P-equivalent martingale measures is non-empty.
 3. The set P of consistent linear price systems is non-empty.

     This theorem can be generalized to allow for settings where time, processes and trading
are continuous and the time horizon is infinite. While the objects studied remain essentially the
same, the mathematical machinery needed in such cases goes well beyond the basic concepts
presented in this chapter. The subsequent section considers the continuous case.
     Starting with the economically plausible assumption that a market model is free of arbi-
trage opportunities, Theorem 1 implies that there exists an equivalent martingale measure.
Why this last implication is so important should become clear in light of the following two
results:

Corollary 1 (HP81, p. 228). If the market model Óàπ is arbitrage-free, then there exists
a unique price A0 associated with any contingent claim AT ‚àà A. It satisfies ‚àÄQ ‚àà Q : A0 =
EQ [ùõΩ A ].
  0 T T

     For arbitrary dates t ‚àà {0, ‚Ä¶ , T}, the following result emerges.

Proposition 2 (HP81, prop. 2.9). For every AT ‚àà A

                                    ùõΩt Vt (ùúô) = EQ
                                                 t [ùõΩT ‚ãÖ AT ]

for all dates t ‚àà {0, ‚Ä¶ , T}, for all trading strategies (ùúôt )t‚àà{0,‚Ä¶,T} ‚àà T that generate AT and
for all P-equivalent martingale measures Q ‚àà Q.


Proof.   HP81, Harrison and Pliska (1981), p. 230.
60                                                              DERIVATIVES ANALYTICS WITH PYTHON


    Suppose Theorem 1 applies to the market model Óàπ. From corollary 1 and proposition 2
one obtains as the date t price At of an attainable contingent claim AT

                                        At = ùõΩt‚àí1 ‚ãÖ EQ
                                                     t [ùõΩT ‚ãÖ AT ]

with everything defined as before and particularly Q ‚àà Q. This equation states that the date t
price of an attainable contingent claim is simply the conditional expectation of its discounted
payoff under an appropriate probability measure multiplied by the price of the bond.9 This
seems remarkably simple. Yet considerable effort has to be put in when one wishes to apply
this method to the real marketplace, i.e. when a specific price has to be computed.10
     A brief discussion of market completeness should conclude this section.

Definition 27 (Market Completeness). The market model Óàπ is complete if it is arbitrage-
                                                                         |Œ©|
free and if every contingent claim is attainable or equivalently if A = R+ .

     In discrete time, a convenient characterization of complete markets is possible.

Proposition 3 (HK79). Suppose that the market model Óàπ is arbitrage-free. The market
model Óàπ is complete if and only if Q is a singleton.

     HK79 do not give a formal proof but the argument is straightforward. In discrete time,
the resolution of uncertainty can generally be represented by so-called event trees.11 If one
calculates martingale branch probabilities, one observes that these are unique if markets are
complete. The corresponding equivalent martingale measure is then unique as well. Hence, Q
is a singleton if markets are complete.
     The converse statement follows from the observation that if markets are incomplete then
there are always many probability measures contained in Q. In fact, there are an infinite
number of such probability measures in general. So Q has to be a singleton for markets to be
complete. For a formal proof refer to Lamberton and Lapeyre (1996), pp. 9‚Äì10.
     As an aside, we want to demonstrate that, under certain circumstances, one can interpret
discounted martingale probabilities as Arrow-Debreu security prices.12 The defining property
of an Arrow-Debreu security is that it pays off one unit in a predetermined state and nothing in
other states. Consider an arbitrary Arrow-Debreu security, say, for example, the one that pays
in state ùúî
         ÃÉ ‚àà Œ©. Given the unique P-equivalent martingale measure Q of a complete market
model Óàπ its price Aùúî  ÃÉ at date 0 must be according to proposition 1‚Äîwith the 1 at the ùúî-th
                      0
                                                                                            ÃÉ
position in the payoff vector

                                    Aùúî
                                     ÃÉ
                                     0
                                       = ùõΩT EQ
                                             0
                                               [(0, ‚Ä¶ , 1, ‚Ä¶ , 0)]
                                       = ùõΩT Q(ùúî)
                                               ÃÉ ‚ãÖ1

9
   Note that ùõΩt‚àí1 ‚â° St0 .
10
   One can, for example, rely on statistical estimation methods or on calibration approaches to come up
with a market-consistent martingale measure Q for a given market model.
11
   Event trees are one possible way to graphically represent filtrations. The main feature of these trees
is that every node has a unique predecessor. They should be carefully distinguished from recombining
trees that are sometimes used to illustrate the evolution of the stock price process in the binomial option
pricing model. In recombining trees, nodes may have more than one predecessor.
12
   Yet another expression for Arrow-Debreu security price is state price.
Risk-Neutral Valuation                                                                                     61


Consequently, for there to be no arbitrage the price of the chosen Arrow-Debreu security must
equal the discounted probability under the unique P-equivalent martingale measure for state ùúî   ÃÉ
to pertain. This insight is central to options pricing and is also applied in the continuous case.


4.5 CONTINUOUS-TIME CASE

In the continuous-time case, both the time interval and the state space are subsets of the
real line, t ‚àà [0, T] ‚äÜ R+ , Œ© ‚äÜ R. Again, uncertainty is represented as a filtered probability
space (Œ©, Óà≤ , F, P) where F ‚â° {Óà≤t‚àà[0,T] } is now an increasing family of sigma algebras13 with
Óà≤0 ‚â° {‚àÖ, Œ©} and Óà≤T ‚â° Óà≤ .
     The set of tradable assets is denoted S and consists of K + 1 stochastic processes, each
one modeling the evolution of an asset‚Äôs price over time, Sk : [0, T] √ó Œ© ‚Üí R. We normalize
the price of the risk-less bond by assuming that St0 ‚â° 1 ‚áî ùõΩt ‚â° 1, t ‚àà [0, T], making it the
numeraire of the economy and setting the risk-less rate equal to zero. For the moment, we set
K = 1 such that there is only one risky asset in the economy (e.g. stock, stock index, short
rate). We simply write S for S1 .
     We now proceed, following formally Protter (2005), ch. 2, by defining ‚Äúgood‚Äù trading
strategies for which stochastic integrals‚Äîi.e. the analogon of the gains process in definition
17‚Äîare defined.

Definition 28 (Simple Predictable Trading Strategy).                   A trading strategy (ùúôt )t‚àà[0,T] is said
to be simple predictable if ùúôt can be represented by

                                                      ‚àë
                                                      n
                                   ùúôt = ùúô0 10 (t) +         ùúôi 1(ùúèi ,ùúèi+1 ] (t)
                                                      i=1


for a finite sequence of stopping times 0 = ùúè1 ‚â§ ... ‚â§ ùúèn ‚â§ T < ‚àû. Also, ùúôi ‚àà Óà≤ùúèi and ||ùúôi || < ‚àû
almost surely. The set of such trading strategies is denoted H.

    Strategies of type H are the fundamental building block for stochastic integration in
continuous time. For a given stochastic process S, we define a linear mapping It : H ‚Üí L0
where L0 is the space of finite valued random variables with appropriate topology. To this end,
let

                                                      ‚àë
                                                      n
                                It (ùúô, S) ‚â° ùúô0 S0 +         ùúôti (Sti+1 ‚àí Sti )
                                                      i=1

                                                                                         t
for ùúô ‚àà H and times 0 = t1 ‚â§ ... ‚â§ tn ‚â§ t ‚â§ T < ‚àû. We write It (ùúô, S) = ‚à´0 ùúôs dSs for the case
where n ‚Üí ‚àû. The value process of a trading stragy ùúô in S is denoted (Vt (ùúô, S))t‚àà[0,T] .


13
  A sigma algebra is closed under countably infinite unions of sets contained in the algebra such that
                                                                            ‚ãÉ‚àû
condition 3. in definition 3 is to be replaced by 3.‚Ä≤ E1 , E2 , ‚Ä¶ , E‚àû ‚àà Óà≤ ‚áí i=1 Ei ‚àà Óà≤ . Cf. Bhattacharya
and Waymire (2007), ch. 2.
62                                                                    DERIVATIVES ANALYTICS WITH PYTHON


Definition 29 (Gains Process).              The gains process (Gt (ùúô, S))t‚àà[0,T] of a trading strategy
ùúô ‚àà H in S is given by
                                             t                  ‚àë
                                                                n
                             Gt (ùúô, S) =         ùúôs dSs = lim         ùúôti (Sti+1 ‚àí Sti )
                                           ‚à´0+           n‚Üí‚àû
                                                                i=1

with 0 = t1 ‚â§ ... ‚â§ tn ‚â§ t ‚â§ T < ‚àû.

        We then get the following central definitions.

Definition 30 (Total Semimartingale). A process S is a total semimartingale if S is right
continuous with left limits (caÃÄdlaÃÄg) and F-adapted and if It : H ‚Üí L0 is continuous.

     The continuity requirement in the definition ensures that small changes in the trading
strategy (or a portfolio at a specific time) cannot lead to big perturbations in the value of the
gains process or the value of a portfolio.

Definition 31 (Semimartingale). A process S is a semimartingale if, for each stopping time
ùúè ‚àà [0, T], the stopped process (St‚àßùúè )t‚àà[0,T] is a total semimartingale.

     These concepts might seem rather abstract. However, for a continuous market model they
define on the one hand the set of acceptable trading strategies and on the other hand the set of
stochastic processes appropriate to model a financial market in general and the price process of
a traded asset in particular, respectively. If either the trading strategy is not simple predictable
or the stochastic processes, i.e. the assets‚Äô price processes, are not semimartingales then the
gains process of definition 29 is not defined. Fortunately, both concepts are quite general and in
particular the class of semimartingales encompasses as special cases almost any, if not every,
stochastic process used in mathematical finance for asset pricing.
     For financial applications, a further characterization of semimartingales is helpful (cf. for
details Protter (2005), p. 55).

Definition 32 (Decomposable Process). An F-adapted process S is decomposable if it can
be decomposed as St = S0 + Mt + At where M0 = A0 = 0 and M is a locally square integrable
martingale, and A is a caÃÄdlaÃÄg, F-adapted process with paths of finite variations on compacts.14

    Two processes are worth mentioning as special cases of semimartingales (cf. Protter
(2005), p. 17 and p. 20).

Definition 33 (Brownian Motion). Let (Zt )t‚àà[0,T] be an F-adapted process taking values in
R (Rk , 1 < k < ‚àû). Then Z is a (k-dimensional) standard Brownian motion if:

     1. Z0 = 0 almost surely
     2. Zt ‚àí Zs is independent of Óà≤s for 0 ‚â§ s < t ‚â§ T
     3. Zt ‚àí Zs is a Gaussian random variable (vector) with mean zero and variance of t ‚àí s
        (variance matrix (t ‚àí s)ÓàÆ for a given non-random matrix ÓàÆ and k > 1)

14
     For example, if A is deterministic it has finite variations on compacts.
Risk-Neutral Valuation                                                                        63


   According to Theorem 26 in Protter (2005) there always exists a modification of a standard
Brownian motion that has continuous paths almost surely.

Example 1 (Bachelier Model). In the Bachelier model, the index process (St )t‚àà[0,T] is given
                                                  t        t
as an arithmetic Brownian motion with St = S0 + ‚à´0 ùúádt + ‚à´0 ùúédZs where Z is a standard
Brownian motion and ùúá, ùúé > 0 are fixed. Obviously, S is decomposable and therewith a
semimartingale.

Definition 34 (LeÃÅvy Process). Let (Nt )t‚àà[0,T] be an F-adapted process taking values in R
and N0 = 0 almost surely. Then N is a LeÃÅvy process if:


 1. Nt ‚àí Ns is independent of Óà≤s for 0 ‚â§ s < t ‚â§ T
 2. Nt ‚àí Ns has the same distribution as Nt‚àís for 0 ‚â§ s < t ‚â§ T, i.e. it has stationary incre-
    ments
 3. lims‚Üít Ns = Nt almost surely, i.e. it is continuous in probability


     By Theorem 30 of Protter (2005) there always exists a unique modification of a LeÃÅvy
process that is caÃÄdlaÃÄg and also a LeÃÅvy process.
     Brownian motion and LeÃÅvy processes are central in modeling financial markets. In fact,
all models presented in this book are either built on Brownian motion (e.g. the Black-Scholes-
Merton model, cf. Black and Scholes (1973) and Merton (1973)) or on a LeÃÅvy process (e.g. the
jump-diffusion model of Merton, cf. Merton (1976)) or on both (e.g. the stochastic volatility
jump model of Bates, cf. Bates (1996)).
     We need as before a further qualification of trading strategies.

Definition 35 (Admissible Strategy). A trading strategy (ùúôt )t‚àà[0,T] ‚àà H in S is admissi-
                       t
ble if ùúô0 = 0 and if ‚à´0 ùúôs dSs ‚â• ‚àíùõº with ùõº ‚â• 0 and S a semimartingale. We denote this set
by T.

     Admissibility in continuous market models ensures, apart from the avoidance of
bankruptcy of agents, that certain trading strategies known to generate arbitrage opportu-
nities (e.g. the so-called doubling strategy) are excluded. This is because such strategies rely
on the possibility of producing a position of infinite debt (in the limit).

Definition 36 (Self-Financing Strategy).    A trading strategy (ùúôt )t‚àà[0,T] ‚àà H is self-financing
if

                                                          t
                                   ùúôt St = ùúô0 S0 +            ùúôs dSs
                                                     ‚à´0

Gains from trade are only induced by random changes in S. ùúôt St is caÃÄdlaÃÄg.

     The concept of an arbitrage opportunity carries over from the discrete time case.
64                                                                 DERIVATIVES ANALYTICS WITH PYTHON


Definition 37 (Arbitrage Opportunity). An arbitrage opportunity in S is a self-financing,
admissible
      (    trading strategy
                   )        ùúô ‚àà T whose value process satisfies V0 (ùúô, S) = 0, VT (ùúô, S) ‚â• 0
and P VT (ùúô, S) > 0 > 0.

    We now follow the tradition initiated in the seminal paper by Delbaen and Schachermayer
(1994) and define a number of sets central to arbitrage pricing. We have:

                 T
      A = {‚à´0 ùúôs dSs , ùúô ‚àà T}: all terminal wealths (i.e. contingent claims) that can be generated
       by admissible trading strategies in the semimartingale S
      B = A ‚àí Óà∏0 : all functions dominated by elements of A with Óà∏0 being positive finite
                 +                                                         +
       random variables
      A‚àû = A ‚à© Óà∏‚àû : the intersection of A with Óà∏‚àû , the space of bounded functions
      B‚àû = B ‚à© Óà∏‚àû : the intersection of B with Óà∏‚àû ; B  ÃÑ ‚àû denotes the closure of B‚àû


         We then have the following conditions.

Definition 38 (NA‚ÄîNFLVR). A semimartingale S satisfies the no arbitrage condition (NA)
if B‚àû ‚à© Óà∏‚àû+ = {0}. It satisfies the no free lunches with vanishing risk condition (NFLVR) if
ÃÑB‚àû ‚à© Óà∏‚àû = {0}.
        +


         Finally, we can state the Fundamental Theorem of Asset Pricing for the continuous setup.

Theorem 2 (Fundamental Theorem of Asset Pricing‚ÄîOne Dimensional).              Let S be a
bounded real-valued semimartingale. There exists a P-equivalent martingale measure Q for S
if and only if S satisfies NFLVR.



Proof. Cf. Delbaen and Schachermayer (1994). For a comprehensive exposition of the whole
theory refer to Delbaen and Schachermayer (2004).

    This version is the original one which, however, holds for the general case of a multi-
dimensional semimartingale S as well.15 With respect to the above set definitions, we have
mainly to make, for K > 1, the change

                                       {K                               }
                                        ‚àë           T
                                  A=                    ùúôks dSsk , ùúôk ‚àà T
                                               ‚à´0
                                         k=1


Here, each Sk is a semimartingale. We now have everything together to define the general
continuous market model.


 ‚ÄúThe process S, sometimes denoted (St )t‚ààR+ is supposed to be R+ -valued, although all proofs work
15

with a d-dimensional process as well‚Äù, cf. Delbaen and Schachermayer (1994), p. 464.
Risk-Neutral Valuation                                                                        65


Definition 39 (Continuous Market Model). A continuous market model Óàπ is a collection of:

   a continuous state space Œ© ‚äÜ R
   a filtration F of non-decreasing sigma algebras
   a probability measure P defined on the sigma algebra Óà≤
   a terminal date T, 0 < T < ‚àû

   a set of simple predictable trading strategies H for which gains processes are defined and
   a set of K + 1 tradable assets S ‚â° {(Sk )                                       k
                                            t t‚àà[0,T] : k ‚àà {0, ‚Ä¶ , K}} where each S is a semi-
    martingale and S0 is (locally) risk-less and strictly positive

We write Óàπ = {(Œ©, Óà≤ , F, P), T, H, S}.

      We then have:

Theorem 3 (Fundamental Theorem of Asset Pricing‚ÄîMulti-Dimensional). Let a contin-
uous market model Óàπ be given. There exists a P-equivalent martingale measure Q (EMM)
for S, the set of semimartingales representing tradable assets, if and only if this set satisfies
NFLVR.

      In practical applications there are basically two routes to apply this theorem:

   model without EMM: one has a model with real-world dynamics and is able to derive
    an EMM thereby ensuring NFLVR
   model with EMM: one starts with a model with risk-neutral dynamics under an EMM

    and uses it‚Äîknowing that NFLVR applies‚Äîto value contingent claims (e.g. options and
    other financial derivatives)

     Let us switch back to the case K = 1, i.e. with one risky asset only (the general case
is easily accounted for by a change of notation). A contingent claim is a Óà≤T -measurable,
integrable payoff AT at time T. A contingent claim is attainable (or redundant) in the market
model Óàπ if there exists an admissible trading strategy ùúô ‚àà T that is self-financing and has
VT (ùúô, S) = AT . In other words, the payoff can be perfectly replicated by a strategy in the
tradable assets.
     For an attainable contingent claim A ‚àà A with replicating strategy ùúô ‚àà T we have
                                                                T
                             AT = VT (ùúô, S) = V0 (ùúô, S) +           ùúôs dSs
                                                            ‚à´0+

Taking expectations under the EMM yields
                                                            (       T            )
                          EQ (VT (ùúô, S)) = V0 (ùúô, S) + EQ               ùúôs dSs
                           0                            0   ‚à´0+

Since the last term equals zero due to the martingale property of S we deduce the risk-neutral
pricing formula (cf. Harrison and Pliska (1981), p. 240)

                                    V0 (ùúô, S) = EQ
                                                 0
                                                   (VT (ùúô, S))                              (4.1)
66                                                        DERIVATIVES ANALYTICS WITH PYTHON


The present value of a contingent claim equals its expected payoff under the EMM. It is easily
verified that arbitrage opportunities arise if equation (4.1) does not hold. With ùõΩt ‚â† 1 we get

                                  V0 (ùúô, S) = EQ (ùõΩ V (ùúô, S))
                                               0 T T
                                                                                           (4.2)

which means that the present value equals the expectation of the discounted payoff under the
EMM. Similarly, for 0 < t < T we finally have

                                Vt (ùúô, S) = ùõΩt‚àí1 EQ (ùõΩ V (ùúô, S))
                                                  0 T T
                                                                                           (4.3)

    To define the value process (At )t‚àà[0,T] of an attainable contingent claim A ‚àà A identify
At = Vt (ùúô, S) for ùúô ‚àà T, self-financing and AT = VT (ùúô, S). We then see that the discounted
value process is a martingale under the EMM

                               EQ (ùõΩ A ) = EQ
                                0 t t
                                              (ùõΩ V (ùúô, S)) = A0
                                            0 T T

which follows immediately from (4.2) and (4.3).
     Finally, let us consider completeness of the continuous model Óàπ. Define the set of all
Óà≤T -measurable, integrable payoffs AT by C. The market model is then complete if C = A, i.e.
the set of all contingent claims coincides with the set of attainable contingent claims.

Proposition 4 (Market Completeness). The continuous market model Óàπ is complete if the
set of P-equivalent martingales measures Q is a singleton.

     This result also holds for the multi-dimensional case. It is sometimes called the Second
Fundamental Theorem of Asset Pricing. Cf. BjoÃàrk (2004), Theorems 10.17 and 14.18, for
versions of this result for the one- and multi-dimensional case, respectively, when Brownian
motion drives uncertainty.

4.6 CONCLUSIONS

This chapter looks at the Fundamental Theorem of Asset Pricing and related concepts and
results. It is not possible to cover all relevant aspects of this cornerstone of modern financial
theory in a single chapter. However, it provides at least an overview of the fundamental
framework on which all subsequent theoretical and numerical analyses are based.
    In particular, all subsequent chapters will make heavy use of the risk-neutral discount-
ing approach to value European and American options. Especially when working in higher
dimensional settings (with multiple risk factors) and using Monte Carlo simulation as valuation
method, the power of the risk-neutral valuation paradigm will be impressively illustrated.

4.7 PROOFS

4.7.1 Proof of Lemma 1

Proof. If for ùúô we have Vt (ùúô) ‚â• 0 then it already satisfies definition 25. So assume the
contrary. Then there exist t < T, E ‚àà Óà≤t , a < 0 with ùúôt ‚ãÖ St = a on E and ùúôu ‚ãÖ Su ‚â§ 0 for
Risk-Neutral Valuation                                                                                67


t < u ‚â§ T. Now define another trading strategy ùúì through ùúìu ‚â° 0 for u ‚â§ t and ùúìu (ùúî) ‚â° 0 if
u < t as well as ùúî ‚àâ E. If u > t but ùúî ‚àà E set
                                     { 0
                                      ùúôu (ùúî) ‚àí a‚àïSt0 (ùúî) for k = 0
                         ùúìuk (ùúî) ‚â°
                                      ùúôku (ùúî)            for k = 1, 2, ‚Ä¶ , K

It remains to show that this predictable trading strategy is self-financing and admissible. For
ùúî‚ààE

                             (             )      ‚àë
                                                  K
                  ùúìt+1 ‚ãÖ St = ùúô0t+1 ‚àí a‚àïSt0 St0 +   ùúôkt+1 Stk = ùúôt ‚ãÖ St ‚àí a = 0
                                                         k=1

by the definition of a such that ùúì is self-financing. For u > t and ùúî ‚àà E one has similarly

                            (           )      ‚àëK
                                                                      aS0
                   ùúìu ‚ãÖ Su = ùúô0u ‚àí a‚àïSt0 Su0 +     ùúôku Suk = ùúôu ‚ãÖ Su ‚àí 0u ‚â• 0
                                               k=1                     St

implying Vt (ùúì) ‚â• 0 and so ùúì is admissible. Realizing that ST0 > 0 implies VT (ùúì) > 0 on
E with EP0 [VT (ùúì)] > 0 yields the assertion of the lemma (cf. Harrison and Pliska (1981),
p. 228).



4.7.2 Proof of Proposition 1

Proof.   First, let Q ‚àà Q and define ùúÅ by (a). Take an arbitrary ùúô ‚àà T and write

                                                         ‚àë
                                                         T‚àí1
                         ùõΩT VT (ùúô) = ùõΩT (ùúôT ‚ãÖ ST ) +            ùõΩt (ùúôt ‚àí ùúôt+1 ) ‚ãÖ St
                                                         t=1
                                                         ‚àë
                                                         T
                                     = ùõΩ1 (ùúô1 ‚ãÖ S1 ) +         ùúôt ‚ãÖ (ùõΩt St ‚àí ùõΩt+1 St+1 )
                                                         t=2

after several regroupings of terms in the first sum. Now use the definition of ùúÅ
                                [           ]
                ùúÅ (VT (ùúô)) = EQ
                              0
                                  ùõΩT VT (ùúô)
                                                           [ T                                    ]
                                 [              ]           ‚àë
                            = EQ
                               0
                                   ùõΩ1 (ùúô1 ‚ãÖ S1 ) + EQ
                                                    0
                                                                      ùúôt ‚ãÖ (ùõΩt St ‚àí ùõΩt+1 St+1 )
                                                                t=2
                                 [               ]
                            = EQ
                               0
                                   ùõΩ1 (ùúô1 ‚ãÖ S1 )

since, by assumption, (ùõΩt St )t‚àà{0,‚Ä¶,T} is a martingale under Q and ùúô is predictable. The last
term gives EQ [ùõΩ (ùúô ‚ãÖ S1 )] = ùúô1 ‚ãÖ ùõΩ0 S0 ‚â° V0 (ùúô) showing consistency of ùúÅ .
             0 1 1
    Second, assume ùúÅ ‚àà P and define Q by (b). For ùúî ‚àà Œ© one clearly has Q(ùúî) = ùúÅ (ST0 1ùúî ) >
0 since ùúÅ is consistent with Óàπ. This establishes the first characteristic of a P-equivalent
68                                                               DERIVATIVES ANALYTICS WITH PYTHON


martingale measure. The second follows from observing that the trading strategy ùúô ‚àà T with
ùúô0 ‚â° 1 and ùúôk ‚â° 0 for k ‚â† 0 yields

                                          V0 (ùúô) = ùúÅ (VT (ùúô))
                                                 = ùúÅ (ST0 1Œ© )
                                                 =1

such that Q(Œ©) = 1. As a consequence, ùúÅ (AT ) = ùõΩT EQ      0
                                                             [AT ] for AT ‚àà A.
      It remains to establish that Q is a martingale measure for (ùõΩt St )t‚àà{0,‚Ä¶,T} . The case k = 0 is
trivial‚Äîthis is the risk-less numeraire. Take k ‚â† 0 arbitrary and consider the trading strategy
ùúÅ ‚àà T with ùúôkt ‚â° 1t‚â§ùúè and ùúô0t ‚â° (Sùúèk ‚àïSùúè0 )1t>ùúè for 0 < ùúè < T being a stopping time. Furthermore,
ùúôit ‚â° 0 for all other securities i and all dates t. Obviously, V0 (ùúô) = S0k and VT (ùúô) = (Sùúèk ‚àïSùúè0 )ST0 =
ST0 ùõΩùúè Sùúèk . We get
                                                  (           )
                                    ùúÅ (VT (ùúô)) = ùúÅ ST0 ùõΩùúè Sùúèk
                                                    (               )
                                               = EQ
                                                  0
                                                      ùõΩT ST0 ùõΩùúè Sùúèk
                                                    ( k)
                                               = EQ
                                                  0
                                                      ùõΩùúè Sùúè
                                                = S0k

where the last equality follows from consistency of ùúÅ . Realizing that k is arbitrary, this yields
the last characteristic Q has to fulfill to make the discounted securities process (ùõΩt St )t‚àà{0,‚Ä¶,T}
a vector martingale. So Q ‚àà Q completing the proof (cf. Harrison and Pliska (1981),
p. 227).



4.7.3 Proof of Theorem 1

Proof. Suppose Q is non-empty. Proposition 1 then implies that P is non-empty as well.
Consider a trading strategy ùúô ‚àà T with V0 (ùúô) = 0. Then there is a ùúÅ ‚àà P such that ùúÅ (VT (ùúô)) =
V0 (ùúô) = 0 and so by the definition of a linear price system VT (ùúô) = 0. It remains to show that
the first statement implies the second and third.
     Start by defining two sets:

                     A+ ‚â° {AT ‚àà A : EP0 (AT ) ‚â• 1}
                      A0 ‚â° {AT : AT = VT (ùúô), V0 (ùúô) = 0, ùúô self-financing}

Obviously, if there are no arbitrage opportunities then A+ ‚à© A0 = ‚àÖ. The next step is to show
that there exists a consistent linear price system ùúÅ ‚àà P. Since A+ is a closed and convex subset
of R|Œ©| and A0 is a linear subspace, the Separating Hyperplane Theorem can be applied to
establish the existence of a linear functional L on R|Œ©| such that:

 1. L(AT ) = 0 for AT ‚àà A0 and
 2. L(AT ) > 0 for AT ‚àà A+
Risk-Neutral Valuation                                                                          69


     Now define ùúÅ (AT ) ‚â° L(AT )‚àïL(ST0 ) which satisfies definition 24. One needs to show that
indeed ùúÅ ‚àà P, i.e. that it is consistent with Óàπ. Take an admissible trading strategy ùúô ‚àà T and
define a new self-financing trading strategy by
                                   {
                                    ùúô0t ‚àí V0 (ùúô) for k = 0
                           ùúìtk ‚â°
                                     ùúôkt             for k = 1, 2, ‚Ä¶ , K

It holds V0 (ùúì) = 0 and VT (ùúì) = VT (ùúô) ‚àí V0 (ùúô)ST0 with VT (ùúì) ‚àà A0 so that ùúÅ (VT (ùúì)) = 0.
We get
                                            (                  )
                             ùúÅ (VT (ùúì)) = ùúÅ VT (ùúô) ‚àí V0 (ùúô)ST0
                                                              ( )
                                        = ùúÅ (VT (ùúô)) ‚àí V0 (ùúô)ùúÅ ST0
                                           = ùúÅ (VT (ùúô)) ‚àí V0 (ùúô)
                                           =0

using linearity and normalization of ùúÅ relative to ST0 , i.e. ùúÅ (ST0 ) = 1. From this, ùúÅ (VT (ùúô)) =
V0 (ùúô) for ùúô ‚àà T arbitrary and ùúÅ ‚àà P. Hence, P is non-empty and so is Q due to proposition 1‚Äî
completing the proof (cf. Harrison and Pliska (1981), pp. 228‚Äì229).
                                                                            CHAPTER         5
                                         Complete Market Models


5.1 INTRODUCTION

Ever since the publication of the seminal works by Black, Scholes and Merton (BSM) in 1973
(cf. Black and Scholes (1973) and Merton (1973)), the BSM model‚Äîwhich is a continuous
market model‚Äîand associated option pricing formulas have been considered a benchmark for
option pricing. Benchmark in the sense that they provide closed-form solutions in a simple
but still somehow realistic setting. The original and famous formula is derived in the papers
on the basis of two different arguments. The first one in Black and Scholes (1973) is an
equilibrium argument saying that a risk-less portfolio should yield the risk-less interest rate
in equilibrium. The second, and rather widely applicable, one from Merton (1973) is that the
value of a (European) option should equal the value of a portfolio that, in combination with
an appropriate trading strategy, perfectly replicates the payoff at maturity. It is essentially the
key argument of the general arbitrage pricing theory presented in Chapter 4.
     Several years later, in 1979, Cox, Ross and Rubinstein presented (cf. Cox et al. (1979))
their binomial option pricing model. This model assumes in principle a BSM economy but
in discrete time with discrete state space. Whereas the BSM model necessitates advanced
mathematics and the handling of partial differential equations (PDE), the CRR analysis relies
on fundamental probabilistic concepts only. Their representation of uncertainty by binomial
(recombining) trees is still today the tool of choice when one wishes to illustrate option topics
in a simple, intuitive way. Furthermore, their numerical approach allows not only European
options but also American options to be valued quite as easily.
     The main characterizing feature of both market models is that they are complete: every
contingent claim maturing at some future date can be replicated by a trading strategy in the
two tradable assets available‚Äîa risky asset (e.g. an index or stock) and a risk-less bond. The
two models are also consistent in the sense that the CRR model converges to the BSM setup
when the time interval between two consecutive dates tends to zero.
     This chapter presents in the next section the BSM model and some associated aspects of
the pricing theory. Section 5.3 analyzes how option prices and other quantities of interest react
to changes in the model parameters. The major topic is the so-called Greeks, i.e. the delta and
theta of an option, for example. Section 5.4 introduces the CRR model.




                                                                                                71
72                                                          DERIVATIVES ANALYTICS WITH PYTHON


5.2 BLACK-SCHOLES-MERTON MODEL

5.2.1 Market Model
We consider an economy ÓàπBSM with final date T, 0 < T < ‚àû. Uncertainty in the economy is
represented by a filtered probability space {Œ©, Óà≤ , F, P}. Œ© denotes the continuous state space,
Óà≤ an ùúé-algebra, F a filtration‚Äîi.e. a family of non-decreasing ùúé-algebras F ‚â° {Óà≤t‚àà[0,T] } with
Óà≤0 ‚â° {‚àÖ, Œ©} and Óà≤T ‚â° Óà≤ ‚Äîand P the real or objective probability measure.
    Against this background, we model for 0 ‚â§ t ‚â§ T the risk-neutral evolution of the relevant
stock index according to the stochastic differential equation (SDE)

                                         dSt
                                             = rdt + ùúédZt                                      (5.1)
                                          St

St denotes the index level at date t, r the constant risk-less short rate, ùúé the constant volatility
of the index and Zt a standard Brownian motion. Since we model an index instead of a single
stock, we abstract from dividend related modeling issues.1 The stochastic process S generates
the filtration F, i.e. Óà≤t ‚â° Óà≤ (S0‚â§s‚â§t ).
     The differential equation that a risk-less zero-coupon bond satisfies is

                                             dBt
                                                 = rdt                                         (5.2)
                                              Bt

The time t value of a zero-coupon bond paying one unit of currency at T with 0 ‚â§ t < T is
Bt (T) = e‚àír(T‚àít) with BT ‚â° 1.
     It is well-known that the BSM model

                               ÓàπBSM = {{Œ©, Óà≤ , F, P}, T, {S, B}}

is complete and that the P-equivalent martingale measure Q is unique. Cf. BjoÃàrk (2004),
Theorems 8.3 and 10.17, for completeness and uniqueness of the risk-neutral measure Q,
respectively.


5.2.2 The Fundamental PDE
We are now interested in the value V of a contingent claim, say a European call option on
the index. We follow the analysis in Wilmott et al. (1995), sec. 3.5. Assume that the value
depends on the index level S and time t only, i.e. V(S, t). ItoÃÇ‚Äôs lemma, stated as proposition 5
in sub-section 5.6.1, gives the incremental change of the value V over time. Omitting time
subscripts, we get

                                      ùúïV      1 ùúï2V 2      ùúïV
                               dV =      dS +       v dt +    dt
                                      ùúïS      2 ùúïS2        ùúït

1
 However, if the index would pay a continuous dividend yield of dy one would replace the risk-neutral
drift r by rÃÑ = r ‚àí dy.
Complete Market Models                                                                       73


From equation (5.1) we know dS and v = ùúéS. Then

                               ùúïV                   1 ùúï2V 2 2      ùúïV
                     dV =         (rSdt + ùúéSdZt ) +       ùúé S dt +    dt
                               ùúïS                   2 ùúïS2          ùúït
                                           (                          )
                                 ùúïV           ùúïV 1 2 2 ùúï 2 V ùúïV
                             = ùúéS dZt + rS          + ùúé S        +       dt                (5.3)
                                  ùúïS           ùúïS 2         ùúïS2    ùúït

    Define now the delta of the contingent claim (think again of a European call option) by

                                                      ùúïVt
                                               Œît ‚â°
                                                      ùúïSt

and set up a portfolio Œ†0 = V0 ‚àí Œî0 S0 . In other words, a portfolio consisting of one option
long and Œî units of the index short. How does this portfolio evolve over time? Building on
equations (5.1) and (5.3)

                         (         )     (                            )
                             ùúïV              ùúïV 1 2 2 ùúï 2 V ùúïV
             dŒ† = ùúéS            ‚àí Œî dZt + rS   + ùúé S       +    ‚àí rŒîS   dt                 (5.4)
                             ùúïS              ùúïS 2     ùúïS2    ùúït

Recognizing the definition of Œî, (5.4) simplifies to

                                          (                     )
                                              1 2 2 ùúï 2 V ùúïV
                                   dŒ† =         ùúé S      +          dt                     (5.5)
                                              2     ùúïS2    ùúït

As a consequence of adding a delta short position, the portfolio becomes (locally) risk-less. To
avoid arbitrage, a risk-less portfolio must yield the risk-less short rate according to equation
(5.2). We must therefore have dŒ† = rŒ†dt as well. Equating this with (5.5)

                              (      )      (                 )
                                  ùúïV          1 2 2 ùúï 2 V ùúïV
                             r V‚àí      dt =     ùúé S      +      dt
                                  ùúïS          2     ùúïS2    ùúït

and rearranging, we finally arrive at the famous and central BSM partial differential equation
(PDE)

                                  ùúïV 1 2 2 ùúï 2 V ùúïV
                                    + ùúé S       +    ‚àí rV = 0                              (5.6)
                                  ùúïS 2     ùúïS2    ùúït

This equation holds for every contingent claim whose value V depends on S and t only. This is
what makes it so important. It cannot be overemphasized that the whole argument hinges on
the assumption that the portfolio made up of the contingent claim and the short delta position
becomes risk-less. However, we are on quite safe ground due to the completeness of the market
model.
74                                                             DERIVATIVES ANALYTICS WITH PYTHON


5.2.3 European Options
Although fundamentally of high importance, the BSM equation (5.6) is not the only reason
for the popularity of the BSM model.2 It is also the fact that this PDE allows for an explicit,
i.e. analytical, solution in the case of European call and put options.
      To this end, denote by C(S, t) the value at time t of a European call option on the index S
with payoff hC T
                  = max[ST ‚àí K, 0] where K > 0 is the fixed strike price. Obviously, by arbitrage
we have C(S, T) = hC   T
                         such that we get a boundary condition, i.e. a final condition, for the PDE
(5.6). We also know that C(S = 0, t) = 0 since in this case the option will never show a positive
value at maturity.3 Finally, when St ‚Üí ‚àû then C(S, t) ‚âà St since K becomes negligible.
      Taking one of a number of different routes,4 one can show that the time t value of the
European call option is

                        C(S, K, t, T, r, ùúé) = St ‚ãÖ N(d1 ) ‚àí e‚àír(T‚àít) ‚ãÖ K ‚ãÖ N(d2 )                   (5.7)

where
                                                     d
                                           1           1 2
                                  N(d) = ‚àö          e‚àí 2 x dx
                                           2ùúã ‚à´‚àí‚àû
                                                  (      2)
                                         log Kt + r + ùúé2 (T ‚àí t)
                                             S

                                    d1 =          ‚àö
                                                 ùúé T ‚àít
                                                  (      2)
                                         log Kt + r ‚àí ùúé2 (T ‚àí t)
                                             S

                                    d2 =          ‚àö
                                                 ùúé T ‚àít

     To derive the corresponding formula for a European put option, one can apply put-call
parity. To this end, consider a portfolio of one unit of the index S long, one European put option
with strike K long and one European call option with the same strike short. The portfolio pays
at maturity T

                         S + P ‚àí C = S + max[K ‚àí S, 0] ‚àí max[S ‚àí K, 0]

You now have to distinguish two cases. First, S < K. Then the payoff is S + K ‚àí S = K.
Second, S ‚â• K. In this case, the payoff is S ‚àí S + K = K. Alas, the portfolio S + P ‚àí C pays
K for sure. To avoid arbitrage, the time t value of the portfolio therefore must be

                                      St + Pt ‚àí Ct = e‚àír(T‚àít) K

2
  Robert Merton and Myron Scholes received the Nobel Prize for economics in 1997 mainly for this
general approach to option pricing and its widespread applicability in mathematical finance. Cf. the
article by Robert Jarrow (Jarrow, 1999)‚Äîhonoring the Nobel Prize winners and their theory‚Äîwhose
title says ‚ÄúA Partial Differential Equation That Changed the World‚Äù.
3
  Once St = 0, it will stay there according to equation (5.1).
4
  Cf. Wilmott et al. (1995), ch. 5, for a similarity solution approach to equation (5.6) or BjoÃàrk (2004),
ch. 7, for a risk-neutral/probabilistic approach.
Complete Market Models                                                                         75


From this, the European put option value is given by


                                   Pt = Ct ‚àí St + e‚àír(T‚àít) K                                (5.8)


     We therefore have for a European put option with payoff hPT = max[K ‚àí ST , 0] at maturity
the following BSM formula


                         P(S, t) = e‚àír(T‚àít) ‚ãÖ K ‚ãÖ N(‚àíd2 ) ‚àí St ‚ãÖ N(‚àíd1 )                    (5.9)


     In what follows we are mainly interested in European options. So speaking of an ‚Äúoption‚Äù
means a European option if not otherwise indicated. To get a better feeling of how the value
of an option depends on the model and option parameters, we analyze an example option with
the following parameters:


   S0 = 100: initial index level
   K = 100: strike price
   T = 1.0: maturity in years
   r = 0.05: risk-less short rate

   ùúé = 0.2: volatility of the index level
   t = 0: valuation date, i.e. present date




     The Python script in sub-section 5.6.2 implements the valuation formulas for the European
call option and put option, contains the above parameters and generates the graphical output
for the call version of the option as shown in Figure 5.1. Figure 5.2 shows the respective output
for the put option. Every sub-plot shows variations of the base case parameters with respect
to a single parameter only.
     We can see the following in Figures 5.1 and 5.2:


 1. moneyness: the at-the-money call (K = S0 = 100, ATM) is worth about 10.4, much more
    than the put which is worth about 5.6 only; the more the options become in-the-money
    (K < 100 for the call, K > 100 for the put, ITM) the more they become worth; the opposite
    is true the more the options come out-of-the-money (K > 100 for the call, K > 100 for
    the put, OTM)
 2. time-to-maturity: the higher the time-to-maturity the more the options are worth; there
    are European options, however, for which this relationship does not necessarily hold (e.g.
    deep ITM European put options)
 3. short rate: an increase in the short rate increases the value of the call option and decreases
    the value of the put option; under risk-neutrality the index drifts with the short rate and
    the higher the drift the better for the call option (probability increases for ITM expiration)
    and the worse for the put option (probability increases for OTM expiration)
 4. volatility: a higher volatility increases both the value of the call and the value of the put
    option since the probability for ITM expiration increases in both cases
76                                                           DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 5.1 Value of the example European call option for varying strike K, maturity date T, short
rate r and volatility ùúé


5.3 GREEKS IN THE BSM MODEL

In particular for hedging and risk management purposes, it is of importance to know how option
values change with marginal changes in a model parameter. To derive the BSM equation (5.6),
a portfolio is set up that adds a short delta position to a long position in the option. The delta
Œî = ùúïVùúïS
         , i.e. the first partial derivative of the option‚Äôs value with respect to the index level, is
one of the so-called Greeks (which refers to the Greek origin of the letter‚Äôs name).
     The analytical valuation formula (5.7) allows closed-form expressions to be derived for
the most important Greeks as well. In what follows, we provide expressions for the Greeks of
a European call option. For the delta, we simply get (omitting time subscripts)
                                               ùúïC
                                         Œî=       = N(d1 )                                     (5.10)
                                               ùúïS
     The gamma is the second partial derivative with respect to the index level

                                           ùúï2C    N‚Ä≤ (d1 )
                                      Œì=       =   ‚àö                                           (5.11)
                                           ùúïS2   Sùúé T ‚àí t
Complete Market Models                                                                         77




FIGURE 5.2 Value of the example European put option for varying strike K, maturity date T, short
rate r and volatility ùúé


     The theta of an option is, by convention, the negative first partial derivative with respect
to time-to-maturity t‚àó = T ‚àí t

                                ùúïC      SN‚Ä≤ (d1 )ùúé
                         Œò=‚àí        = ‚àí  ‚àö         ‚àí re‚àír(T‚àít) KN(d2 )                      (5.12)
                                ùúït‚àó     2 T ‚àít

    The rho of an option is the first partial derivative with respect to the short rate r

                                    ùúïC
                               ùúå=      = K(T ‚àí t)e‚àír(T‚àít) N(d2 )                            (5.13)
                                    ùúïr
    The vega‚Äîwhich is obviously not a Greek letter‚Äîis the first partial derivative with
respect to the volatility ùúé

                                        ùúïC            ‚àö
                                  V=       = SN‚Ä≤ (d1 ) T ‚àí t                                (5.14)
                                        ùúïùúé
    Referring to Figure 5.1 and arguing graphically, the theta, rho and vega provide closed-
form expressions for the slope, given a certain parameter set, for three of the four sub-plots.
78                                                          DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 5.3    The delta of the European call option with respect to maturity date T and strike K


In the following, we provide plots of all the Greeks for the example call with different time-
to-maturities T and different strikes K. The Python script of sub-section 5.6.3 implements the
Greek formulas and generates the 3d plots.
     Some observations are worth pointing out:

   delta: Figure 5.3 shows that the delta of the call option varies both with moneyness
    and maturity date T; it is between 1 and 0 for far ITM options and far OTM options,
    respectively, with short maturity; delta changes most around the ATM level for short
    maturities
   gamma: Figure 5.4 shows that the gamma has the highest values around the ATM level

    for short maturities; this is in line with the observation that delta changes most around the
    ATM level
   theta: Figure 5.5 paints a similar picture to gamma but with changed sign; theta is most

    important around the ATM level and for short maturities
   rho: Figure 5.6 illustrates that rho increases in importance with higher T (longer time-to-

    maturity) and with moneyness from OTM to ATM to ITM
   vega: Figure 5.7 shows vega increasing with T and decreasing from the ATM level in

    both directions, i.e. OTM and ITM

It is worth pointing out that the shapes of the Greeks in the different figures partly depend on
the specific model parameters chosen and in particular on the option being a call. However,
gamma and vega are the same for the put option counterpart of the call. Furthermore, some
general remarks can be made:

 1. short-term: most Greeks (delta, gamma, theta, vega) reach their highest/lowest values
    around the ATM level, generally at short maturities (apart from vega)
Complete Market Models                                                                             79




FIGURE 5.4    The gamma of the European call option with respect to maturity date T and strike K

 2. long-term: for options with longer maturities only rho and vega have significant value
    impact; this is due to their role in determining how probable it is that the option expires
    ITM

    In practice, option traders try to hedge one or several of the risks represented by the
Greeks. For example, traders speak of ‚Äúdelta neutral‚Äù or ‚Äúvega hedged‚Äù positions which means




FIGURE 5.5    The theta of the European call option with respect to maturity date T and strike K
80                                                         DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 5.6   The rho of the European call option with respect to maturity date T and strike K




FIGURE 5.7   The vega of the European call option with respect to maturity date T and strike K
Complete Market Models                                                                                 81


that (small) moves in the underlying or the volatility are offset by certain hedge positions in
the underlying or other options.5 Hedge activity generally does not include theta since the
constant passage of time is something one has to accept and since it is what option premiums
are paid for to a great extent.


5.4 COX-ROSS-RUBINSTEIN MODEL

This section presents some fundamental aspects of the binomial option pricing approach
pioneered by CRR in Cox et al. (1979). We focus on those aspects that allow an implementation
in Python. A detailed treatment of the model is found, for example, in Pliska (1997).
    We are given a discrete market model with fixed filtered probability space {Œ©, Óà≤ , F, P}
where Œ© is finite. As in the BSM model, there are two securities traded: a risky stock index
S and a risk-less zero-coupon bond B. The time horizon [0, T] is divided into equidistant
time intervals Œît so that one gets T‚àïŒît + 1 points in time t ‚àà {0, Œît, 2 ‚ãÖ Œît, ‚Ä¶ , T}. The zero-
coupon bond grows annually in value by the risk-less short rate r, Bt = B0 ert where we set for
convenience BT ‚â° 1, i.e. we also have Bt = BT e‚àír(T‚àít) = Bt = e‚àír(T‚àít) . Together

                                 ÓàπCRR = {{Œ©, Óà≤ , F, P}, T, {S, B}}

    Starting from a strictly positive, fixed stock index level of S0 at t = 0, the stock index
evolves according to the law

                                             St+Œît ‚â° St ‚ãÖ m
                                                                                  ‚àö
where m is selected randomly from {u, d}. Here, 0 < d < erŒît < u ‚â° eùúé Œît as well as u ‚â° d1
as an important simplification. ùúé is a volatility parameter comparable to the respective BSM
quantity. These assumptions lead to a recombining tree which has after n time steps n + 1
nodes only‚Äîinstead of 2n nodes if the tree would not recombine. This allows for a high
number of time steps in the numerical implementation.
    Assuming risk-neutral valuation holds, the following relationship can be derived:

                                St = e‚àírŒît EQ
                                            t [St+Œît ]
                                   = e‚àírŒît (q ‚ãÖ u ‚ãÖ St + (1 ‚àí q) ‚ãÖ d ‚ãÖ St )

Against this background, the risk-neutral (or martingale) branch probability is

                                                   erŒît ‚àí d
                                             q=
                                                    u‚àíd
This quantity is uniquely determined by the structure of the index level tree which implies
completeness of the CRR model. The value of a European call option C0 is then obtained by

5
  In a BSM model, positions in the underlying can only immunize against small movements in the
underlying. To hedge against volatility changes one needs a further financial instrument sensitive to such
changes, in general an option. Cf. Nandi and Waggoner (2000) for an intuitive introduction to delta-vega
hedging.
82                                                              DERIVATIVES ANALYTICS WITH PYTHON


TABLE 5.1 Valuation results from the CRR binomial algorithm for the European call option; upper
panel index level process, lower panel option value processa

Time                 t=0                 Œît                2Œît                  3Œît             T

St                  100.00             110.52             122.14               134.99         149.18
                                        90.48             100.00               110.52         122.14
                                                           81.87                90.48         100.00
                                                                                74.08          81.87
                                                                                               67.03
Ct                    9.97              15.92              24.61                36.23          49.18
                                         3.32               6.25                11.76          22.14
                                                            0.00                 0.00           0.00
                                                                                 0.00           0.00
                                                                                                0.00
a
    The true value of the European put option from the BSM formula is 10.45.


discounting the final payoffs C(S, T) ‚â° max[ST ‚àí K, 0] at t = T to t = 0:

                                           C0 = e‚àírT EQ
                                                      0
                                                        [CT ]

The discounting can be done step-by-step and node-by-node backwards starting at t = T ‚àí Œît.
     From an algorithmical point of view, one has to first generate the index level values,
then determine the final payoffs of the call option and finally discount them back. This is
what we will do in the following assuming the same model parameters as in the previous
BSM example. A quite dense Python implementation of the binomial valuation approach is
found in sub-section 5.6.4. Appendix A about Python discusses in sub-section A.2.2 several
implementation approaches to the CRR model to illustrate different algorithmic strategies.
     Table 5.1 presents results for the binomial model with four time steps, i.e. five points in
time in total. From each node, the index can move upwards or downwards.6 For example,
starting at t = 0 with S0 = 100 the index can rise to 110.52 or can drop to 90.48. Arriving
with the evolution of S at T we can calculate the inner value of the option at this date
by C(S, T) ‚â° max[ST ‚àí K, 0]. The algorithm proceeds by taking expectations under Q and
discounting backwards. For example, considering the highest node at time t = 3Œît the option
value is derived by

                           V3Œît = e‚àírŒît (q ‚ãÖ 49.18 + (1 ‚àí q) ‚ãÖ 22.14) = 36.23

where r = 0.05, Œît = 0.25 and q = 0.5378.
     To illustrate the convergence of the CRR model value, consider Figure 5.8. In this figure,
an increasing number of time intervals obviously increases valuation accuracy. The figure
suggests that the CRR option value represents a lower bound to the BSM option value (i.e.
that it converges to the BSM value from below). However, as Figure 5.9 illustrates, the CRR

6
 To save space and computer memory, ‚Äúupwards‚Äù actually means sidewards in the table as well as in the
arrays generated by the Python script.
Complete Market Models                                                                    83




FIGURE 5.8 European call option values from the CRR model for increasing number of time
intervals M‚Äîstep size of 20 intervals




FIGURE 5.9 European call option values from the CRR model for increasing number of time
intervals M‚Äîstep size of 25 intervals
84                                                        DERIVATIVES ANALYTICS WITH PYTHON


option value might also oscillate around the BSM benchmark value given a different numerical
parametrization of the binomial model.
     Obviously, the CRR model values converge quite well to the BSM value of 10.45. One
might wonder where the advantage of the CRR model lies compared to the BSM model. With
regard to standard European options there is hardly an advantage. If any, it is the simplicity
of the model and the ability to analyze the workings of the algorithm step by step and node
by node in a tree. In that sense, it is a good teaching tool, for instance. However, advantages
arise beyond standard European options: the CRR model can also handle options with early
exercise features, i.e. American or Bermudan options, as well as options with arbitrary payoffs
at time T. This is illustrated in Chapter 7 which analyzes American options.


5.5 CONCLUSIONS

This chapter deals with two of the benchmark models for options pricing, the Black-Scholes-
Merton (1973) continuous time model and the Cox-Ross-Rubinstein (1979) discrete time
binomial model.
    All of the theory and the majority of the other models covered in this book will be about
some kind of enhancement relative to these benchmark models. For example, the Merton
(1976) model adds a jump component to the geometric Brownian motion of BSM while the
Heston (1993) model introduces a stochastic variance/volatility process.
    In addition, when speaking of implied volatilities of option prices it is in general the
BSM model that implies the volatility given the quoted option prices and the other market
parameters.


5.6 PROOFS AND PYTHON SCRIPTS

5.6.1 It oÃÇ‚Äôs Lemma

Proposition 5 (ItoÃÇ‚Äôs Lemma). Let f : R2 ‚Üí R be a twice continuously differentiable function
and S be a diffusion
                                       dSt = mt dt + vt dZt                             (5.15)

with Z a standard Brownian motion. Then for f (S, t) the marginal change in time is (omitting
time subscripts)
                                           ùúïf      1 ùúï2f 2     ùúïf
                            df (S, t) =       dS +       v dt + dt                      (5.16)
                                           ùúïS      2 ùúïS2       ùúït

Proof. First, a Taylor series expansion up to second order yields (suppressing dt2 terms and
other terms of equal or smaller order)

                                           ùúïf      1 ùúï 2 f 2 ùúïf
                             df (S, t) =      dS +        dS + dt
                                           ùúïS      2 ùúïS2      ùúït
Second, note that dS2 = v2 dt. Cf. Wilmott et al. (1995), pp. 25‚Äì31, for a discussion of this
simplified derivation and on the order of differential terms in the Taylor expansion.
Complete Market Models                                                     85


5.6.2 Script for BSM Option Valuation

#
# Black-Scholes-Merton (1973) European Call & Put Valuation
# 05_com/BSM_option_valuation.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rcParams['font.family'] = 'serif'
from scipy.integrate import quad

#
# Helper Functions
#



def dN(x):
    ''' Probability density function of standard normal random variable x.'''
    return math.exp(-0.5 * x ** 2) / math.sqrt(2 * math.pi)



def N(d):
    ''' Cumulative density function of standard normal random variable x. '''
    return quad(lambda x: dN(x), -20, d, limit=50)[0]



def d1f(St, K, t, T, r, sigma):
    ''' Black-Scholes-Merton d1 function.
        Parameters see e.g. BSM_call_value function. '''
    d1 = (math.log(St / K) + (r + 0.5 * sigma ** 2)
            * (T - t)) / (sigma * math.sqrt(T - t))
    return d1


#
# Valuation Functions
#



def BSM_call_value(St, K, t, T, r, sigma):
    ''' Calculates Black-Scholes-Merton European call option value.
86                                              DERIVATIVES ANALYTICS WITH PYTHON


     Parameters
     ==========
     St: float
          stock/index level at time t
     K:   float
          strike price
     t:   float
          valuation date
     T:   float
          date of maturity/time-to-maturity if t = 0; T > t
     r:   float
          constant, risk-less short rate
     sigma: float
         volatility


     Returns
     =======
     call_value: float
         European call present value at t
     '''
     d1 = d1f(St, K, t, T, r, sigma)
     d2 = d1 - sigma * math.sqrt(T - t)
     call_value = St * N(d1) - math.exp(-r * (T - t)) * K * N(d2)
     return call_value



def BSM_put_value(St, K, t, T, r, sigma):
    ''' Calculates Black-Scholes-Merton European put option value.


     Parameters
     ==========
     St: float
         stock/index level at time t
     K: float
          strike price
     t:   float
          valuation date
     T:   float
          date of maturity/time-to-maturity if t = 0; T > t
     r:   float
         constant, risk-less short rate
     sigma: float
         volatility


     Returns
     =======
     put_value: float
Complete Market Models                                                   87


        European put present value at t
    '''
    put_value = BSM_call_value(St, K, t, T, r, sigma) \
           - St + math.exp(-r * (T - t)) * K
    return put_value




#
# Plotting European Option Values
#



def plot_values(function):
    ''' Plots European option values for different parameters c.p. '''
    plt.figure(figsize=(10, 8.3))
    points = 100
    #
    # Model Parameters
    #
    St = 100.0 # index level
    K = 100.0 # option strike
    t = 0.0 # valuation date
    T = 1.0 # maturity date
    r = 0.05 # risk-less short rate
    sigma = 0.2 # volatility


    # C(K) plot
    plt.subplot(221)
    klist = np.linspace(80, 120, points)
    vlist = [function(St, K, t, T, r, sigma) for K in klist]
    plt.plot(klist, vlist)
    plt.grid()
    plt.xlabel('strike $K$')
    plt.ylabel('present value')

    # C(T) plot
    plt.subplot(222)
    tlist = np.linspace(0.0001, 1, points)
    vlist = [function(St, K, t, T, r, sigma) for T in tlist]
    plt.plot(tlist, vlist)
    plt.grid(True)
    plt.xlabel('maturity $T$')


    # C(r) plot
    plt.subplot(223)
    rlist = np.linspace(0, 0.1, points)
88                                             DERIVATIVES ANALYTICS WITH PYTHON


     vlist = [function(St, K, t, T, r, sigma) for r in rlist]
     plt.plot(tlist, vlist)
     plt.grid(True)
     plt.xlabel('short rate $r$')
     plt.ylabel('present value')
     plt.axis('tight')


     # C(sigma) plot
     plt.subplot(224)
     slist = np.linspace(0.01, 0.5, points)
     vlist = [function(St, K, t, T, r, sigma) for sigma in slist]
     plt.plot(slist, vlist)
     plt.grid(True)
     plt.xlabel('volatility $\sigma$')
     plt.tight_layout()




5.6.3 Script for BSM Call Greeks

#
# Black-Scholes-Merton (1973) European Call Option Greeks
# 05_com/BSM_call_greeks.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rcParams['font.family'] = 'serif'
import mpl_toolkits.mplot3d.axes3d as p3
from BSM_option_valuation import d1f, N, dN


#
# Functions for Greeks
#



def BSM_delta(St, K, t, T, r, sigma):
    ''' Black-Scholes-Merton DELTA of European call option.


     Parameters
     ==========
     St: float
         stock/index level at time t
Complete Market Models                                        89


    K:   float
         strike price
    t:   float
         valuation date
    T:   float
         date of maturity/time-to-maturity if t = 0; T > t
    r:  float
        constant, risk-less short rate
    sigma: float
         volatility

    Returns
    =======
    delta: float
        European call option DELTA
    '''
    d1 = d1f(St, K, t, T, r, sigma)
    delta = N(d1)
    return delta



def BSM_gamma(St, K, t, T, r, sigma):
    ''' Black-Scholes-Merton GAMMA of European call option.


    Parameters
    ==========
    St: float
        stock/index level at time t
    K: float
         strike price
    t:   float
         valuation date
    T:   float
         date of maturity/time-to-maturity if t = 0; T > t
    r:  float
        constant, risk-less short rate
    sigma: float
         volatility

    Returns
    =======
    gamma: float
        European call option GAMMA
    '''
    d1 = d1f(St, K, t, T, r, sigma)
    gamma = dN(d1) / (St * sigma * math.sqrt(T - t))
    return gamma
90                                              DERIVATIVES ANALYTICS WITH PYTHON


def BSM_theta(St, K, t, T, r, sigma):
    ''' Black-Scholes-Merton THETA of European call option.


     Parameters
     ==========
     St: float
          stock/index level at time t
     K:   float
          strike price
     t:   float
          valuation date
     T:   float
          date of maturity/time-to-maturity if t = 0; T > t
     r:   float
         constant, risk-less short rate
     sigma: float
         volatility


     Returns
     =======
     theta: float
         European call option THETA
     '''
     d1 = d1f(St, K, t, T, r, sigma)
     d2 = d1 - sigma * math.sqrt(T - t)
     theta = -(St * dN(d1) * sigma / (2 * math.sqrt(T - t))
              + r * K * math.exp(-r * (T - t)) * N(d2))
     return theta



def BSM_rho(St, K, t, T, r, sigma):
     ''' Black-Scholes-Merton RHO of European call option.

     Parameters
     ==========
     St: float
         stock/index level at time t
     K:   float
          strike price
     t:   float
          valuation date
     T:   float
          date of maturity/time-to-maturity if t = 0; T > t
     r:  float
         constant, risk-less short rate
     sigma: float
          volatility
Complete Market Models                                       91


    Returns
    =======
    rho: float
        European call option RHO
    '''
    d1 = d1f(St, K, t, T, r, sigma)
    d2 = d1 - sigma * math.sqrt(T - t)
    rho = K * (T - t) * math.exp(-r * (T - t)) * N(d2)
    return rho



def BSM_vega(St, K, t, T, r, sigma):
    ''' Black-Scholes-Merton VEGA of European call option.


    Parameters
    ==========
    St: float
         stock/index level at time t
    K:   float
         strike price
    t:   float
         valuation date
    T:   float
         date of maturity/time-to-maturity if t = 0; T > t
    r:   float
         constant, risk-less short rate
    sigma: float
        volatility


    Returns
    =======
    vega: float
        European call option VEGA
    '''
    d1 = d1f(St, K, t, T, r, sigma)
    vega = St * dN(d1) * math.sqrt(T - t)
    return vega


#
# Plotting the Greeks
#
def plot_greeks(function, greek):
    # Model Parameters
    St = 100.0 # index level
    K = 100.0 # option strike
    t = 0.0 # valuation date
    T = 1.0    # maturity date
92                                              DERIVATIVES ANALYTICS WITH PYTHON


     r = 0.05 # risk-less short rate
     sigma = 0.2 # volatility


     # Greek Calculations
     tlist = np.linspace(0.01, 1, 25)
     klist = np.linspace(80, 120, 25)
     V = np.zeros((len(tlist), len(klist)), dtype=np.float)
     for j in range(len(klist)):
         for i in range(len(tlist)):
              V[i, j] = function(St, klist[j], t, tlist[i], r, sigma)

     # 3D Plotting
     x, y = np.meshgrid(klist, tlist)
     fig = plt.figure(figsize=(9, 5))
     plot = p3.Axes3D(fig)
     plot.plot_wireframe(x, y, V)
     plot.set_xlabel('strike $K$')
     plot.set_ylabel('maturity $T$')
     plot.set_zlabel('%s(K, T)' % greek)




5.6.4 Script for CRR Option Valuation

#
# Cox-Ross-Rubinstein Binomial Model
# European Option Valuation
# 05_com/CRR_option_calcuation.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
mpl.rcParams['font.family'] = 'serif'
from BSM_option_valuation import BSM_call_value

#
# Model Parameters
#
S0 = 100.0 # index level
K = 100.0 # option strike
T = 1.0 # maturity date
r = 0.05 # risk-less short rate
sigma = 0.2   # volatility
Complete Market Models                                                         93


# Valuation Function
def CRR_option_value(S0, K, T, r, sigma, otype, M=4):
    ''' Cox-Ross-Rubinstein European option valuation.


    Parameters
    ==========
    S0: float
        stock/index level at time 0
    K: float
         strike price
    T:   float
         date of maturity
    r:   float
         constant, risk-less short rate
    sigma: float
        volatility
    otype: string
         either 'call' or 'put'
    M:   int
         number of time intervals
    '''
    # Time Parameters
    dt = T / M # length of time interval
    df = math.exp(-r * dt)   # discount per interval

    # Binomial Parameters
    u = math.exp(sigma * math.sqrt(dt)) # up movement
    d = 1 / u # down movement
    q = (math.exp(r * dt) - d) / (u - d) # martingale branch probability


    # Array Initialization for Index Levels
    mu = np.arange(M + 1)
    mu = np.resize(mu, (M + 1, M + 1))
    md = np.transpose(mu)
    mu = u ** (mu - md)
    md = d ** md
    S = S0 * mu * md


    # Inner Values
    if otype == 'call':
        V = np.maximum(S - K, 0)     # inner values for European call option
    else:
        V = np.maximum(K - S, 0)     # inner values for European put option


    z = 0
    for t in range(M - 1, -1, -1):    # backwards iteration
         V[0:M - z, t] = (q * V[0:M - z, t + 1]
94                                              DERIVATIVES ANALYTICS WITH PYTHON


                         + (1 - q) * V[1:M - z + 1, t + 1]) * df
         z += 1
     return V[0, 0]


def plot_convergence(mmin, mmax, step_size):
    ''' Plots the CRR option values for increasing number of time
     intervals M against the Black-Scholes-Merton benchmark value.'''
     BSM_benchmark = BSM_call_value(S0, K, 0, T, r, sigma)
     m = xrange(mmin, mmax, step_size)
     CRR_values = [CRR_option_value(S0, K, T, r, sigma, 'call', M) for M in m]
     plt.figure(figsize=(9, 5))
     plt.plot(m, CRR_values, label='CRR values')
     plt.axhline(BSM_benchmark, color='r', ls='dashed', lw=1.5,
                 label='BSM benchmark')
     plt.grid()
     plt.xlabel('# of binomial steps $M$')
     plt.ylabel('European call option value')
     plt.legend(loc=4)
     plt.xlim(0, mmax)
                                                                            CHAPTER         6
                                Fourier-Based Option Pricing


6.1 INTRODUCTION

Chapter 4 introduces the elegant and general theory of arbitrage pricing by risk-neutral dis-
counting. Chapter 5 discusses the rather special setting of Black-Scholes-Merton and presents
the famous analytical valuation formula for European options. In the first case, the generality
of the approach is what is appealing. In the second case, the highly specific but very useful
valuation formula is the advantage.
     The question is whether there is an approach to derive formulas as useful as the BSM one
in more general settings, thereby bridging the gap between generality of risk-neutral pricing
and the specificity of the BSM formula. Fortunately, there is an approach: Fourier-based option
pricing. This approach allows the use of semi-analytic valuation formulas for European options
whenever the characteristic function of the stochastic process representing the underlying is
known.
     The Fourier approach, presented in this chapter, has three main advantages:

 1. generality: as pointed out, the approach is applicable whenever the characteristic function
    of the process driving uncertainty is known; and this is the case for the majority of
    processes/models applied in practice
 2. accuracy: the semi-analytic formulas can be evaluated numerically in such a way that a
    high degree of accuracy is reached at little computational cost (e.g. compared to simulation
    techniques)
 3. speed: the formulas can in general be evaluated very fast such that 10s, 100s or even
    1,000s of options can be valued per second

     These three advantages make Fourier-based option pricing an indispensible tool in prac-
tice. In particular, when calibrating a model to option quotes or implied volatilities, there is
often no real alternative. In this chapter, the discussion focuses on European call options since
these are in general the instruments of choice for the calibration of financial models. However,
using put-call parity, put prices are only one step away.
     There is a large body of literature dealing with Fourier-based pricing methods. For practical
purposes, the valuation formulas of Lewis (2001) and Carr and Madan (1999) are of high
importance. Duffie et al. (2000) provides an in-depth analysis of this method in the context


                                                                                               95
96                                                            DERIVATIVES ANALYTICS WITH PYTHON


of affine jump-diffusion models. Cheng and Scaillet (2007) generalizes the results of Duffie
et al. (2000) to the class of linear quadratic jump-diffusion models. Cherubini et al. (2009)
is a focused monograph on derivatives valuation via Fourier transforms. Schmelzele (2010)
is a recent survey article comparing a number of approaches in Fourier-based option pricing.
CeÃårnyÃÅ (2004) discusses several fundamental aspects and shows how to apply this approach
to the binomial model. Generally, the introduction of this method to mathematical finance is
attributed to Heston (1993).
     Section 6.2 reformulates the risk-neutral pricing problem and shows how Fourier-based
option pricing can help in solving it. Section 6.3 introduces the fundamental concepts of Fourier
transforms of functions and of characteristic functions. Section 6.4 presents the two popular
pricing approaches as developed by Lewis (cf. Lewis (2001)) and Carr-Madan (cf. Carr and
Madan (1999)). Full proofs are given due to the importance for later chapters. Section 6.5 treats
Fourier series and the Fast Fourier Transform algorithm as numerical methods for function
approximation and option valuation. Section 6.6 then applies the approaches presented in
a continuous and a discrete market model. The continuous theory is extensively used and
illustrated in later chapters. Therefore the focus lies on the application to the binomial model
of Cox-Ross-Rubinstein which allows a closer look into the inner workings of Fourier pricing
and allows a first assessment of the accuracy and speed of the approach.


6.2 THE PRICING PROBLEM

We consider a continuous market model

                                 Óàπ = {(Œ©, Óà≤ , F, P), T, (S, B)}

with the fixed filtered probability space (Œ©, Óà≤ , F, P) and a final date 0 < T < ‚àû. Two assets
are traded in the economy, a (positive) stock index St‚àà[0,T] which is a semimartingale and
a risk-less bond B paying one unit of currency at T with time t value Bt ‚â° e‚àír(T‚àít) where
r ‚â• 0 represents the constant short rate. We assume no free lunches with vanishing risk such
that there is a P-equivalent martingale measure Q making the discounted index process a
martingale.
     We then know that the arbitrage value of an attainable call option is

                                     Ct = e‚àír(T‚àít) EQ
                                                    t (CT )

where CT ‚â° max[ST ‚àí K, 0] for a strike K > 0. In integral from, setting t = 0, the call option
pricing reads
                                                   ‚àû
                                  C0 = e‚àírT            CT (s)Q(ds)
                                              ‚à´0
                                                   ‚àû
                                     = e‚àírT            CT (s)q(s)ds                        (6.1)
                                              ‚à´0

where q(s) is the risk-neutral probability density function (pdf) of ST . Unfortunately, the pdf
is quite often not known in closed form‚Äîwhereas the characteristic function (CF) of ST is.
Fourier-Based Option Pricing                                                                     97


The fundamental insight of Fourier-based option pricing is to replace both the pdf by the CF
and the call option payoff CT by its Fourier transform.
     Therefore we will first define these fundamental terms and will then present two different
versions of the Fourier-based pricing approach.



6.3 FOURIER TRANSFORMS

In a continuous setting, we have the following definition:

Definition 40 (Fourier Transform).         The Fourier transform of the integrable function f (x) is

                                                   ‚àû
                                      fÃÇ (u) ‚â°          eiux f (x)dx
                                                 ‚à´‚àí‚àû

with u either real or complex. eiux is called the phase factor.

    By Fourier inversion

                                                    ‚àû
                                              1
                                   f (x) =          e‚àíiux fÃÇ (u)du
                                             2ùúã ‚à´‚àí‚àû

for u real and

                                                  ‚àû+iu
                                                    i
                                            1
                                 f (x) =              e‚àíiux fÃÇ (u)du
                                           2ùúã ‚à´‚àí‚àû+iui

for u complex with u = ur + iui where ur and ui denote the real and imaginary part of u,
respectively.
     Denote the inner product of two complex-valued, square-integrable functions f , g by

                                                    ‚àû
                                     ‚ü®f , g‚ü© ‚â°          f (x)g(x)dx
                                                 ‚à´‚àí‚àû

with uÃÑ denoting the complex conjugate of u, i.e. for u = ur + iui it holds uÃÑ = ur ‚àí iui .

Theorem 4 (Parseval‚Äôs Relation).        f , g as before, then
                                                        ‚àû
                                              1
                                   ‚ü®f , g‚ü© =              fÃÇ (k)ÃÇg(k)dk
                                             2ùúã ‚à´‚àí‚àû
                                              1 ÃÇ
                                           =    ‚ü®f , gÃÇ ‚ü©                                      (6.2)
                                             2ùúã
98                                                                DERIVATIVES ANALYTICS WITH PYTHON


                                                             ‚àû
Proof. By the inner product definition ‚ü®f , g‚ü© ‚â° ‚à´‚àí‚àû f (x)g(x)dx. By Fourier inversion f (x) =
   ‚à´ e‚àíiux fÃÇ (k)dk. Inserting the latter in the former gives (cf. Schmelzele (2010))
 1  ‚àû
2ùúã ‚àí‚àû

                                          ‚àû             ‚àû
                                        1
                          ‚ü®f , g‚ü© =               e‚àíiux fÃÇ (k)dkg(x)dx
                                   ‚à´‚àí‚àû 2ùúã ‚à´‚àí‚àû
                                        ‚àû           ‚àû
                                    1
                                 =        fÃÇ (k)       e‚àíiux g(x)dxdk
                                   2ùúã ‚à´‚àí‚àû        ‚à´‚àí‚àû
                                                  ‚àû          ‚àû
                                    1
                                 =        fÃÇ (k)      eiux g(x)dxdk
                                   2ùúã ‚à´‚àí‚àû        ‚à´‚àí‚àû
                                        ‚àû
                                    1
                                 =        fÃÇ (k)ÃÇg(k)dk
                                   2ùúã ‚à´‚àí‚àû

applying the Fubini-Tonello theorem where needed (cf. Bhattacharya and Waymire (2007),
app. A).


Definition 41 (Characteristic Function). Let a random variable X be distributed with pdf
q(x). The characteristic function qÃÇ of X is the Fourier transform of its pdf
                                              ‚àû
                              qÃÇ (u) ‚â°            eiux q(x)dx = EQ (eiuX )
                                         ‚à´‚àí‚àû


6.4 FOURIER-BASED OPTION PRICING

This section uses the tools developed so far to reproduce two popular, Fourier-based option
pricing approaches.

6.4.1 Lewis (2001) Approach
Fourier-based option pricing is an application of Parseval‚Äôs relation (6.2) to the risk-neutral
pricing equation (6.1). Consider a European call option with payoff CT ‚â° max[es ‚àí K, 0]
where s ‚â° log S.

Lemma 2 (Call Option Transform).              For u = ur + iui with ui > 1, the Fourier transform of
CT is

                                                        iu+1
                                          ÃÇ T (u) = ‚àí K
                                          C
                                                     u2 ‚àí iu
Proof.   By direct integration
                                               ‚àû
                             ÃÇ T (u) =
                             C                     eius max[es ‚àí K, 0]ds
                                          ‚à´‚àí‚àû
                                               ‚àû
                                      =               eius (es ‚àí K)ds
                                          ‚à´log K
Fourier-Based Option Pricing                                                                       99

                                               ‚àû
                                         =        (e(iu+1)s ‚àí Keius )ds
                                           ‚à´log K
                                           [ (iu+1)s             ]‚àû
                                            e               eius
                                         =             ‚àíK
                                             iu + 1          iu log K
                                            K iu+1
                                         =‚àí 2
                                           u ‚àí iu


    Fourier inversion gives
                                                    ‚àû+iu
                                                      i
                                              1               ÃÇ T (u)du
                                  CT (s) =              e‚àíius C
                                             2ùúã ‚à´‚àí‚àû+iui
Now
                                            ( )
                               C0 = e‚àírT EQ
                                          0
                                             CT
                                             (                  )
                                                ‚àû+iui
                                    e‚àírT Q             ‚àíius ÃÇ
                                  =      E            e CT (u)du
                                     2ùúã 0 ‚à´‚àí‚àû+iui
                                               ‚àû+iu
                                      e‚àírT      i
                                                               ÃÇ T (u)du
                                  =               EQ (ei(‚àíu)s )C
                                       2ùúã ‚à´‚àí‚àû+iui 0
                                               ‚àû+iu
                                      e‚àírT      i
                                                  ÃÇ (u)ÃÇq(‚àíu)du
                                  =               C
                                       2ùúã ‚à´‚àí‚àû+iui T

If St ‚â° S0 ert+Xt with Xt a LeÃÅvy process and eXt a martingale with X0 = 0, then qÃÇ (‚àíu) =
e‚àíiuy ùúë(‚àíu) where ùúë is the characteristic function of XT . Here, y ‚â° log S0 + rT. Now
                                                ‚àû+iu
                                        e‚àírT      i
                                                          ÃÇ
                                C0 =                e‚àíiuy C(u)ùúë(‚àíu)du
                                         2ùúã ‚à´‚àí‚àû+iui

Defining k = log(S0 ‚àïK) + rT and using the derived call option payoff transform yields
                                                   ‚àû+iu
                                        Ke‚àírT        i
                                                                     du
                               C0 = ‚àí                  e‚àíiuk ùúë(‚àíu) 2                             (6.3)
                                         2ùúã   ‚à´ ‚àí‚àû+iui            u ‚àí ui

Proposition 6 (Lewis (2001)).           Assuming ui ‚àà (0, 1), the call option present value is
                                                    ‚àû+iu
                                         Ke‚àírT     i
                                                                   du
                          C0 = S0 ‚àí                  e‚àíiuk ùúë(‚àíu) 2                               (6.4)
                                          2ùúã ‚à´‚àí‚àû+iui            u ‚àí ui

Furthermore, setting ui = 0.5 gives
                                 ‚àö
                                  S0 Ke‚àírT‚àï2          ‚àû
                                                                                dz
                   C0 = S0 ‚àí                              Re[eizk ùúë(z ‚àí i‚àï2)] 2                  (6.5)
                                         ùúã       ‚à´0                          z + 1‚àï4

where Re[x] denotes the real part of x.
100                                                              DERIVATIVES ANALYTICS WITH PYTHON


Proof.    Equation (6.3) has two singularities at u = i and u = 0. Residue calculus gives for the
first
                                     (        (                      ))
                                                  Ke‚àírT ‚àíiuk ùúë(‚àíu)
                       Res(i) = lim (u ‚àí i) ‚àí          e
                                u‚Üíi                2ùúã       u(u ‚àí i)
                                  Ke  ‚àírT    ùúë(‚àíi)
                              =‚àí          ek
                                     2ùúã        i
                                S0 i
                              =
                                 2ùúã

using ek = S0 ‚àïK ‚ãÖ erT , ùúë(‚àíi) = 1 and i‚àí1 = ‚àíi in the last equation. According to the residue
theorem (cf. Rudin (1970), ch. 13), the call option value equals the integral along ui minus
2ùúãiRes(i) = ‚àíS0 such that equation (6.4) follows immediately. Fixing ui = 0.5

                                       ‚àû
                           Ke‚àírT                                       du
            C0 = S0 ‚àí              e‚àíi(u+i‚àï2)k ùúë(‚àí(u + i‚àï2))
                            2ùúã ‚à´‚àí‚àû                           (u + i‚àï2)2 ‚àí (u + i‚àï2)i

Note that

                                           e‚àíi(u+i‚àï2)k = e‚àíiuk ek‚àï2

with

                                           ek‚àï2 = e(log(S0 ‚àïK)+rT)‚àï2

so that
                                                          ‚àö
                                       Ke‚àírT ek‚àï2 = e‚àírT‚àï2 S0 K

Defining u = z + i‚àï2 gives

                              (z ‚àí i‚àï2)2 ‚àí (z ‚àí i‚àï2)i = z2 ‚àí 2zi + 1‚àï4

and
                               ‚àö
                                   S0 Ke‚àírT‚àï2      ‚àû
                                                                             dz
                 C0 = S0 ‚àí                             e‚àíizk ùúë(‚àíz ‚àí i‚àï2) 2
                                       ùúã        ‚à´‚àí‚àû                     z ‚àí 2zi + 1‚àï4

For f integrable and real-valued, Fourier inversion and symmetry of the characteristic function
around u = 0 yields (cf. Schmelzele (2010))
                                   ‚àû
                         1
                 f (x) =        e‚àíiux fÃÇ (u)du
                        2ùúã ‚à´‚àí‚àû
                              [ 0                 ]        ‚àû
                         1                            1
                      =    Re       e‚àíiux fÃÇ (u)du +         Re[e‚àíiux fÃÇ (u)du]
                        2ùúã     ‚à´‚àí‚àû                   2ùúã ‚à´0
                              [ ‚àû                 ]        ‚àû
                         1                            1
                      =    Re       e‚àíiux fÃÇ (u)du +         Re[e‚àíiux fÃÇ (u)du]
                        2ùúã     ‚à´0                    2ùúã ‚à´0
Fourier-Based Option Pricing                                                                   101

                             [     ‚àû           ]
                         1            ‚àíiux ÃÇ
                      =    Re 2      e f (u)du
                        2ùúã      ‚à´0
                            [ ‚àû              ]
                        1          ‚àíiux ÃÇ
                      = Re        e f (u)du
                        ùúã    ‚à´0

Using this result leads to
                               ‚àö
                                   S0 Ke‚àírT‚àï2        ‚àû
                                                                                 dz
                 C0 = S0 ‚àí                               Re[e‚àíizk ùúë(‚àíz ‚àí i‚àï2)] 2
                                      ùúã         ‚à´0                            z + 1‚àï4

By symmetry, the value of the integral remains unchanged if e‚àíizk ùúë(‚àíz ‚àí i‚àï2) is replaced by
eizk ùúë(z ‚àí i‚àï2) proving equation (6.5).

   Valuation equation (6.5) can be evaluated by standard numerical integration methods, like
numerical quadrature.


6.4.2 Carr-Madan (1999) Approach
Define the payoff of a European call option with strike price K at maturity T as CT ‚â°
max[ST ‚àí K, 0] where K ‚â° ek and ST ‚â° es . The present value of the call option is
                                                (                 )
                                   C0 ‚â° e‚àírT EQ
                                              0
                                                 max[es ‚àí ek , 0]
                                                     ‚àû
                                       = e‚àírT            (es ‚àí ek )q(s)ds
                                                ‚à´k

where q(s) is the risk-neutral pdf of sT . To ensure integrability, define c0 ‚â° eùõºk C0 with ùõº > 0.
The Fourier transform of c0 is

                                                         ‚àû
                                          ùúì(v) ‚â°             eivk c0 dk
                                                     ‚à´‚àí‚àû

while the inverse transform is
                                                         ‚àû
                                            e‚àíùõºk
                                     C0 =                    e‚àíivk ùúì(v)dv                     (6.6)
                                             ùúã ‚à´0

In-the-Money Options

Proposition 7 (Carr-Madan (1999)).            The call option value is given by (6.6) where

                                               e‚àírT ùúë(v ‚àí (ùõº + 1)i)
                                   ùúì(v) =                                                     (6.7)
                                            ùõº 2 + ùõº ‚àí v2 + i(2ùõº + 1)v

with ùúë as characteristic function ùúë(u) ‚â° EQ
                                          0
                                            (eiusT ) of sT ‚â° log ST .
102                                                                   DERIVATIVES ANALYTICS WITH PYTHON


Proof. Taking the Fourier transform, using risk-neutral valuation and applying the Fubini-
Tonello theorem yields (cf. Schmelzele (2010))
                                  ‚àû
                      ùúì(v) =          eivk c0 dk
                                ‚à´‚àí‚àû
                                  ‚àû                  (   ‚àû                        )
                                       ivk ‚àírT               ùõºk   s     k +
                            =         e e        e (e ‚àí e ) q(s)ds dk
                                ‚à´‚àí‚àû                   ‚à´‚àí‚àû
                                ‚àû                    ( ‚àû         )
                                   ivk ‚àírT        ùõºk s     k
                            =     e e            e (e ‚àí e )q(s)ds dk
                              ‚à´‚àí‚àû           ‚à´k
                                ‚àû          (   s                 )
                                   ‚àírT            ivk ùõºk s   k
                            =     e q(s)         e e (e ‚àí e )dk ds
                              ‚à´‚àí‚àû           ‚à´‚àí‚àû

The inner integral allows direct integration
            s                                    s                      s
                eivk eùõºk (es ‚àí ek )dk = es           e(iv+ùõº)k dk ‚àí  e(iv+1+ùõº)k dk
         ‚à´‚àí‚àû                               ‚à´‚àí‚àû                ‚à´‚àí‚àû
                                           es [ (iv+ùõº)k ]s             1     [ (iv+1+ùõº)k ]s
                                      =          e            ‚àí                e
                                        iv + ùõº            ‚àí‚àû     iv + 1 + ùõº               ‚àí‚àû

                                        e(iv+1+ùõº)s     e(iv+1+ùõº)s
                                      =            ‚àí
                                          iv + ùõº      iv + 1 + ùõº
                                              e(iv+1+ùõº)s
                                      =
                                        (iv + ùõº)(iv + 1 + ùõº)

Rearranging e(iv+1+ùõº)s = ei(v‚àí(ùõº+1))s , multiplying out the denominator and plugging back in
yields the desired Fourier transform


                                                e‚àírT ùúë(v ‚àí (ùõº + 1)i)
                                 ùúì(v) =
                                             ùõº 2 + ùõº ‚àí v2 + i(2ùõº + 1)v




     Consequently, knowledge of the characteristic function ùúë of the relevant process and
therewith of ùúì allows direct computation of C0 via equation (6.6).


Out-of-the-Money Options For out-of-the-money options define z0 to be the current price of
a European put if k < log S0 and to be the price of a European call if k > log S0 where S0 ‚â° 1.
In other words, consider time values only. After similar calculations and manipulations (see
Carr and Madan (1999)) the Fourier transform of z0 arises as

                                             (                                )
                                                   1      erT ùúë(v ‚àí i)
                             ùúç(v) = e  ‚àírT
                                                        ‚àí     ‚àí 2
                                                 1 + iv    iv   v ‚àí iv
Fourier-Based Option Pricing                                                                103


Due to the symmetry of z0 around k = 0, dampen the function by sinh(ùõºk) to get a new
transform
                                                   ‚àû
                                   ùõæ(v) =        eivk sinh(ùõºk)z0 dk
                                            ‚à´‚àí‚àû
                                            ùúç(v ‚àí iùõº) ‚àí ùúç(v + iùõº)
                                          =
                                                       2
After inverting this new transform, the time value becomes


                                                               ‚àû
                                             1     1
                                z0 =                     e‚àíivk ùõæ(v)dv                      (6.8)
                                         sinh(ùõºk) 2ùúã ‚à´‚àí‚àû




6.5 NUMERICAL EVALUATION

This section illustrates the Fourier-based pricing approach by the means of more simple
settings.



6.5.1 Fourier Series
We are now in a discrete setting.


Definition 42 (Fourier Series). A Fourier series is an infinite sum of the form

                                         ‚àë
                                         ‚àû
                               f (x) =         (an cos nx + bn sin nx)
                                         n=0
                                                 ‚àë
                                                 ‚àû
                                    = a0 +         (an cos nx + bn sin nx)
                                                 n=1

which is a 2ùúã-periodic function, i.e. f (x) = f (x + 2ùúã).


     If f (x) is a known 2ùúã-periodic function, then the coefficients of the series are according
to the Euler formulas
                                                           ùúã
                                           1
                                     a0 =         f (x)dx
                                          2ùúã ‚à´‚àíùúã
                                              ùúã
                                          1
                                     an =       f (x) cos nxdx
                                          ùúã ‚à´‚àíùúã
                                                       ùúã
                                                1
                                     bn =             f (x) sin nxdx
                                                ùúã ‚à´‚àíùúã
104                                                                     DERIVATIVES ANALYTICS WITH PYTHON


For an arbitrary interval [‚àíL, L] , the formulas are

                                        ‚àë‚àû (       (     )         (      ))
                                                     nùúã              nùúã
                         f (x) = a0 +       an cos      x + bn sin      x
                                        n=1
                                                      L               L
                                         L
                                   1
                           a0 =          f (x)dx
                                  2L ‚à´‚àíL
                                    L           (     )
                                1                 nùúã
                           an =       f (x) cos      x dx
                                L ‚à´‚àíL              L
                                    L           (     )
                                1                 nùúã
                           bn =       f (x) sin      x dx
                                L ‚à´‚àíL              L

If u is complex with u = ur + iui then by Euler identity

                                  eiux = eur x cos(ur x) + ieur x sin(ui x)

so that

                                                  ‚àë
                                                  ‚àû
                                                                 nùúã
                                      f (x) =          cn ei L x                                    (6.9)
                                                n=‚àí‚àû
                                                         L
                                                   1             nùúã
                                        cn =             f (x)e‚àíi L x dx                           (6.10)
                                                  2L ‚à´‚àíL

    In a sense, the complex Fourier series (6.9) is the discrete equivalent of a Fourier transform.
To see this, denote kn ‚â° nùúã
                          L
                            , cÃÇ (kn ) ‚â° cn and write

                                                     ‚àë
                                                     ‚àû
                                          f (x) =            cÃÇ (kn )eikn x
                                                    n=‚àí‚àû


It holds Œî nùúã
            L
              = ùúãL Œîn with Œîn = 1. So ùúãL Œîkn = ùúãL Œî nùúã
                                                     L
                                                       = 1. Multiplying with this unity factor
gives

                                                L ‚àë
                                                    ‚àû
                                     f (x) =          cÃÇ (k )eikn x Œîkn
                                                ùúã n=‚àí‚àû n

Now define fÃÇ (kn ) ‚â° ùúãL cÃÇ (kn ) yielding

                                                   ‚àë
                                                   ‚àû
                                        f (x) =          fÃÇ (kn )eikn x Œîkn
                                                  n=‚àí‚àû

and
                                                             L
                                                L 1
                                     fÃÇ (kn ) =          f (x)e‚àíikn x dx
                                                ùúã 2L ‚à´‚àíL
Fourier-Based Option Pricing                                                             105


using (6.10). Taking the limit L ‚Üí ‚àû and dropping the n subscript, the sum becomes an
integral yielding
                                                  ‚àû
                                    f (x) =           fÃÇ (k)eikx dk
                                               ‚à´‚àí‚àû
                                                          ‚àû
                                              1
                                    fÃÇ (k) =        e‚àíikx f (x)dx
                                             2ùúã ‚à´‚àí‚àû

Changing the sign in the phase factor and multiplying f (x) by 2ùúã thus dividing fÃÇ (x) by 2ùúã
leads to the Fourier transform pair as defined previously
                                                  ‚àû
                                    fÃÇ (k) =          eikx f (x)dx
                                               ‚à´‚àí‚àû
                                                       ‚àû
                                                1
                                    f (x) =           e‚àíikx fÃÇ (k)dk
                                               2ùúã ‚à´‚àí‚àû

    A simple numerical example shall illustrate how Fourier series can approximate functions.

Example 2 (Fourier Series). Consider the function f (x) = |x| over the interval [‚àíùúã, ùúã]. This
function can be approximated by the Fourier series

                                         ‚àû [           ]
                                      ùúã ‚àë 2((‚àí1)n ‚àí 1)
                               f (x) = +                 cos nx
                                      2 n=1   ùúãn2


Sub-section 6.8.2 contains a Python script implementing and plotting the formula. Figure 6.1
shows the output for series of order 1 and 5‚Äîthe better approximation of the higher order
series is obvious.



6.5.2 Fast Fourier Transform
Fast Fourier Transform (FFT) is an efficient algorithm, dating back to Cooley (1965), to
compute sums of type (cf. Carr and Madan (1999))


                                    ‚àë
                                    N
                                          2ùúã
                           w(u) =     e‚àíi N (j‚àí1)(u‚àí1) x(j), u = 1, ‚Ä¶ , N              (6.11)
                                    j=1



Defining vj ‚â° ùúÇ(j ‚àí 1) the integral (6.6) can be numerically approximated by the sum


                                               e‚àíùõºk ‚àë ‚àíivj k
                                                      N
                                    C0 ‚âà              e      ùúì(vj )ùúÇ
                                                ùúã j=1
106                                                          DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 6.1    Fourier series approximation of function f (x) = |x| of order 1 (left) and of order 5
(right)



    Let ùúñ be a regular spacing parameter and consider the sequence of log-strikes ku =
‚àíb + ùúñ(u ‚àí 1) with u = 1, ‚Ä¶ , N. With this spacing, the FFT algorithm returns N values for
log-strikes ranging from ‚àíb to b with b = 0.5Nùúñ. Then


                                e‚àíùõºku ‚àë ‚àíivj (‚àíb+ùúñ(u‚àí1))
                                         N
                         C0 ‚âà           e                ùúì(vj )ùúÇ, u = 1, ‚Ä¶ , N
                                  ùúã j=1


Substituting vj yields


                         e‚àíùõºku ‚àë ‚àíiùúñùúÇ(j‚àí1)(u‚àí1) ibvj
                                     N
                    C0 ‚âà         e             e ùúì(vj )ùúÇ, u = 1, ‚Ä¶ , N
                           ùúã j=1


Realizing that ùúñùúÇ = 2ùúã
                    N
                       which implies that a small ùúÇ increases ùúñ and vice versa, introduce
weightings according to Simpson‚Äôs rule such that the call approximation finally takes on the
form


                 e‚àíùõºku ‚àë ‚àíi 2ùúã
                          N
                                                    ùúÇ
          C0 ‚âà           e N (j‚àí1)(u‚àí1) eibvj ùúì(vj ) (3 + (‚àí1)j ‚àí ‚ãÑj‚àí1 ), u = 1, ‚Ä¶ , N            (6.12)
                   ùúã j=1                            3


with ‚ãÑn being the Kronecker delta function which takes value one for n = 0 and zero otherwise.
Equation (6.12) has a form similar enough to equation (6.11) to directly apply the FFT
algorithm to it.
Fourier-Based Option Pricing                                                                   107


6.6 APPLICATIONS

This section applies the methods introduced in this chapter to different continuous and discrete
market models.

6.6.1 Black-Scholes-Merton (1973) Model
To illustrate the usefulness of the transform method and the accuracy of formula (6.5) this
example applies them alongside the FFT algorithm to the BSM model (the next sub-section
and Chapter 8 do it for the Merton (1976) model and Chapter 9 for the Bakshi-Cao-Chen
(1997) model). The characteristic function of the BSM model (without dividends) is given by
                                                    2      2   2
                               ùúëBSM
                                0
                                    (u, T) = e((r‚àíùúé ‚àï2)iu‚àíùúé ‚àï2u )T

The Python script in sub-section 6.8.1 implements this characteristic function and formula
(11.12), which is a variant of (6.5), for a constant short rate r. In addition, it provides a FFT
algorithm implementation for BSM and as a benchmark the standard analytical call option
formula without dividends (cf. Wilmott et al. (1995), p. 48, or Chapter 5 of this book)

                               C0 = S0 ‚ãÖ N(d1 ) ‚àí e‚àírT ‚ãÖ K ‚ãÖ N(d2 )
                                              (      2)
                                    log K0 + r + ùúé2 T
                                         S

                               d1 ‚â°          ‚àö
                                           ùúé T
                                           ‚àö
                               d2 ‚â° d1 ‚àí ùúé T

where N is the cumulative distribution function of a standard normal random variable. Fig-
ure 6.2 compares the accuracy of formula (6.5) against the analytical values for a range of
strikes. Figure 6.3 does the same for FFT values where the same grid spacing is used as in
CM99. While formula (6.5) is accurate up to 12 digits, the FFT approach is accurate ‚Äúonly‚Äù
up to five digits (with this particular parametrization). In the calibration of the BCC97 model,
we use formula (6.5) because it is more accurate.
      In terms of speed one can say the following. Based on 5,000 valuations of the same call
(with original CM99 parameters for the FFT routine), the analytical formula is the benchmark
with a normalized time of 1 (which translates to 0.898 seconds on the author‚Äôs notebook). FFT
is slower by a factor of 7.9 and numerical integration by a factor of 15.1 such that FFT is about
1.9 times faster than numerical integration.
      In the example, it is not taken into account that the FFT algorithm may in principle deliver
call values for a number of different strikes with a single valuation run. However, the number
of application areas for this particular feature of FFT seems sometimes a bit limited. Kahl
(2007), for example, comments in this regard:

    ‚Äú‚Ä¶when calibrating a model to quoted option prices one typically has quotes for just
    a couple of strikes and maturities. Using the FFT would require a uniform grid in the
    log-strike direction ‚Ä¶ The strikes of the options to which we calibrate will typically
    not lie on this grid, so that an additional source of error is introduced when using the
    FFT: interpolation error.‚Äù
108                                                        DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 6.2 Valuation accuracy of Lewis‚Äô integral approach in comparison to BSM analytical
formula; parameter values are S0 = 100, T = 1.0, r = 0.05, ùúé = 0.2



     Although it is quite nice to have an alternative pricing mechanism for BSM, the benefit
is only marginal in this setup. This is different when considering more complex models, like
Merton (1976) or Bakshi-Cao-Chen (1997). For these models, knowledge of the characteristic
function makes European call option pricing as simple as in the BSM case.


6.6.2 Merton (1976) Model
Consider the continuous market model ÓàπM76 where the risk-neutral stock index dynamics
are given by the jump diffusion of Merton (1976)


                            dSt = (r ‚àí rJ )St dt + ùúéSt dZt + Jt St dNt                  (6.13)


r is the constant short rate, ùúé the constant volatility, Zt a standard Brownian motion, Nt a
Poisson process with intensity ùúÜ. Furthermore, Jt is the jump at date t with distribution

                                          (                     )
                                                         ùõø2
                          log(1 + Jt ) ‚âà N log(1 + ùúáJ ) ‚àí , ùõø 2
                                                         2
Fourier-Based Option Pricing                                                              109




FIGURE 6.3 Valuation accuracy of CM99 FFT approach in comparison to BSM analytical formula;
parameter values are S0 = 100, T = 1.0, r = 0.05, ùúé = 0.2, N = 4, 096, ùúñ = 150‚àí1



where N is the cumulative distribution function of a standardized normal random variable.
Finally


                                     rJ ‚â° ùúÜ ‚ãÖ (eùúáJ +ùõø ‚àï2 ‚àí 1)
                                                    2




    The characteristic function of log ST given stock index dynamics (6.13) is a well-known
function
                                   ((                                   ) )
                                           u2 ùúé 2
                                                  + ùúÜ(eiuùúáJ ‚àíu ùõø ‚àï2 ‚àí 1) T
                                                              2 2
                  ùúëM76 (u) = exp     iuùúî ‚àí                                             (6.14)
                                             2

where the risk-neutral drift term ùúî takes on the form

                                          ùúé2
                                             ‚àí ùúÜ(eùúáJ +ùõø ‚àï2 ‚àí 1)
                                                       2
                               ùúî=r‚àí                                                    (6.15)
                                          2

Valuation of a European call option then boils down to inserting (6.14)/(6.15) in either (6.5)
and using an appropriate numerical integration scheme or (6.6)‚Äì(6.8) and applying FFT.
110                                                         DERIVATIVES ANALYTICS WITH PYTHON


6.6.3 Discrete Market Model
Consider the discrete market model of Cox-Ross-Rubinstein with binomial representation of
the index dynamics. Although not further needed, the application of Fourier-based option
pricing to this type of model is rather instructive since it allows a ‚Äúlook behind the scenes‚Äù.
The exposition follows CeÃårnyÃÅ (2004) rather closely.
     Before attacking the valuation problem itself, some more notions have to be introduced.

Definition 43 (Root of Unity).      The nth root of unity is

                                                     2ùúã
                                           zn ‚â° e‚àíi n

      Note that (z5 )0 = (z5 )5 = (z5 )10 = (z5 )15 = ‚Ä¶ (anticlockwise rotation) and (z5 )0 =
(z5 )‚àí5 = (z5 )‚àí10 = (z5 )‚àí15 = ‚Ä¶ (clockwise rotation). We have

                                 (zn )1 + (zn )2 + ...(zn )n‚àí1 = 0

We also have
                       ( k )1 ( k )2 ( )n‚àí1
                        zn + zn + ‚ãØ + zkn   = 0, k ‚â† 0, n, ‚àín

and
                       ( k )1 ( k )2 ( )n‚àí1
                        zn + zn + ‚ãØ + zkn   = n, k = 0, n, ‚àín

Given a sequence of numbers a = (a0 , a1 , ‚Ä¶ , an‚àí1 ), its reverse order is given by rev(a) =
(a0 , an‚àí1 , ‚Ä¶ , a1 ). Given the sequence

                                       (( k )0 ( k )1 ( )n‚àí1 )
                              z(k) =     zn , zn , ‚Ä¶ , zkn

it can be shown that rev(z(‚àík)) = z(k).
     Figure 6.4 shows two series of roots of unity plotted as ‚Äúspokes of a wheel‚Äù, for n = 5
and n = 30. The Python script in sub-section 6.8.3 generates such plots.
     Now, let a sequence a = (a0 , a1 , ‚Ä¶ , an‚àí1 ) of n (complex) numbers be given.

Definition 44 (Discrete Fourier Transform). The discrete Fourier transform (DFT) of a is
the sequence b = (b0 , b1 , ‚Ä¶ , bn‚àí1 ) where
                                ( )0     ( )1           ( )n‚àí1
                         bk = a0 zkn + a1 zkn + ‚ãØ + an‚àí1 zkn
                              ‚àë
                              n‚àí1
                                    ( )j
                            =     aj zkn
                              j=0


We write ÓâÄ (a) = b.
Fourier-Based Option Pricing                                                                    111




FIGURE 6.4     Series with roots of unity for n = 5 and n = 30 plotted in the imaginary plane



   The discrete inverse Fourier transform of b is then the sequence a = (a0 , a1 , ‚Ä¶ , an‚àí1 )
where
                         ( ( )           ( ‚àíl )1            ( ‚àíl )n‚àí1 )
                                  0
                    al = b0 z‚àíl
                              n     + b1  z n    + ‚ãØ + bn‚àí1  zn

                               ‚àë
                               n‚àí1
                                       ( )‚àíl
                          =          bk zkn
                               k=0


We write a = ÓâÄ ‚àí1 (b).
    Consider next two sequences a = (a0 , a1 , ‚Ä¶ , an‚àí1 ) and b = (b0 , b1 , ‚Ä¶ , bn‚àí1 ). The con-
volution c of the two sequences is denoted by c = a‚ó¶b and given element-wise by


                                               ‚àë
                                               n‚àí1
                                        cj =         aj‚àík+n‚ãÖ1{j‚àík<0} ‚ãÖ bk
                                               k=0



The script in sub-section 6.8.4 implements this algorithm for two one-dimensional vectors.


Example 3 (Convolution). Assume n = 4, then c = a‚ó¶b = (c0 , c1 , c2 , c3 ) is given by

                                     c0 = a0 b0 + a3 b1 + a2 b2 + a1 b3
                                     c1 = a1 b0 + a0 b1 + a3 b2 + a2 b3
                                     c2 = a2 b0 + a1 b1 + a0 b2 + a3 b3
                                     c3 = a3 b0 + a2 b1 + a1 b2 + a0 b3
112                                                              DERIVATIVES ANALYTICS WITH PYTHON


    We can apply convolutions to value European call options. To this end, remember the
option pricing example of section 5.4 and revisit in particular Table 5.1. At time t = 3Œît we
have

                                                     ‚éõ 36.23 ‚éû
                                                     ‚éú 11.76 ‚éü
                                              C3Œît = ‚éú 0 ‚éü
                                                     ‚éú       ‚éü
                                                     ‚éú 0 ‚éü
                                                     ‚éù 0 ‚é†

Now define a probability vector by

                                                   ‚éõ 0.5034 ‚éû
                                                   ‚éú 0.4966 ‚éü
                                              qv = ‚éú 0 ‚éü
                                                   ‚éú        ‚éü
                                                   ‚éú 0 ‚éü
                                                   ‚éù 0 ‚é†

We can now write

                                     C2Œît = e‚àírŒît ‚ãÖ C3Œît ‚ó¶rev(qv)

and so forth until we reach C0 . In Python, this takes on the form as presented in sub-section
6.8.6. The value the script derives equals exactly the one as reported in Table 5.1, namely
9.97. The Python script in sub-section 6.8.7 implements the algorithm in a general fashion
(the script uses the parameters stored in the script of sub-section 6.8.5).
     The next step is to use the DFT to value a European call option in the model. Consider
two sequences a = (a0 , a1 , ‚Ä¶ , an‚àí1 ) and b = (b0 , b1 , ‚Ä¶ , bn‚àí1 ). It holds

                                     ÓâÄ (a‚ó¶b) = ÓâÄ (a) ‚ãÖ ÓâÄ (b)
                                 ÓâÄ   ‚àí1
                                          (a‚ó¶b) = n ‚ãÖ ÓâÄ ‚àí1 (a) ‚ãÖ ÓâÄ ‚àí1 (b)

We now know that the present value of the call option is

                          C0 = e‚àírT (CT ‚ó¶ rev(qv)‚ó¶rev(qv)‚ó¶...‚ó¶rev(qv))
                                          ‚èü‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èü‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èû‚èü
                                                       T‚àïŒît times


      Fourier inverting the last equation gives

                   ÓâÄ ‚àí1 (C0 ) = e‚àírT ÓâÄ ‚àí1 (CT )((T‚àïŒît + 1) ‚ãÖ ÓâÄ ‚àí1 (rev(qv)))T‚àïŒît

(T‚àïŒît + 1) is the dimension of CT . Taking the DFT again, we get

                     C0 = ÓâÄ (e‚àírT ÓâÄ ‚àí1 (CT )((T‚àïŒît + 1) ‚ãÖ ÓâÄ ‚àí1 (rev(qv)))T‚àïŒît )
    Fourier-Based Option Pricing                                                              113


    With (T‚àïŒît + 1) ‚ãÖ ÓâÄ ‚àí1 (rev(qv)) = ÓâÄ (qv) one obtains

                                     C0 = ÓâÄ (e‚àírT ÓâÄ ‚àí1 (CT )ÓâÄ (qv)T‚àïŒît )

    We also have

                                   C0 = ÓâÄ ‚àí1 (e‚àírT ÓâÄ (CT )ÓâÄ (rev(qv))T‚àïŒîn )

         The Python script in sub-section 6.8.8 implements three alternative formulas relying on
    DFT pricing in the binomial model. Equipped with these formulas we can now test both
    accuracy and speed of the approach. The BSM benchmark value for the example call option
    is 10.4506.
         The DFT approach delivers the following results for 250 valuations including index level
    generations (cf. the script in sub-section 6.8.9). This accuracy is reached with M = 5000 time
    steps.


1    In [3]: run call_fft_speed.py
2    Value of European option is            10.4502
3    Number of Valuations                       250
4    Duration in Seconds                    11.1037
5    Time per Option in Seconds              0.0444
6
7    In [4]:



         Reducing the number of time steps to M = 500, and thereby sacrificing a bit of accuracy,
    yields these results for 250 valuations:


1    In [4]: run call_fft_speed.py
2    Value of European option is 10.4466
3    Number of Valuations                       250
4    Duration in Seconds                     0.1865
5    Time per Option in Seconds              0.0007
6
7    In [5]:



         Reducing the number of time steps by a factor of 10 reduces the time by a factor of more
    than 60. At this level of accuracy, one valuation takes less than 1 millisecond such that more
    than 1,000 options can be valued per second. These numbers are of course dependent on the
    system (hardware, operating system, etc.) used. However, they give a feeling for the trade-off
    between accuracy and speed. And they give a feeling for the advantage of Fourier-based option
    pricing.
114                                                    DERIVATIVES ANALYTICS WITH PYTHON


6.7 CONCLUSIONS

Fourier-based option pricing combines generality of the risk-neutral valuation approach with
the convenience of having a closed-form pricing formula as in the BSM setup. The two
Fourier approaches presented in this chapter are widely applicable and quite fast when it
comes to numerical valuations. In general, this is what makes them an indispensable tool
for practical option pricing applications. Part III of the book will breathe life into these
statements.




6.8 PYTHON SCRIPTS

6.8.1 BSM Call Valuation via Fourier Approach

#
# Valuation of European Call Options in BSM Model
# Comparison of Analytical, int_valueegral and FFT Approach
# 11_cal/BSM_option_valuation_FOU.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
from numpy.fft import fft
from scipy.integrate import quad
from scipy import stats
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'

#
# Model Parameters
#
S0 = 100.00 # initial index level
K = 100.00 # strike level
T = 1. # call option maturity
r = 0.05 # constant short rate
sigma = 0.2    # constant volatility of diffusion

#
# Valuation by int_valueegration
#
### Analytical Formula
Fourier-Based Option Pricing                                              115


def BSM_call_value(S0, K, T, r, sigma):
    ''' Valuation of European call option in BSM Model.
    --> Analytical Formula.


     Parameters
     ==========
     S0: float
         initial stock/index level
     K: float
         strike price
     T: float
         time-to-maturity (for t=0)
     r: float
         constant risk-free short rate
     sigma: float
         volatility factor in diffusion term


     Returns
     =======
     call_value: float
           European call option present value

     '''
     d1 = (np.log(S0 / K) + (r + 0.5 * sigma ** 2) * T) \
                                         / (sigma * np.sqrt(T))
     d2 = (np.log(S0 / K) + (r - 0.5 * sigma ** 2) * T) \
                                         / (sigma * np.sqrt(T))
     BS_C = (S0 * stats.norm.cdf(d1, 0.0, 1.0)
             - K * np.exp(-r * T) * stats.norm.cdf(d2, 0.0, 1.0))
     return BS_C



#
# Fourier Transform with Numerical int_valueegration
#



def BSM_call_value_INT(S0, K, T, r, sigma):
    ''' Valuation of European call option in BSM model via Lewis (2001)
    --> Fourier-based approach (integral).



     Parameters
     ==========
     S0: float
         initial stock/index level
116                                              DERIVATIVES ANALYTICS WITH PYTHON


      K: float
          strike price
      T: float
          time-to-maturity (for t=0)
      r: float
          constant risk-free short rate
      sigma: float
          volatility factor in diffusion term


      Returns
      =======
      call_value: float
            European call option present value
      '''
      int_value = quad(lambda u:
                 BSM_integral_function(u, S0, K, T, r, sigma), 0, 100)[0]
      call_value = max(0, S0 - np.exp(-r * T) * np.sqrt(S0 * K)
                                                  / np.pi * int_value)
      return call_value



def BSM_integral_function(u, S0, K, T, r, sigma):
    ''' Valuation of European call option in BSM model via Lewis (2001)
      --> Fourier-based approach: integral function. '''
      cf_value = BSM_characteristic_function(u - 1j * 0.5, 0.0, T, r, sigma)
      int_value = 1 / (u ** 2 + 0.25) \
              * (np.exp(1j * u * np.log(S0 / K)) * cf_value).real
      return int_value



def BSM_characteristic_function(v, x0, T, r, sigma):
      ''' Valuation of European call option in BSM model via
      Lewis (2001) and Carr-Madan (1999)
      --> Fourier-based approach: characteristic function. '''
      cf_value = np.exp(((x0 / T + r - 0.5 * sigma ** 2) * 1j * v
                  - 0.5 * sigma ** 2 * v ** 2) * T)
      return cf_value


#
# Fourier Transform with FFT
#



def BSM_call_value_FFT(S0, K, T, r, sigma):
    ''' Valuation of European call option in BSM model via Lewis (2001)
    --> Fourier-based approach (integral).
Fourier-Based Option Pricing                                                       117


     Parameters
     ==========
     S0: float
         initial stock/index level
     K: float
         strike price
     T: float
         time-to-maturity (for t=0)
     r: float
         constant risk-free short rate
     sigma: float
         volatility factor in diffusion term


     Returns
     =======
     call_value: float
         European call option present value


     '''
     k = np.log(K / S0)
     x0 = np.log(S0 / S0)
     g = 1 # factor to increase accuracy
     N = g * 4096
     eps = (g * 150.) ** -1
     eta = 2 * np.pi / (N * eps)
     b = 0.5 * N * eps - k
     u = np.arange(1, N + 1, 1)
     vo = eta * (u - 1)
     # Modifications to Ensure int_valueegrability
     if S0 >= 0.95 * K:        # ITM case
         alpha = 1.5
          v = vo - (alpha + 1) * 1j
          modcharFunc = np.exp(-r * T) * (BSM_characteristic_function(
                                      v, x0, T, r, sigma) /
                                            (alpha ** 2 + alpha
                                              - vo ** 2 + 1j * (2 * alpha + 1) * vo))
     else:            # OTM case
          alpha = 1.1
          v = (vo - 1j * alpha) - 1j
          modcharFunc1 = np.exp(-r * T) * (1 / (1 + 1j * (vo - 1j * alpha))
                                            - np.exp(r * T) / (1j * (vo - 1j * alpha))
                                            - BSM_characteristic_function(
                                                 v, x0, T, r, sigma) /
                                              ((vo - 1j * alpha) ** 2
                                            - 1j * (vo - 1j * alpha)))
          v = (vo + 1j * alpha) - 1j
118                                             DERIVATIVES ANALYTICS WITH PYTHON


          modcharFunc2 = np.exp(-r * T) * (1 / (1 + 1j * (vo + 1j * alpha))
                                     - np.exp(r * T) / (1j * (vo + 1j * alpha))
                                     - BSM_characteristic_function(
                                          v, x0, T, r, sigma) /
                                       ((vo + 1j * alpha) ** 2
                                     - 1j * (vo + 1j * alpha)))
      # Numerical FFT Routine
      delt = np.zeros(N, dtype=np.float)
      delt[0] = 1
      j = np.arange(1, N + 1, 1)
      SimpsonW = (3 + (-1) ** j - delt) / 3
      if S0 >= 0.95 * K:
          FFTFunc = np.exp(1j * b * vo) * modcharFunc * eta * SimpsonW
          payoff = (fft(FFTFunc)).real
          CallValueM = np.exp(-alpha * k) / np.pi * payoff
      else:
          FFTFunc = (np.exp(1j * b * vo)
                      * (modcharFunc1 - modcharFunc2)
                      * 0.5 * eta * SimpsonW)
          payoff = (fft(FFTFunc)).real
          CallValueM = payoff / (np.sinh(alpha * k) * np.pi)
      pos = int((k + b) / eps)
      CallValue = CallValueM[pos] * S0
      # klist = np.exp((np.arange(0, N, 1) - 1) * eps - b) * S0
      return CallValue #, klist[pos - 50:pos + 50]


def plot_val_differences(vtype='int'):
    k_list = np.linspace(S0 * 0.6, S0 * 1.4, 50)
    ana_values = BSM_call_value(S0, k_list, T, r, sigma)
      plt.figure(figsize=(8, 6))
      plt.subplot(311)
      plt.plot(k_list, ana_values, 'b', label='analytical', lw=1.5)
      if vtype == 'int':
          int_values = np.array([BSM_call_value_INT(S0, K, T, r, sigma)
                                 for K in k_list])
          plt.plot(k_list, int_values, 'r-.', label='Fourier (integral)',
                   lw=1.5)
          diffs = int_values - ana_values
          rdiffs = (int_values - ana_values) / ana_values
      else:
          fft_values = np.array([BSM_call_value_FFT(S0, K, T, r, sigma)
                                 for K in k_list])
          plt.plot(k_list, fft_values, 'r-.', label='Fourier (FFT)', lw=1.5)
          diffs = fft_values - ana_values
          rdiffs = (fft_values - ana_values) / ana_values
      plt.legend()
      plt.grid()
Fourier-Based Option Pricing                                          119


     plt.subplot(312)
     plt.plot(k_list, diffs, 'g', label='abs. difference', lw=1.5)
     plt.legend(loc=0)
     plt.grid()
     plt.subplot(313)
     plt.plot(k_list, rdiffs, 'r', label='rel. difference', lw=1.5)
     plt.legend(loc=0)
     plt.xlabel('strike')
     plt.grid()
     plt.tight_layout()




6.8.2 Fourier Series

#
# Fourier Series for f(x) = abs(x) for -pi <= x <= pi
# 06_fou/Fourier_series.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import numpy as np
import matplotlib.pyplot as plt

#
# Fourier series function
#



def fourier_series(x, n):
     ''' Generate Fourier Series from vector x for f(x) = abs(x)
     of order n.


     Parameters
     ==========
     x:   float or array of floats
          input numbers
     n:   int
          order of Fourier series


     Returns
     =======
     fourier_values : float or array of floats
         numbers according to Fourier series approximation
     '''
     fourier_values = np.pi / 2
120                                             DERIVATIVES ANALYTICS WITH PYTHON


      for i in range(1, n + 1):
          fourier_values += ((2 * ((-1) ** i - 1))
                          / (np.pi * i ** 2) * np.cos(i * x))
      return fourier_values

def plot_fourier_series():
      # Data Generation
      x = np.linspace(-np.pi, np.pi, 100)
      y1 = fourier_series(x, 1)
      y2 = fourier_series(x, 5)

      # Data Plotting
      plt.figure(figsize=(10, 5))
      plt.subplot(121)
      plt.plot(x, abs(x), 'b', label='$f(x) = |x|$')
      plt.plot(x, y1, 'r-.', lw=3.0, label='Fourier series $n=1$')
      plt.grid()
      plt.legend(loc=9)
      plt.subplot(122)
      plt.plot(x, abs(x), 'b', label='$f(x) = |x|$')
      plt.plot(x, y2, 'r-.', lw=3.0, label='Fourier series $n=5$')
      plt.grid()
      plt.legend(loc=9)




6.8.3 Roots of Unity

#
# Plotting Spokes and Points on a Circle
# with Complex Numbers
# 06_fou/roots_of_unity.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import numpy as np
import matplotlib.pyplot as plt

def generate_subplot(n):
      y = np.exp(1j * 2 * np.pi / n) ** np.arange(1, n + 1)
      for l in range(n):
          plt.plot(y[l].real, y[l].imag, 'ro')
          plt.plot((0, y[l].real), (0.0, y[l].imag), 'b')
      plt.axis([-1.1, 1.1, -1.1, 1.1])
      plt.xlabel('$n=%s$' % n)
      plt.grid()
Fourier-Based Option Pricing                                                121


def generate_plot():
    plt.figure(figsize=(10, 7))
    # first sub-plot for n=5
     plt.subplot(121)
     generate_subplot(n=5)


     # second sub-plot for n=30
     plt.subplot(122)
     generate_subplot(n=30)


     plt.subplots_adjust(left=0.05, bottom=0.2, top=0.8, right=1.0)




6.8.4 Convolution

#
# Circular convolution of two 1-dim vectors
# 06_fou/convolution.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import numpy as np


#
# Function Definitions
#



def revpy(a):
    ''' Reversing the order of the vector's numbers (for loop). '''
    a = np.array(a)
     n = len(a)
     c = np.zeros(n, dtype=np.float)
     c[0] = a[0]
     for j in range(1, n):
         c[j] = a[n - j]
     return c



def revnp(a):
     ''' Reversing the order of the vector's numbers (NumPy version). '''
     b = a.copy()
     b[1:] = b[1:][::-1]
     return b
122                                              DERIVATIVES ANALYTICS WITH PYTHON


def convolution(a, b):
    ''' Convolution of two vectors. '''
    if len(a) != len(b):
          raise ValueError(''Lengths of vectors do not match.'')
      n = len(a)
      c = np.zeros(n, dtype=np.float)
      for j in range(n):
          s = 0
          for k in range(n):
              if j - k >= 0:
                  s += a[j - k] * b[k]
              else:
                  s += a[j - k + n] * b[k]
          c[j] = s
      return c



6.8.5 Module with Parameters

#
# Model Parameters for European Call Option
# in Binomial Model
# 06_fou/parameters.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
from math import exp, sqrt


# Model and Option Parameters
S0 = 100.0 # index level
K = 100.0 # option strike
T = 1.0 # maturity date
r = 0.05 # risk-less short rate
sigma = 0.2      # volatility

def get_binomial_parameters(M=100):
      # Time Parameters
      dt = T / M # length of time interval
      df = exp(-r * dt)    # discount per interval

      # Binomial Parameters
      u = exp(sigma * sqrt(dt)) # up movement
      d = 1 / u # down movement
      q = (exp(r * dt) - d) / (u - d) # martingale branch probability
      return dt, df, u, d, q
Fourier-Based Option Pricing                                            123


6.8.6 Call Value by Convolution

#
# Call Option Pricing with Circular Convolution (Simple)
# 06_fou/call_convolution.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
from convolution import revnp, convolution

# Parameter Definitions
M = 4 # number of time steps
dt = 1.0 / M # length of time interval
r = 0.05 # constant short rate
C = [49.18246976, 22.14027582, 0, 0, 0] # call payoff at maturity
q = 0.537808372 # martingale probability
qv = np.array([q, 1 - q, 0, 0, 0]) # probabilitiy vector filled with zeros


# Calculation
V = np.zeros((M + 1, M + 1), dtype=np.float)
V[M] = C


for t in range(M - 1, -1, -1):
    V[t] = convolution(V[t + 1], revnp(qv)) * math.exp(-r * dt)


print "Value of the Call Option %8.3f" % V[0, 0]




6.8.7 Option Pricing by Convolution

#
# Call Option Pricing with Circular Convolution (General)
# 06_fou/call_convolution_general.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import numpy as np
from convolution import revnp, convolution
from parameters import *
124                                            DERIVATIVES ANALYTICS WITH PYTHON


# Parameter Adjustments
M = 3 # number of time steps
dt, df, u, d, q = get_binomial_parameters(M)


# Array Generation for Stock Prices
mu = np.arange(M + 1)
mu = np.resize(mu, (M + 1, M + 1))
md = np.transpose(mu)
mu = u ** (mu - md)
md = d ** md
S = S0 * mu * md


# Valuation
V = np.maximum(S - K, 0)
qv = np.zeros((M + 1), dtype=np.float)
qv[0] = q
qv[1] = 1 - q
for t in range(M - 1, -1, -1):
    V[:, t] = convolution(V[:, t + 1], revnp(qv)) * df


print "Value of the Call Option %8.3f" % V[0, 0]




6.8.8 Option Pricing by DFT

#
# Call Option Pricing with Discrete Fourier Transforms (DFT/FFT)
# 06_fou/call_fft_pricing.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
from numpy.fft import fft, ifft
from convolution import revnp
from parameters import *

# Parameter Adjustments
M = 3 # number of time steps
dt, df, u, d, q = get_binomial_parameters(M)


# Array Generation for Stock Prices
mu = np.arange(M + 1)
mu = np.resize(mu, (M + 1, M + 1))
md = np.transpose(mu)
Fourier-Based Option Pricing                                             125


mu = u ** (mu - md)
md = d ** md
S = S0 * mu * md


# Valuation by fft
CT = np.maximum(S[:, -1] - K, 0)
qv = np.zeros(M + 1, dtype=np.float)
qv[0] = q
qv[1] = 1 - q
C0_a = fft(math.exp(-r * T) * ifft(CT) * ((M + 1) * ifft(revnp(qv))) ** M)
C0_b = fft(math.exp(-r * T) * ifft(CT) * fft(qv) ** M)
C0_c = ifft(math.exp(-r * T) * fft(CT) * fft(revnp(qv)) ** M)


# Results Output
print "Value of European option is %8.3f" % np.real(C0_a[0])
print "Value of European option is %8.3f" % np.real(C0_b[0])
print "Value of European option is %8.3f" % np.real(C0_c[0])




6.8.9 Speed Test of DFT

#
# Call Option Pricing with DFT/FFT Speed Test
# 06_fou/call_fft_speed.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
from numpy.fft import fft, ifft
from convolution import revnp
from parameters import *

def call_fft_value(M):
     # Parameter Adjustments
     dt, df, u, d, q = get_binomial_parameters(M)


     # Array Generation for Stock Prices
     mu = np.arange(M + 1)
     mu = np.resize(mu, (M + 1, M + 1))
     md = np.transpose(mu)
     mu = u ** (mu - md)
     md = d ** md
     S = S0 * mu * md
126                                             DERIVATIVES ANALYTICS WITH PYTHON


      # Valuation by FFT
      CT = np.maximum(S[:, -1] - K, 0)
      qv = np.zeros(M + 1, dtype=np.float)
      qv[0] = q
      qv[1] = 1 - q
      C0 = fft(math.exp(-r * T) * ifft(CT) * fft(qv) ** M)
                                                                                CHAPTER         7
                               Valuation of American Options
                                               by Simulation


7.1 INTRODUCTION

Monte Carlo simulation (MCS) is a flexible and powerful numerical method to value financial
derivatives of any kind (cf. Glasserman (2004)). As a forward evolving technique, it is per se not
suited to address the valuation of American or Bermudan options which are valued in general
by backwards induction (cf. Kohler (2009)). However, Longstaff and Schwartz (2001) provide
a numerically efficient method to solve this problem by what they call Least-Squares Monte
Carlo (LSM).1 Their approach approximates continuation values for American options in
backwards steps by an ordinary least-squares regression. Equipped with such approximations,
the option is exercised if the approximate continuation value is lower than the value of
immediate exercise. Otherwise it is not exercised. The LSM leads to a lower bound for the
option‚Äôs value since the exercise decision is in any case sub-optimal (cf. Longstaff and Schwartz
(2001)).
     Haugh and Kogan (2004), among others, propose a dual formulation of the valuation
problem for an American option which finally leads to a MCS estimator that represents an
upper bound to the option‚Äôs value. In some situations, it is very helpful to have an upper bound
in addition to a lower bound since the LSM does not allow to assess ‚Äúhow much too low the
value estimate is.‚Äù Then, in the absence of alternative benchmarks, the accuracy of the LSM
estimator cannot be judged.
     This chapter proceeds as follows. Section 7.2 describes a financial model in the spirit
of the Black-Scholes-Merton (BSM) economy. Section 7.3 introduces the primal and dual
valuation problems for an American option and the respective MCS valuation algorithms.
Section 7.4 presents valuation results for two different types of American options from a
Python implementation of the MCS algorithms. Section 7.5 concludes.




1
 Cf. Tsitsiklis and Van Roy (2001) for a similar algorithm published at about the same time. Cf. Kohler
(2009) for comparisons.


                                                                                                  127
128                                                                   DERIVATIVES ANALYTICS WITH PYTHON


7.2 FINANCIAL MODEL

We consider the continuous market model of Black-Scholes-Merton
                                  ÓàπBSM = {(Œ©, Óà≤ , F, P), T, (S, B)}
with final date T, 0 < T < ‚àû. Uncertainty in the economy is represented by a filtered proba-
bility space {Œ©, Óà≤ , F, P}. Œ© denotes the continuous state space, Óà≤ an ùúé-algebra, F a filtration
and P the real or objective probability measure.
     Against this background, we model for 0 ‚â§ t ‚â§ T the risk-neutral evolution of the relevant
stock index S according to the stochastic differential equation (SDE)
                                             dSt
                                                 = rdt + ùúédZt                                        (7.1)
                                              St
St denotes the index level at date t, r the constant risk-less short rate, ùúé the constant volatility
of the index and Zt a standard Brownian motion. The stochastic process generates the filtration
F, i.e. Óà≤t ‚â° Óà≤ (S0‚â§s‚â§t ). The differential equation a risk-less zero-coupon bond B satisfies is
                                                dBt
                                                    = rdt                                            (7.2)
                                                 Bt
The time t value of a zero-coupon bond paying one unit of currency at T with 0 ‚â§ t < T is
Bt (T) = e‚àír(T‚àít) .
     To simulate the financial model, i.e. to generate numerical values for St , the SDE (7.1) has
to be discretized. To this end, divide the given time interval [0, T] in equidistant sub-intervals
Œît such that now t ‚àà {0, Œît, 2Œît, ‚Ä¶ , T}, i.e. there are M + 1 points in time with M ‚â° T‚àïŒît.
A discrete version of the continuous time market model (7.1)‚Äì(7.2) is
                                                 (           )       ‚àö
                                                         2
                                        St           r‚àí ùúé2       Œît+ùúé Œîtzt
                                              =e                                                     (7.3)
                                      St‚àíŒît
                                       Bt
                                            = erŒît                                                   (7.4)
                                      Bt‚àíŒît

for t ‚àà {Œît, ‚Ä¶ , T} and standard normally distributed zt . This scheme is a Euler discretization
based on the log-dynamics of St which is known to be exact for the geometric Brownian
motion (7.1) (cf. Glasserman (2004), pp. 93‚Äì94).


7.3 AMERICAN OPTION VALUATION

7.3.1 Problem Formulations
By the Fundamental Theorem of Asset Pricing, the time t value of an attainable2 and Óà≤T -
measurable contingent claim VT ‚â° hT (ST ) ‚â• 0 (satisfying suitable integrability conditions) is
given by arbitrage as
                                             (         )
                                  Vt = EQ  t Bt (T)VT


2
 Recall that a contingent claim is attainable if it can be replicated via an admissible trading strategy in
the index and a zero-coupon bond. A trading strategy is admissible if it is predictable and self-financing
and if its value is at all times finite and bounded from below. See Chapter 4.
Valuation of American Options by Simulation                                                       129

              (          )
with V0 = EQ0
                B0 (T)VT as the important special case for valuation purposes. E denotes the
expectation operator and Q the unique risk-neutral probability measure equivalent to the real
world measure P.3 Et (‚ãÖ) is short for the conditional expectation E(‚ãÖ|Óà≤t ).
    The contingent claim could be a European call option maturing at T with payoff hT (ST ) ‚â°
max[ST ‚àí K, 0]. It could also be a European put with payoff hT (ST ) ‚â° max[K ‚àí ST , 0]. In both
cases, K > 0 is the fixed strike price of the option.

Primal Formulation The valuation of contingent claims with American exercise is more
involved. In its primal form, this problem can be formulated as an optimal stopping problem
(cf. Kohler (2009), p. 2)

                                   V0 = sup EQ
                                             0
                                               (B0 (ùúè)hùúè (Sùúè ))                                  (7.5)
                                         ùúè‚àà[0,T]


with V0 being the present value of the American derivative, ùúè an F-adapted stopping time,
T the date of maturity, B0 (ùúè) the discount factor appropriate for stopping time ùúè, hùúè a non-
negative, Óà≤ùúè -measurable payoff function and Sùúè the index level process stopped at t = ùúè. The
expectation is again taken under the risk-neutral measure Q. To value American options by
MCS, the optimal stopping problem (7.5) also has to be discretized:

                              V0 =         sup          EQ
                                                         0
                                                           (B0 (ùúè)hùúè (Sùúè ))                      (7.6)
                                     ùúè‚àà{0,Œît,2Œît,‚Ä¶,T}


     The continuation value Ct at date t of the option, i.e. the value of not exercising the option
at this date, is given under risk-neutrality as

                              Ct (s) = EQ
                                        t (e
                                            ‚àírŒît
                                                 Vt+Œît (St+Œît )|St = s)

using the Markov property of St . Applying another important result in this context (cf. Kohler
(2009), pp. 4‚Äì6), the value of the option at date t is then

                                     Vt (s) = max[ht (s), Ct (s)]                                (7.7)

i.e. the maximum of the payoff ht (s) of immediate exercise and the expected payoff Ct (s) of
not exercising.
      The Python script in sub-section 7.6.1 implements this primal valuation problem in the
context of the Cox-Ross-Rubinstein binomial model presented in Chapter 5. The adjustments
to American exercise are quite simple in this context. The script values two different American
options that are further analyzed in section 7.4.

Dual Formulation Let M be the set of all Q-martingales ÓàΩt , t ‚àà {0, ‚Ä¶ , T}, satisfying ÓàΩ0 =
0. For any such martingale and a stopping time ùúè ‚àà {Œît, ‚Ä¶ , T} it holds (cf. Glasserman

3
 The defining characteristic of Q is that it makes the discounted index level process a martingale. Cf.
BjoÃàrk (2004), Theorems 8.3 and 10.17, for completeness of the BSM model (7.1)‚Äì(7.2) and uniqueness
of the risk-neutral measure Q, respectively.
130                                                                     DERIVATIVES ANALYTICS WITH PYTHON


(2004), p. 471)

                     EQ
                      0
                        (B0 (ùúè)hùúè (Sùúè )) = EQ
                                            0
                                              (B0 (ùúè)(hùúè (Sùúè ) ‚àí ÓàΩùúè ))
                                              (                                    )
                                         ‚â§ EQ
                                            0
                                                    max     B 0 (t)[h (S
                                                                     t t ) ‚àí ÓàΩ t ]                            (7.8)
                                                         t‚àà{Œît,‚Ä¶,T}


The first equality follows by the optional sampling property of martingales (cf. Bhattacharya
and Waymire (2007), Theorem 3.6). Since (7.8) holds for any martingale ÓàΩ it also holds for
the infimum taken over all ÓàΩ ‚àà M
                                                          (                                         )
                   EQ
                    0
                      (B0 (ùúè)hùúè (Sùúè )) ‚â§ inf EQ                   max      B0 (t)[ht (St ) ‚àí ÓàΩt ]             (7.9)
                                        ÓàΩ‚ààM
                                              0               t‚àà{Œît,‚Ä¶,T}


Finally, since (7.9) holds for any ùúè, it also holds for the supremum taken over all ùúè such that

                              V0 =       sup          EQ
                                                       0
                                                         (B0 (ùúè)hùúè (Sùúè ))
                                     ùúè‚àà{0,Œît,‚Ä¶,T}
                                                  (                                        )
                                ‚â§ inf     EQ
                                           0
                                                       max        B0 (t)[ht (St ) ‚àí ÓàΩt ]                     (7.10)
                                 ÓàΩ‚ààM                t‚àà{Œît,‚Ä¶,T}


     It can be proven that the last inequality holds with equality (cf. Kohler (2009), pp. 16‚Äì
18). Therefore, the discrete dual problem of valuing an American option given the primal
formulation (7.6) is
                                                  (                                    )
                              V0 = inf    EQmax B0 (t)[ht (St ) ‚àí ÓàΩt ]
                                   ÓàΩ‚ààQ
                                           0
                                          t‚àà{0,‚Ä¶,T}
                                      (                              )
                                 = EQ
                                    0
                                        max    B0 (t)[h (S
                                                       t t ) ‚àí ÓàΩ ‚àó
                                                                 t ]                                         (7.11)
                                           t‚àà{0,‚Ä¶,T}


with ÓàΩ‚àó the martingale defined by (cf. Kohler (2009), p. 16)
                          (                                       (                                     ))
                   ‚àë
                   t                                                                      |
                                                                                          |
           ÓàΩ‚àót =          max[hu (Su ), Cu (Su )] ‚àí E         Q
                                                                   max[hu (Su ), Cu (Su )]|Óà≤u‚àíŒît
                                                                                          |
                   u=Œît                                                                   |
                        (                     (                    ))
                   ‚àë t                                    |
                                                          |
               =          Vu (Su ) ‚àí E    Q
                                                  Vu (Su )|Óà≤u‚àíŒît                                             (7.12)
                                                          |
                   u=Œît                                   |


7.3.2 Valuation Algorithms
This sub-section translates the basic theory into implementable algorithms.

LSM Algorithm The decision to exercise an American option or not is dependent on the
continuation value. Consider a simulation with M + 1 points in time and I paths. Given a
simulated index level St,i , t ‚àà {0, ‚Ä¶ , T}, i ‚àà {1, ‚Ä¶ , I}, what is the continuation value Ct,i (St,i ),
i.e. the expected payoff of not exercising the option? Of course, by simulation you know
the simulated continuation value Yt,i ‚â° e‚àírŒît Vt+Œît,i . However, using these quantities directly
Valuation of American Options by Simulation                                                        131


would translate into perfect foresight‚Äîsomething not seen in financial markets and therefore
not acceptable for a valuation algorithm. In other words, using these quantities would lead to a
better-than-optimal exercise policy and therewith to a consistently high biased estimator. On
the other hand, estimating the continuation value through a nested MCS, for example, would
lead to generally unacceptable computational times.4
       The major insight of Longstaff-Schwartz is to estimate the continuation values Ct,i by
ordinary least-squares regression‚Äîhence the name Least-Squares Monte Carlo for their algo-
rithm. They propose to regress the I continuation values Yt,i against the I simulated index levels
St,i . Given D basis functions b with b1 , ‚Ä¶ , bD : RD ‚Üí R for the regression, the continuation
value Ct,i is according to their approach approximated by

                                                  ‚àë
                                                  D
                                       CÃÇ t,i =         ùõºd,t
                                                         ‚àó
                                                             ‚ãÖ bd (St,i )                        (7.13)
                                                  d=1

The optimal regression parameters ùõºd,t
                                   ‚àó are the result of the minimization


                                               (                             )2
                                         1‚àë            ‚àë
                                            I           D
                               min              Yt,i ‚àí     ùõºd,t ‚ãÖ bd (St,i )                     (7.14)
                            ùõº1,t ,‚Ä¶,ùõºD,t I
                                           i=1         d=1

In some circumstances, the quality of the regression can be improved upon when restricting
the paths involved in the regression to those where the option is in-the-money. To apply the
LSM, implement Algorithm 1.
     Note that when updating option values Vt,i , the real continuation value Yt,i is to be taken
and not the estimated one CÃÇ t,i .
     Sub-section 7.6.2 presents a Python script implementing the LSM primal algorithm. It
uses the parametrization for the first option of table one in the seminal paper of Longstaff and
Schwartz (2001) (see also the next section).
     It is well-known that the LSM estimator (7.15)‚Äîfor large enough I‚Äîprovides a lower
bound for the option‚Äôs value. However, small I may lead to an in-sample bias of the regressions
in the sense that the resulting exercise policy is better-than-optimal.5 To avoid such a bias, the
algorithm may be divided into two parts. To this end, one would simulate I = I1 + I2 paths and
use the first I1 paths for the derivation of the ùõºd,t
                                                  ‚àó and the remaining I paths for the valuation
                                                                         2
of the American option given the ùõºd,t .
                                      ‚àó


Dual Algorithm The algorithm to implement the dual approach to American option valuation
(7.11) and (7.12) uses the optimal regression parameters ùõºd,t ‚àó from the LSM algorithm. The

dual algorithm is forward evolving and shown as Algorithm 2.
     Note that when updating the Vt,i , the regression-based estimate for the continuation value
is taken (in contrast to the LSM algorithm). Also note that for t = T the CÃÇ T,i,j are zero by
definition as well as formally due to the ùõºd,T
                                             ‚àó being zero.



4
  Suppose the continuation value is also estimated with I paths through a nested MCS. Then the number
of simulated index level values increases from (M + 1) ‚ãÖ I to (M + 1) ‚ãÖ I 2 .
5
  For I = 1 we again have the situation with perfect foresight. However, for small I > 1 the problem may
nevertheless arise. Cf. Fries (2008).
    132                                                                DERIVATIVES ANALYTICS WITH PYTHON



    Algorithm 1: Primal Algorithm
1 Divide the time interval [0, T] into equidistant sub-intervals of length Œît
  for t = 0, Œît, ‚Ä¶ , T do
      for i = 1, ‚Ä¶ , I do
          if t = 0 then
2              Set St,i = S0
              else
3                 Draw a standard normally distributed pseudo-random number zt,i
4                 Simulate the index level value St,i given St‚àíŒît,i and zt,i

  for t = T, T ‚àí Œît, ‚Ä¶ , Œît, 0 do
      if t = T then
5          Set VT,i = hT (ST,i )
          if T > t > 0 then
6             Regress the Yt,i against the St,i , i ‚àà {1, ‚Ä¶ , I}, given D basis functions b
7             Approximate Ct,i by CÃÇ t,i according to (7.13) given the optimal parameters ùõºd,t
                                                                                            ‚àó from

              (7.14)
8             According to (7.7) set

                                                     {
                                                         ht (St,i )   if ht (St,i ) > CÃÇ t,i
                                            Vt,i =
                                                         Yt,i         if ht (St,i ) ‚â§ CÃÇ t,i

          if t = 0 then
9              With V0,i ‚â° e‚àírŒît VŒît,i , calculate the LSM estimator as

                                                        ‚àëI
                                             ÃÇV LSM = 1    V                                      (7.15)
                                               0      I i=1 0,i




    7.4 NUMERICAL RESULTS

    7.4.1 American Put Option
    The first example is a simple American put option. It is the first non-trivial example in the
    seminal paper by Longstaff-Schwartz (2001) where the following assumptions are made:

       S0 = 36
       T = 1.0
       r = 0.06
       ùúé = 0.2

       h (s) = max[40 ‚àí s, 0]
         t
     Valuation of American Options by Simulation                                                             133


     Algorithm 2: Dual Algorithm
 1 Divide the time interval [0, T] into equidistant sub-intervals of length Œît
   for t = 0, Œît, ‚Ä¶ , T do
       for i = 1, ‚Ä¶ , I do
           if t = 0 then
 2              Set St,i = S0
             else
 3               Draw a standard normally distributed pseudo-random number zt,i
 4               Simulate the index level value St,i given St‚àíŒît,i and zt,i

   for t = 0, Œît, ‚Ä¶ , T do
       for i = 1, ‚Ä¶ , I do
           if t = 0 then
 5              initialize ÓàΩ0,i = 0 and U0,i = 0
             if 0 < t < T then
 6               Simulate J successors St,i,j , j ‚àà {1, ‚Ä¶ , J}, for each St‚àíŒît,i by a nested MCS
 7               According to (7.7) set Vt,i = max[ht (St,i ), CÃÇ t,i (St,i )] given the ùõºd,t     ‚àó from LSM and

                 approximation (7.13)
 8               Determine for all i, j the VÃÇ t,i,j = max[ht (St,i,j ), CÃÇ t,i,j (St,i,j )] with the ùõºd,t
                                                                                                       ‚àó and
                                                                           ‚àë
                 equation (7.13) to approximate Vt,i by VÃÇ t,i = 1J Jj=1 VÃÇ t,i,j
 9               Set ÓàΩt,i = erŒît ÓàΩt‚àíŒît,i + (Vt,i ‚àí VÃÇ t,i )
10               Update Ut,i = max[erŒît Ut‚àíŒît,i , ht (St,i ) ‚àí ÓàΩt,i ]
             if t = T then
11                Update UT,i = max[erŒît UT‚àíŒît,i , hÃÇ T (ST,i ) ‚àí ÓàΩT,i ] where


                                                            1‚àë
                                                               J
                                             hÃÇ T (ST,i ) =      h (S )
                                                            J j=1 T T,i,j

12               Calculate the dual MCS estimator as

                                                            1‚àë
                                                               I
                                            VÃÇ 0DUAL = e‚àírT      U                                        (7.16)
                                                            I i=1 T,i




          The true (theoretical) value of this option is 4.486 given a binomial valuation model with
     500 time steps.
          The Python script in sub-section 7.6.3 implements the LSM algorithm with some addi-
     tional features as well as the dual algorithm. As variance reduction techniques the imple-
     mentation uses antithetic paths (cf. Glasserman (2004), sec. 4.2) and moment matching (cf.
     Glasserman (2004), sec. 4.5.). It is also possible to derive the optimal regression coefficients
134                                                           DERIVATIVES ANALYTICS WITH PYTHON


TABLE 7.1     Valuation results from the LSM and DUAL algorithms for the American put optiona
from 25 different simulation runs with base case parametrization.

Algorithm                Value                     M = 25                M = 50                 M = 75

LSM                      Maximum                    4.526                 4.529                  4.544
                         Mean                       4.452                 4.470                  4.467
                         Difference                ‚àí0.034                ‚àí0.016                 ‚àí0.019
                         Median                     4.459                 4.471                  4.475
                         Minimum                    4.342                 4.370                  4.391
DUAL                     Maximum                     5.018                 4.697                  4.753
                         Mean                        4.651                 4.595                  4.598
                         Difference                  0.165                 0.109                  0.111
                         Median                      4.632                 4.585                  4.574
                         Minimum                     4.610                 4.570                  4.552
Spread                   Absolute                    0.199                 0.125                  0.131
a
  The true value of the American put option from a binomial model with 500 time steps is 4.486. Reported
differences are absolute deviations of the mean values from the correct option value.


on the basis of in-the-money paths only. As regression functions, the implementation uses
simple monomials, the number of which can be chosen freely.
    We use the following simulation parameters as our base case to illustrate the valuation of
the American put option:




 FIGURE 7.1 Valuation results for the American put option from 25 simulation runs with M = 75
 time intervals; AV = average of primal (LSM) and dual (DUAL) values; dashed line = true value
Valuation of American Options by Simulation                                                  135


     M = 25
     I1 = 4 ‚ãÖ 4096, I2 = 1096
     J = 50

     D = 9
     moment matching but no antithetic paths
     all paths are used for the regressions



    Experience from a number of numerical experiments suggests that the value estimates
do not become much more accurate when the path numbers I1 , I2 or J are increased. The use
of antithetic paths also does not contribute to accuracy. However, increasing the number of
time steps M has a positive effect on the spread between the LSM and DUAL mean value as
Table 7.1 illustrates. Figure 7.1 shows the main results for M = 75 as boxplots.


7.4.2 American Short Condor Spread
The second example is a so-called Short Condor Spread which is mainly a combination of
long and short positions in vanilla options. This type of payoff is analyzed, for example, in
Kohler (2009), sec. 8. The model assumptions now are:

     S0 = 100
     T = 1.0
     r = 0.05
     ùúé = 0.5
     h (s) = min[40, max(90 ‚àí s, 0) + max(s ‚àí 110, 0)]
       t


     This payoff is non-convex and therefore difficult to approximate via parametric regression
with simple monomials. Therefore convergence of the LSM is generally weak and the avail-
ability of a high estimator quite useful. Table 7.2 reports results from different simulations for


TABLE 7.2 Valuation results from the LSM and DUAL algorithms for the Short Condor Spreada
from 25 different simulation runs with base case parametrization.

Algorithm                Value                  M = 25               M = 50               M = 75

LSM                      Maximum                26.683               26.710               27.063
                         Mean                   25.977               26.027               26.308
                         Difference             ‚àí1.000               ‚àí0.950               ‚àí0.669
                         Median                 25.946               25.989               26.294
                         Minimum                25.181               25.564               25.521
DUAL                     Maximum                33.462                45.401               32.416
                         Mean                   27.885                28.177               27.749
                         Difference              0.908                 1.200                0.772
                         Median                 27.493                27.479               27.569
                         Minimum                27.221                27.230               27.282
Spread                   Absolute                 1.908                2.149                1.441
a
 The true value of the American put option from a binomial model with 500 time steps is 26.97705.
Reported differences are absolute deviations of the mean values from the correct option value.
136                                                      DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 7.2 Valuation results for the American Short Condor Spread from 25 simulation runs with
M = 75 time intervals; AV = average of primal (LSM) and dual (DUAL) values; dashed line = true
value



this type of American derivative. Here, the increase of M has only a marginal effect on the
spread between the LSM and DUAL mean value. However, the LSM estimate improves with
increasing M. Figure 7.2 shows the valuation results graphically for the case M = 75.



7.5 CONCLUSIONS

The numerically efficient valuation of American options by MCS was almost impossible
until Longstaff-Schwartz published their LSM algorithm in 2001. Although there have been
different approaches available at about the same time (cf. Kohler (2009) or Glasserman (2004),
ch. 8) we focus on the LSM because of its simplicity and popularity in practice. The LSM
estimator for an option‚Äôs value is known to be low biased with almost no means of judging
how much too low it is in a practical situation.
     We therefore also discuss a dual approach to American options pricing by MCS which
leads to a high biased estimator. Taken together, the two approaches provide an interval
in which the true option value lies. This is illustrated in this chapter by two examples: a
typical American put option and a Short Condor Spread with non-convex payoff. The self-
contained Python scripts accompanying this chapter allow experimentation with different
parametrizations and the numerical analysis of the performance of the algorithms.
Valuation of American Options by Simulation            137


7.6 PYTHON SCRIPTS

7.6.1 Binomial Valuation

#
# Valuation of American Options
# with the Cox-Ross-Rubinstein Model
# Primal Algorithm
# Case 1: American Put Option (APO)
# Case 2: Short Condor Spread (SCS)
# 07_amo/CRR_american_options.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np

# General Parameters and Option Values
def set_parameters(otype, M):
    ''' Sets parameters depending on valuation case.

     Parameters
     ==========
     otype: int
         option type
           1 = American put option
           2 = Short Condor Spread
     '''
     if otype == 1:
         # Parameters -- American Put Option
           S0 = 36. # initial stock level
           T = 1.0 # time-to-maturity
           r = 0.06 # short rate
           sigma = 0.2     # volatility

     elif otype == 2:
         # Parameters -- Short Condor Spread
           S0 = 100. # initial stock level
           T = 1.0 # time-to-maturity
           r = 0.05 # short rate
           sigma = 0.5     # volatility

     else:
         raise ValueError('Option type not known.')

     # Numerical Parameters
138                                                DERIVATIVES ANALYTICS WITH PYTHON


      dt = T / M # time interval
      df = math.exp(-r * dt) # discount factor
      u = math.exp(sigma * math.sqrt(dt)) # up-movement
      d = 1 / u # down-movement
      q = (math.exp(r * dt) - d) / (u - d)    # martingale probability


      return S0, T, r, sigma, M, dt, df, u, d, q



def inner_value(S, otype):
    ''' Inner value functions for American put option and short condor spread
    option with American exercise.


      Parameters
      ==========
      otype: int
          option type
            1 = American put option
            2 = Short Condor Spread
      '''
      if otype == 1:
          return np.maximum(40. - S, 0)
      elif otype == 2:
          return np.minimum(40., np.maximum(90. - S, 0)
                               + np.maximum(S - 110., 0))
      else:
            raise ValueError('Option type not known.')



def CRR_option_valuation(otype, M=500):
    S0, T, r, sigma, M, dt, df, u, d, q = set_parameters(otype, M)
      # Array Generation for Stock Prices
      mu = np.arange(M + 1)
      mu = np.resize(mu, (M + 1, M + 1))
      md = np.transpose(mu)
      mu = u ** (mu - md)
      md = d ** md
      S = S0 * mu * md

      # Valuation by Backwards Induction
      h = inner_value(S, otype) # innver value matrix
      V = inner_value(S, otype) # value matrix
      C = np.zeros((M + 1, M + 1), dtype=np.float) # continuation values
      ex = np.zeros((M + 1, M + 1), dtype=np.float)      # exercise matrix

      z = 0
      for i in range(M - 1, -1, -1):
Valuation of American Options by Simulation                                139


          C[0:M - z, i] = (q * V[0:M - z, i + 1]
                      + (1 - q) * V[1:M - z + 1, i + 1]) * df
          V[0:M - z, i] = np.where(h[0:M - z, i] > C[0:M - z, i],
                          h[0:M - z, i], C[0:M - z, i])
          ex[0:M - z, i] = np.where(h[0:M - z, i] > C[0:M - z, i], 1, 0)
          z += 1
     return V[0, 0]



7.6.2 Monte Carlo Valuation with LSM

#
# Valuation of American Options
# with Least-Squares Monte Carlo
# Primal Algorithm
# American Put Option
# 07_amo/LSM_primal_valuation.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
np.random.seed(150000)

# Model Parameters
S0 = 36. # initial stock level
K = 40. # strike price
T = 1.0 # time-to-maturity
r = 0.06 # short rate
sigma = 0.2 # volatility

# Simulation Parameters
I = 25000
M = 50
dt = T / M
df = math.exp(-r * dt)

# Stock Price Paths
S = S0 * np.exp(np.cumsum((r - 0.5 * sigma ** 2) * dt
    + sigma * math.sqrt(dt) * np.random.standard_normal((M + 1, I)), axis=0))
S[0] = S0

# Inner Values
h = np.maximum(K - S, 0)

# Present Value Vector (Initialization)
V = h[-1]
140                                                  DERIVATIVES ANALYTICS WITH PYTHON


# American Option Valuation by Backwards Induction
for t in xrange(M - 1, 0, -1):
    rg = np.polyfit(S[t], V * df, 5)
      C = np.polyval(rg, S[t]) # continuation values
      V = np.where(h[t] > C, h[t], V * df)
        # exercise decision
V0 = df * np.sum(V) / I       # LSM estimator

print "American put option value %5.3f" % V0



7.6.3 Primal and Dual LSM Algorithms

#
# Valuation of American Options
# with Least-Squares Monte Carlo
# Primal and Dual Algorithm
# Case 1: American Put Option (APO)
# Case 2: Short Condor Spread (SCS)
# 07_amo/LSM_primal_dual_valuation.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
import pandas as pd
from time import time
from datetime import datetime
import itertools as it
import warnings
warnings.simplefilter('ignore')


t0 = time()
np.random.seed(150000)    # seed for Python RNG


## Simulation Parameters
runs = 5
write = True
otype = [1, 2]    # option type
M = [10, 20]   # time steps
I1 = np.array([4, 6]) * 4096      # replications for regression
I2 = np.array([1, 2]) * 1024      # replications for valuation
J = [50, 75]   # replications for nested MCS
reg = [5, 9]   # no of basis functions
AP = [False, True]    # antithetic paths
MM = [False, True]    # moment matching of RN
ITM = [True, False]     # ITM paths for regression
Valuation of American Options by Simulation                                    141


results = pd.DataFrame()


#
# Function Definitions
#



def generate_random_numbers(I):
    ''' Function to generate I pseudo-random numbers. '''
    if AP:
               ran = np.random.standard_normal(I / 2)
               ran = np.concatenate((ran, -ran))
    else:
               ran = np.random.standard_normal(I)
    if MM:
         ran = ran - np.mean(ran)
         ran = ran / np.std(ran)
    return ran



def generate_paths(I):
    ''' Function to generate I stock price paths. '''
    S = np.zeros((M + 1, I), dtype=np.float)          # stock matrix
    S[0] = S0      # initial values
    for t in range(1, M + 1, 1):          # stock price paths
         ran = generate_random_numbers(I)
         S[t] = S[t - 1] * np.exp((r - sigma ** 2 / 2) * dt
                                       + sigma * ran * math.sqrt(dt))
    return S



def inner_values(S):
    ''' Innver value functions for American put and Short Condor Spread. '''
    if otype == 1:
         return np.maximum(40. - S, 0)
    else:
         return np.minimum(40., np.maximum(90. - S, 0)
                                   + np.maximum(S - 110., 0))



def nested_monte_carlo(St, J):
    ''' Function for nested Monte Carlo simulation.


    Parameters
    ==========
    St: float
         start value for S
    J:   int
         number of paths to simulate
142                                                    DERIVATIVES ANALYTICS WITH PYTHON


      Returns
      =======
      paths : array
            simulated nested paths
      '''
      ran = generate_random_numbers(J)
      paths = St * np.exp((r - sigma ** 2 / 2) * dt
                             + sigma * ran * math.sqrt(dt))
      return paths


#
# Valuation
#
para = it.product(otype, M, I1, I2, J, reg, AP, MM, ITM)
count = 0
for pa in para:
      otype, M, I1, I2, J, reg, AP, MM, ITM = pa
      ## General Parameters and Option Values
      if otype == 1:
            ## Parameters -- American Put Option
            S0 = 36.    # initial stock level
            T = 1.0    # time-to-maturity
            r = 0.06    # short rate
            sigma = 0.2     # volatility
            V0_true = 4.48637    # American Put Option (500 steps bin. model)
      else:
            ## Parameters -- Short Condor Spread
            S0 = 100.     # initial stock level
            T = 1.0    # time-to-maturity
            r = 0.05    # short rate
            sigma = 0.5     # volatility
            V0_true = 26.97705    # Short Condor Spread (500 steps bin. model)
      dt = T / M      # length of time interval
      df = math.exp(-r * dt)      # discount factor per time interval
      for j in range(runs):
            count += 1
            # regression estimation
            S = generate_paths(I1)     # generate stock price paths
            h = inner_values(S)    # inner values
            V = inner_values(S)    # value matrix
            rg = np.zeros((M + 1, reg + 1), dtype=np.float)
                # regression parameter matrix


            itm = np.greater(h, 0)     # ITM paths
            for t in xrange(M - 1, 0, -1):
                if ITM:
                      S_itm = np.compress(itm[t] == 1, S[t])
                      V_itm = np.compress(itm[t] == 1, V[t + 1])
                      if len(V_itm) == 0:
Valuation of American Options by Simulation                                          143


                        rg[t] = 0.0
                   else:
                        rg[t] = np.polyfit(S_itm, V_itm * df, reg)
              else:
                   rg[t] = np.polyfit(S[t], V[t + 1] * df, reg)
                      # regression at time t
              C = np.polyval(rg[t], S[t])        # continuation values
              V[t] = np.where(h[t] > C, h[t], V[t + 1] * df)
                 # exercise decision


         ## Simulation
         Q = np.zeros((M + 1, I2), dtype=np.float)          # martingale matrix
         U = np.zeros((M + 1, I2), dtype=np.float)          # upper bound matrix
         S = generate_paths(I2)         # generate stock price paths
         h = inner_values(S)        # inner values
         V = inner_values(S)        # value matrix


         ## Primal Valuation
         for t in xrange(M - 1, 0, -1):
              C = np.polyval(rg[t], S[t])        # continuation values
              V[t] = np.where(h[t] > C, h[t], V[t + 1] * df)
                 # exercise decision
         V0 = df * np.sum(V[1]) / I2          # LSM estimator


         ## Dual Valuation
         for t in xrange(1, M + 1):
              for i in xrange(I2):
                   Vt = max(h[t, i], np.polyval(rg[t], S[t, i]))
                   # estimated value V(t,i)
                   St = nested_monte_carlo(S[t - 1, i], J)       # nested MCS
                   Ct = np.polyval(rg[t], St)        # cv from nested MCS
                   ht = inner_values(St)        # iv from nested MCS
                   VtJ = np.sum(np.where(ht > Ct, ht, Ct)) / len(St)
                      # average of V(t,i,j)
                   Q[t, i] = Q[t - 1, i] / df + (Vt - VtJ)       # "optimal" martingale
                   U[t, i] = max(U[t - 1, i] / df, h[t, i] - Q[t, i])
                      # high estimator values
                   if t == M:
                        U[t, i] = np.maximum(U[t - 1, i] / df,
                                                 np.mean(ht) - Q[t, i])
         U0 = np.sum(U[M]) / I2 * df ** M         # DUAL estimator
         AV = (V0 + U0) / 2        # average of LSM and DUAL estimator


         # output
         print "%4d | %4.1f | %48s " % (count, (time() - t0) / 60, pa), \
                   "| %6.3f | %6.3f | %6.3f" % (V0, U0, AV)
         # results storage
         results = results.append(pd.DataFrame({'otype': otype, 'runs': runs,
              'M': M, 'I1': I1, 'I2': I2, 'J': J, 'reg': reg, 'AP': AP,
144                                               DERIVATIVES ANALYTICS WITH PYTHON


              'MM': MM, 'ITM': ITM, 'LSM': V0, 'LSM_se': (V0 - V0_true) ** 2,
              'DUAL': U0, 'DUAL_se': (U0 - V0_true) ** 2, 'AV': AV,
              'AV_se': (AV - V0_true) ** 2}, index=[0,]), ignore_index=True)


t1 = time()
print "Total time in min %s" % ((t1 - t0) / 60)


if write:
      h5 = pd.HDFStore('results_%s_%s.h5' % (datetime.now().date(),
                                          str(datetime.now().time())[:8]), 'w')
      h5['results'] = results
      h5.close()
                  PART
             Three
Market-Based Valuation
                                                                          CHAPTER         8
                      A First Example of Market-Based
                                             Valuation


8.1 INTRODUCTION

This chapter takes a hands-on approach and dives into a market-based valuation without paying
too much attention to the theoretical and numerical foundations. It addresses all main steps of
such a valuation: market modeling, European call valuation via Fourier techniques, calibration
of a market model to European call option quotes and simulation of the calibrated model.
      The exposition might seem a bit bumpy. However, all aspects are addressed and are made
somewhat more precise later in this part of the book. Those with some background knowledge
will find in this first example and the accompanying Python scripts a kind of sandbox in which
first steps in other directions can be taken.
      Section 8.2 introduces the market model. Section 8.3 addresses valuation via Fourier-
based approaches. Section 8.4 calibrates the model to real market data. Finally, section 8.5
simulates the calibrated model and values a European call option by simulation.


8.2 MARKET MODEL

We consider the jump-diffusion model ÓàπM76 of Merton (cf. Merton (1976), M76) as already
sketched out in section 6.6. The plan is to completely implement this specific model numerically
and technically. The time horizon T is fixed, 0 < T < ‚àû. In this continuous market model, the
index level has risk-neutral dynamics of the form

                            dSt = (r ‚àí rJ )St dt + ùúéSt dZt + Jt St dNt                     (8.1)

The variables and parameters are defined as follows:

   St index level at date t
   r constant risk-less short rate
   r ‚â° ùúÜ ‚ãÖ (eùúáJ +ùõø ‚àï2 ‚àí 1) drift correction for jump
                   2
     J
   ùúé constant volatility of S

   Z standard Brownian motion
      t



                                                                                            147
148                                                                 DERIVATIVES ANALYTICS WITH PYTHON


       Jt jump at date t with ‚Ä¶
      ‚Äì ‚Ä¶ distribution log(1 + Jt ) ‚âà N(log(1 + ùúáJ ) ‚àí ùõø2 , ùõø 2 ) ‚Ä¶
                                                                2


      ‚Äì ‚Ä¶ and N as the cumulative distribution function of a standard normal random variable
     N Poisson process with intensity ùúÜ
       t

     At this moment, a full understanding of the details is not necessary.1 It suffices to under-
stand that these dynamics model a process with ‚Äúgenerally‚Äù continuous paths which can jump
at certain unforeseeable dates.


8.3 VALUATION

Applying Fourier techniques, one can value European call options in this model in semi-
analytic form‚Äîa prerequisite for which is knowledge of the characteristic function for the
stock price dynamics (8.1) in log terms. This is a well-known function of the form
                                       ((                                      ) )
                                               u2 ùúé 2      iuùúáJ ‚àíu2 ùõø 2 ‚àï2
                   ùúëM76
                    0
                        (u, T) = exp     iuùúî ‚àí        + ùúÜ(e                ‚àí 1) T               (8.2)
                                                 2

where the risk-neutral drift term ùúî takes on the form

                                              ùúé2
                                                 ‚àí ùúÜ(eùúáJ +ùõø ‚àï2 ‚àí 1)
                                                           2
                                   ùúî=r‚àí                                                         (8.3)
                                              2

This function may be found, for instance, in Gatheral (2006), pp. 57‚Äì58, where one has to
include the non-zero short rate.
     To value European call options in this model, we can apply both approaches introduced
in Chapter 6. Sub-section 8.7.1 contains a Python script implementing the following valuation
formula, which is due to Lewis (cf. Lewis (2001)), for the M76 setup and evaluating it via
numerical integration.
                             ‚àö
                              S0 Ke‚àírT‚àï2          ‚àû     [                      ]   dz
                 C0 = S0 ‚àí                            Re eizk ùúëM76 (z ‚àí i‚àï2, T) 2
                                   ùúã         ‚à´0                0
                                                                                 z + 1‚àï4

     The value of a European call option on the index with strike K and maturity T is according
to the Fourier-based approach of Carr-Madan (cf. Carr and Madan (1999)) given by

                               e‚àíùõºk
                                        ‚àû           e‚àírT ùúëM76
                                                          0
                                                              (v ‚àí (ùõº + 1)i, T)
                        C0 =                e‚àíivk                                 dv
                                ùúã ‚à´0                  ùõº 2 + ùõº ‚àí v2 + i(2ùõº + 1)v

with k = log K. This integral has a form that allows the application of FFT. Sub-section 8.7.2
provides a Python script that implements FFT for the M76 model. For both approaches refer
to section 6.4 for further details and derivations.

1
 Tankov and Voltchkova (2009) is a concise survey of jump-diffusion models and related techniques.
Cont and Tankov (2004a) is a comprehensive textbook on this topic.
A First Example of Market-Based Valuation                                                                 149


8.4 CALIBRATION

In simple terms, the‚Äîunfortunately ill-posed2 ‚Äîproblem of calibration is to find parameters
for the M76 model such that observed market quotes of liquidly traded plain vanilla options
are replicated as closely as possible. To this end, one defines an error function that is to be
minimized. Such a function could be the Root Mean Squared Error (RMSE). The task is then
to solve the problem
                                        ‚àö
                                        ‚àö
                                        ‚àö1 ‚àë N
                                               (                          )2
                               min ‚àö            C‚àó ‚àí CnM76 (ùúé, ùúÜ, ùúáJ , ùõø)                                (8.4)
                              ùúé,ùúÜ,ùúáJ ,ùõø   N n=1 n

with the Cn‚àó being the market or input prices and the CnM76 being the model or output prices
for the options n = 1, ‚Ä¶ , N.
     To gain a first impression of the calibration procedure, Appendix 8.7.3 provides a Python
script that calibrates the M76 model to prices of European call options on the EURO STOXX
50 index from the Eurex in Frankfurt. All prices are from 30. September 2014. The script
uses both global minimization in the form of a brute force algorithm and local minimization
algorithm. The idea is first to roughly scan the error surface and then to dig deeper locally
where it seems most promising. These two steps may be necessary since it cannot be excluded
that there are multiple local minima in which a local minimization algorithm could be trapped.3
     Figure 8.1 shows the result of a minimization run. It is obvious that the M76 model is
not capable of perfectly replicating observed market quotes. The degrees of freedom are not
sufficient to simultaneously accommodate both the different maturities and the different strike
levels. This is a first hint at the fact that a realistic financial market model must be richer than
M76.4
     However, inspection of Figure 8.2 reveals that calibration of M76 to a small subset of the
market quotes‚Äîi.e. to the market quotes for the shortest maturity options only‚Äîyields pretty
good results. Appendix 8.7.4 contains the respective Python script which again combines
global with local minimization. This script also uses the FFT approach. In fact, the role of
the jump feature of the general market model will be to better replicate observed short-term
option prices around the at-the-money strike level (while stochastic volatility is needed for
longer maturities). In this calibration the final RMSE is about 0.17 only.


8.5 SIMULATION

To value a European call option with strike price K by MCS consider the simple discretization
of the continuous time dynamics (8.1)
                               (                   ‚àö                         )
                     St = St‚àíŒît 1 + (r ‚àí rJ )Œît + ùúé Œîtz1t + (eùúáJ +ùõøzt ‚àí 1)yt
                                                                    2
                                                                                                         (8.5)


2
  Galluccio and Le Cam (2008) discuss this aspect at considerable length. See also Chapter 11.
3
  Note that the error function definition in the calibration scripts includes a penalty routine which penalizes
negative values for those parameters that are (economically) not allowed to become negative.
4
  Tankov and Voltchkova (2009) draw similar conclusions on the basis of another numerical example.
150                                              DERIVATIVES ANALYTICS WITH PYTHON




      FIGURE 8.1 Results of the calibration of Merton‚Äôs
      jump-diffusion model to market quotes for three maturities; lines =
      market quotes, dots = model prices
A First Example of Market-Based Valuation                                                           151




FIGURE 8.2 Results of the calibration of Merton‚Äôs jump-diffusion model to a small subset of market
quotes (i.e. a single maturity only; here: shortest maturity); line = market quotes, dots = model prices,
bars = difference between model values and market quotes


with the znt being standard normally distributed and the yt being Poisson distributed with
intensity ùúÜ.
     An alternative discretization with generally better convergence properties is based on the
log dynamics and takes the form
                                 (               ‚àö                        )
                     St = St‚àíŒît e(r‚àírJ ‚àíùúé ‚àï2)Œît+ùúé Œîtzt + (eùúáJ +ùõøzt ‚àí 1)yt
                                          2           1          2
                                                                                          (8.6)

     To arrive at a value estimate for a European call option use Algorithm 3.
     Appendix 8.7.5 provides a Python script that implements Algorithm 3 with both dis-
cretization alternatives (8.5) and (8.6). The script uses the optimal parameters (rounded) from
the calibration to the short maturity option quotes. In addition, the script contains a routine to
numerically compare the three valuation approaches for varying moneyness levels of the call
option.
     The values derived from the different approaches are shown in Figure 8.3. Although the
figure suggests that all valuation results are equal, there are minor differences between the
    152                                                       DERIVATIVES ANALYTICS WITH PYTHON



    Algorithm 3: Valuation Algorithm for Merton (1976)
1 Divide the time interval [0, T] into equidistant sub-intervals of length Œît
  for t = 0, Œît, ‚Ä¶ , T do
      for i = 1, ‚Ä¶ , I do
          if t = 0 then
2              Set St,i = S0
           else
3              Draw standard normally distributed pseudo-random numbers z1t,i , z2t,i and a
               Poission distributed pseudo-random number yt,i
4              Simulate the index level value St,i given St‚àíŒît,i and zt,i according to (8.5) or (8.6)
               if t = T then
5                   Determine the inner value hT,i of the call option at T as

                                     hT,i (ST (i)) = max[ST (i) ‚àí K, 0]

6                  Sum up the inner values, average and discount them back with the risk-less
                   short rate:
                                                  1‚àë
                                      C0 ‚âà e‚àírT       h (S (i))                                 (8.7)
                                                  I I T T




             FIGURE 8.3 Comparison of European call option values from Lewis formula
             (line), from Carr-Madan formula (triangles) and Monte Carlo simulation (dots)
     A First Example of Market-Based Valuation                                             153


     MCS estimates and the theoretical values according to the Lewis and Carr-Madan approaches.
     The detailed results are:

 1    CALL STRIKE               3000.000
 2    ----------------------------
 3    Call Value by Int    269.749
 4    Call Value by FFT    269.733
 5    Difference FFT/Int           -0.016
 6    Call Value by MCS           270.503
 7    Difference MCS/Int            0.754
 8    ----------------------------
 9    CALL STRIKE         3050.000
10    ----------------------------
11    Call Value by Int           231.142
12    Call Value by FFT           231.118
13    Difference FFT/Int           -0.025
14    Call Value by MCS           231.827
15    Difference MCS/Int            0.685
16    ----------------------------
17    CALL STRIKE         3100.000
18    ----------------------------
19    Call Value by Int           194.905
20    Call Value by FFT           194.890
21    Difference FFT/Int           -0.015
22    Call Value by MCS    195.531
23    Difference MCS/Int     0.625
24    ----------------------------
25    CALL STRIKE         3150.000
26    ----------------------------
27    Call Value by Int    161.340
28    Call Value by FFT           161.346
29    Difference FFT/Int            0.006
30    Call Value by MCS    161.905
31    Difference MCS/Int     0.565
32    ----------------------------
33    CALL STRIKE         3200.000
34    ----------------------------
35    Call Value by Int    130.761
36    Call Value by FFT           130.785
37    Difference FFT/Int            0.024
38    Call Value by MCS           131.247
39    Difference MCS/Int     0.486
40    ----------------------------
41    CALL STRIKE         3250.000
42    ----------------------------
43    Call Value by Int    103.466
44    Call Value by FFT    103.492
     154                             DERIVATIVES ANALYTICS WITH PYTHON


45    Difference FFT/Int     0.026
46    Call Value by MCS    103.823
47    Difference MCS/Int     0.357
48    ----------------------------
49    CALL STRIKE         3300.000
50    ----------------------------
51    Call Value by Int     79.695
52    Call Value by FFT     79.705
53    Difference FFT/Int    0.010
54    Call Value by MCS    79.906
55    Difference MCS/Int    0.211
56    ----------------------------
57    CALL STRIKE         3350.000
58    ----------------------------
59    Call Value by Int     59.578
60    Call Value by FFT     59.565
61    Difference FFT/Int   -0.013
62    Call Value by MCS    59.677
63    Difference MCS/Int    0.099
64    ----------------------------
65    CALL STRIKE         3400.000
66    ----------------------------
67    Call Value by Int    43.104
68    Call Value by FFT    43.076
69    Difference FFT/Int   -0.028
70    Call Value by MCS     43.161
71    Difference MCS/Int     0.057
72    ----------------------------
73    CALL STRIKE         3450.000
74    ----------------------------
75    Call Value by Int    30.097
76    Call Value by FFT    30.071
77    Difference FFT/Int   -0.026
78    Call Value by MCS     30.133
79    Difference MCS/Int     0.036
80    ----------------------------
81    CALL STRIKE         3500.000
82    ----------------------------
83    Call Value by Int     20.232
84    Call Value by FFT    20.224
85    Difference FFT/Int   -0.008
86    Call Value by MCS    20.288
87    Difference MCS/Int     0.056
88    ----------------------------
89    CALL STRIKE         3550.000
90    ----------------------------
91    Call Value by Int     13.069
      A First Example of Market-Based Valuation                                                   155

92        Call Value by FFT         13.083
93        Difference FFT/Int         0.015
94        Call Value by MCS         13.161
95        Difference MCS/Int         0.093
96        ----------------------------
97        CALL STRIKE         3600.000
98        ----------------------------
99        Call Value by Int          8.104
100       Call Value by FFT          8.132
101       Difference FFT/Int         0.028
102       Call Value by MCS      8.210
103       Difference MCS/Int     0.106
104       ----------------------------




      8.6 CONCLUSIONS

      This chapter illustrates market-based valuation in the context of Merton‚Äôs jump-diffusion
      model. In particular, the chapter provides:

          1. model: a market model adding a jump component to the BSM setup
          2. vanilla valuation: application of the Fourier-based option pricing approaches of Lewis
             and Carr-Madan to the market model
          3. calibration: calibration of the model to a number of real market quotes; this is possible
             due to the inclusion of a jump component offering more degrees of freedom compared to
             BSM
          4. simulation: discretization of the model and simulation of it for the purpose of getting
             European option values

         These building blocks are the typical prerequisites for a market-based valuation of more
      complex derivatives. Subsequent chapters address all related aspects in more detail.


      8.7 PYTHON SCRIPTS

      8.7.1 Valuation by Numerical Integration

      #
      # Valuation of European Call Options
      # in Merton's (1976) Jump Diffusion Model
      # via Numerical Integration
      # 08_m76/M76_valuation_INT.py
      #
      # (c) Dr. Yves J. Hilpisch
      # Derivatives Analytics with Python
      #
156                                             DERIVATIVES ANALYTICS WITH PYTHON


import math
import numpy as np
from scipy.integrate import quad


#
# Model Parameters
#
S0 = 100.0 # initial index level
K = 100.0 # strike level
T = 1.0 # call option maturity
r = 0.05 # constant short rate
sigma = 0.4 # constant volatility of diffusion
lamb = 1.0 # jump frequency p.a.
mu = -0.2 # expected jump size
delta = 0.1     # jump size volatility

#
# Valuation by Integration
#



def M76_value_call_INT(S0, K, T, r, sigma, lamb, mu, delta):
    ''' Valuation of European call option in M76 model via
      Lewis (2001) Fourier-based approach.

      Parameters
      ==========
      S0: float
          initial stock/index level
      K: float
          strike price
      T: float
          time-to-maturity (for t=0)
      r: float
          constant risk-free short rate
      sigma: float
          volatility factor in diffusion term
      lamb: float
          jump intensity
      mu: float
          expected jump size
      delta: float
          standard deviation of jump


      Returns
      =======
      call_value: float
A First Example of Market-Based Valuation                                      157


         European call option present value
     '''
     int_value = quad(lambda u: M76_integration_function(u, S0, K, T, r,
                     sigma, lamb, mu, delta), 0, 50, limit=250)[0]
     call_value = S0 - np.exp(-r * T) * math.sqrt(S0 * K) / math.pi * int_value
     return call_value



def M76_integration_function(u, S0, K, T, r, sigma, lamb, mu, delta):
     ''' Valuation of European call option in M76 model via
     Lewis (2001) Fourier-based approach: integration function.


     Parameter definitions see function M76_value_call_INT. '''
     JDCF = M76_characteristic_function(u - 0.5 * 1j, T, r,
                                        sigma, lamb, mu, delta)
     value = 1 / (u ** 2 + 0.25) * (np.exp(1j * u * math.log(S0 / K))
                                     * JDCF).real
     return value



def M76_characteristic_function(u, T, r, sigma, lamb, mu, delta):
    ''' Valuation of European call option in M76 model via
    Lewis (2001) Fourier-based approach: characteristic function.


     Parameter definitions see function M76_value_call_INT. '''
     omega = r - 0.5 * sigma ** 2 - lamb * (np.exp(mu + 0.5 * delta ** 2) - 1)
     value = np.exp((1j * u * omega - 0.5 * u ** 2 * sigma ** 2 +
             lamb * (np.exp(1j * u * mu - u ** 2 * delta ** 2 * 0.5) - 1))   * T)
     return value


if _ _name_ _ == '_ _main_ _':
     print "Value of Call Option %8.3f" \
               % M76_value_call_INT(S0, K, T, r, sigma, lamb, mu, delta)




8.7.2 Valuation by FFT

#
# Valuation of European Call Options
# in Merton's (1976) Jump Diffusion Model
# via Fast Fourier Transform (FFT)
# 08_m76/M76_valuation_FFT.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
158                                               DERIVATIVES ANALYTICS WITH PYTHON


import math
import numpy as np
from numpy.fft import *


#
# Model Parameters
#
S0 = 100.0 # initial index level
K = 100.0 # strike level
T = 1.0 # call option maturity
r = 0.05 # constant short rate
sigma = 0.4 # constant volatility of diffusion
lamb = 1.0 # jump frequency p.a.
mu = -0.2 # expected jump size
delta = 0.1      # jump size volatility

#
# M76 Characteristic Function
#


def M76_characteristic_function(u, x0, T, r, sigma, lamb, mu, delta):
    ''' Valuation of European call option in M76 model via
    Lewis (2001) Fourier-based approach: characteristic function.


      Parameter definitions see function M76_value_call_FFT. '''
      omega = x0 / T + r - 0.5 * sigma ** 2 \
                  - lamb * (np.exp(mu + 0.5 * delta ** 2) - 1)
      value = np.exp((1j * u * omega - 0.5 * u ** 2 * sigma ** 2 +
              lamb * (np.exp(1j * u * mu - u ** 2 * delta ** 2 * 0.5) - 1))   * T)
      return value


#
# Valuation by FFT
#



def M76_value_call_FFT(S0, K, T, r, sigma, lamb, mu, delta):
      ''' Valuation of European call option in M76 model via
      Carr-Madan (1999) Fourier-based approach.


      Parameters
      ==========
      S0: float
          initial stock/index level
      K: float
          strike price
      T: float
A First Example of Market-Based Valuation                                             159


         time-to-maturity (for t=0)
     r: float
         constant risk-free short rate
     sigma: float
         volatility factor in diffusion term
     lamb: float
         jump intensity
     mu: float
         expected jump size
     delta: float
         standard deviation of jump


     Returns
     =======
     call_value: float
         European call option present value
     '''
     k = math.log(K / S0)
     x0 = math.log(S0 / S0)
     g = 2 # factor to increase accuracy
     N = g * 4096
     eps = (g * 150.) ** -1
     eta = 2 * math.pi / (N * eps)
     b = 0.5 * N * eps - k
     u = np.arange(1, N + 1, 1)
     vo = eta * (u - 1)
     # Modificatons to Ensure Integrability
     if S0 >= 0.95 * K: # ITM case
         alpha = 1.5
          v = vo - (alpha + 1) * 1j
          mod_char_fun = math.exp(-r * T) * M76_characteristic_function(
                                             v, x0, T, r, sigma, lamb, mu, delta) \
                    / (alpha ** 2 + alpha - vo ** 2 + 1j * (2 * alpha + 1) * vo)
     else:     # OTM case
          alpha = 1.1
          v = (vo - 1j * alpha) - 1j
          mod_char_fun_1 = math.exp(-r * T) * (1 / (1 + 1j * (vo - 1j * alpha))
                                            - math.exp(r * T) / (1j * (vo - 1j * alpha))
                                            - M76_characteristic_function(
                                              v, x0, T, r, sigma, lamb, mu, delta)
                  / ((vo - 1j * alpha) ** 2 - 1j * (vo - 1j * alpha)))
          v = (vo + 1j * alpha) - 1j
          mod_char_fun_2 = math.exp(-r * T) * (1 / (1 + 1j * (vo + 1j * alpha))
                                            - math.exp(r * T) / (1j * (vo + 1j * alpha))
                                            - M76_characteristic_function(
                                              v, x0, T, r, sigma, lamb, mu, delta)
                    / ((vo + 1j * alpha) ** 2 - 1j * (vo + 1j * alpha)))
160                                             DERIVATIVES ANALYTICS WITH PYTHON


      # Numerical FFT Routine
      delt = np.zeros(N, dtype=np.float)
      delt[0] = 1
      j = np.arange(1, N + 1, 1)
      SimpsonW = (3 + (-1) ** j - delt) / 3
      if S0 >= 0.95 * K:
          fft_func = np.exp(1j * b * vo) * mod_char_fun * eta * SimpsonW
          payoff = (fft(fft_func)).real
          call_value_m = np.exp(-alpha * k) / math.pi * payoff
      else:
          fft_func = (np.exp(1j * b * vo)
                      * (mod_char_fun_1 - mod_char_fun_2)
                      * 0.5 * eta * SimpsonW)
          payoff = (fft(fft_func)).real
          call_value_m = payoff / (np.sinh(alpha * k) * math.pi)
      pos = int((k + b) / eps)
      call_value = call_value_m[pos]
      return call_value * S0

if _ _name_ _ == '_ _main_ _':
      print "Value of Call Option %8.3f" \
          % M76_value_call_FFT(S0, K, T, r, sigma, lamb, mu, delta)




8.7.3 Calibration to Three Maturities

#
# Calibration of Merton's (1976)
# Jump Diffusion Model
# via Fast Fourier Transform
# 08_m76/M76_calibration_FFT.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
np.set_printoptions(suppress=True,
                    formatter={'all': lambda x: '%5.3f' % x})
import pandas as pd
import scipy.optimize as sop
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
from M76_valuation_FFT import M76_value_call_FFT
A First Example of Market-Based Valuation                            161


#
# Market Data from www.eurexchange.com
# as of 30. September 2014
#
h5 = pd.HDFStore('08_m76/option_data.h5', 'r')
data = h5['data'] # European call & put option data (3 maturities)
h5.close()
S0 = 3225.93 # EURO STOXX 50 level
r = 0.0005 # ECB base rate


# Option Selection
tol = 0.02
options = data[(np.abs(data['Strike'] - S0) / S0) < tol]


#
# Error Function
#


def M76_error_function_FFT(p0):
     ''' Error Function for parameter calibration in M76 Model via
     Carr-Madan (1999) FFT approach.


     Parameters
     ==========
     sigma: float
         volatility factor in diffusion term
     lamb: float
         jump intensity
     mu: float
         expected jump size
     delta: float
          standard deviation of jump


     Returns
     =======
     RMSE: float
         root mean squared error
     '''
     global i, min_RMSE
     sigma, lamb, mu, delta = p0
     if sigma < 0.0 or delta < 0.0 or lamb < 0.0:
         return 500.0
     se = []
     for row, option in options.iterrows():
         T = (option['Maturity'] - option['Date']).days / 365.
162                                             DERIVATIVES ANALYTICS WITH PYTHON


          model_value = M76_value_call_FFT(S0, option['Strike'], T,
                                           r, sigma, lamb, mu, delta)
          se.append((model_value - option['Call']) ** 2)
      RMSE = math.sqrt(sum(se) / len(se))
      min_RMSE = min(min_RMSE, RMSE)
      if i % 50 == 0:
          print '%4d |' % i, np.array(p0), '| %7.3f | %7.3f' % (RMSE, min_RMSE)
      i += 1
      return RMSE


def generate_plot(opt, options):
    #
      # Calculating Model Prices
      #
      sigma, lamb, mu, delta = opt
      options['Model'] = 0.0
      for row, option in options.iterrows():
          T = (option['Maturity'] - option['Date']).days / 365.
          options.loc[row, 'Model'] = M76_value_call_FFT(S0, option['Strike'],
                                      T, r, sigma, lamb, mu, delta)


      #
      # Plotting
      #
      mats = sorted(set(options['Maturity']))
      options = options.set_index('Strike')
      for i, mat in enumerate(mats):
          options[options['Maturity'] == mat][['Call', 'Model']].\
                  plot(style=['b-', 'ro'], title='%s' % str(mat)[:10])
          plt.ylabel('option value')
          plt.savefig('../images/08_m76/M76_calibration_3_%s.pdf' % i)


if _ _name_ _ == '_ _main_ _':
    #
      # Calibration
      #
      i = 0 # counter initialization
      min_RMSE = 100 # minimal RMSE initialization
      p0 = sop.brute(M76_error_function_FFT, ((0.075, 0.201, 0.025),
                      (0.10, 0.401, 0.1), (-0.5, 0.01, 0.1),
                      (0.10, 0.301, 0.1)), finish=None)

      # p0 = [0.15, 0.2, -0.3, 0.2]
      opt = sop.fmin(M76_error_function_FFT, p0,
                      maxiter=500, maxfun=750,
                      xtol=0.000001, ftol=0.000001)
A First Example of Market-Based Valuation                            163


8.7.4 Calibration to Short Maturity

#
# Calibration of Merton's (1976)
# Jump Diffusion Model
# to Short Maturity Data
# 08_m76/M76_calibration_single.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
np.set_printoptions(suppress=True,
                    formatter={'all': lambda x: '%5.3f' % x})
import pandas as pd
import scipy.optimize as sop
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
from M76_valuation_FFT import M76_value_call_FFT


#
# Market Data from www.eurexchange.com
# as of 30. September 2014
#
h5 = pd.HDFStore('08_m76/option_data.h5', 'r')
data = h5['data'] # European call & put option data (3 maturities)
h5.close()
S0 = 3225.93 # EURO STOXX 50 level
r = 0.005 # assumption


# Option Selection
tol = 0.05
options = data[(np.abs(data['Strike'] - S0) / S0) < tol]
mats = sorted(set(options['Maturity']))
options = options[options['Maturity'] == mats[0]]


#
# Error Function
#



def M76_error_function_FFT(p0):
    ''' Error function for parameter calibration in M76 Model via
     Carr-Madan (1999) FFT approach.
164                                              DERIVATIVES ANALYTICS WITH PYTHON


      Parameters
      ==========
      sigma: float
          volatility factor in diffusion term
      lamb: float
          jump intensity
      mu: float
          expected jump size
      delta: float
          standard deviation of jump

      Returns
      =======
      RMSE: float
          root mean squared error
      '''
      global i, min_RMSE
      sigma, lamb, mu, delta = p0
      if sigma < 0.0 or delta < 0.0 or lamb < 0.0:
          return 500.0
      se = []
      for row, option in options.iterrows():
          T = (option['Maturity'] - option['Date']).days / 365.
          model_value = M76_value_call_FFT(S0, option['Strike'], T,
                                           r, sigma, lamb, mu, delta)
          se.append((model_value - option['Call']) ** 2)
      RMSE = math.sqrt(sum(se) / len(se))
      min_RMSE = min(min_RMSE, RMSE)
      if i % 50 == 0:
          print '%4d |' % i, np.array(p0), '| %7.3f | %7.3f' % (RMSE, min_RMSE)
      i += 1
      return RMSE



#
# Graphical Output
#
def generate_plot(opt, options):
    #
    # Calculating Model Prices
      #
      sigma, lamb, mu, delta = opt
      options['Model'] = 0.0
      for row, option in options.iterrows():
          T = (option['Maturity'] - option['Date']).days / 365.
          options.loc[row, 'Model'] = M76_value_call_FFT(S0, option['Strike'],
                                       T, r, sigma, lamb, mu, delta)
A First Example of Market-Based Valuation                                   165


     #
     # Plotting
     #
     options = options.set_index('Strike')
     fig, ax = plt.subplots(2, sharex=True, figsize=(8, 7))
     options[['Call', 'Model']].plot(style=['b-', 'ro'],
                     title='%s' % str(option['Maturity'])[:10], ax=ax[0])
     ax[0].set_ylabel('option values')
     xv = options.index.values
     ax[1] = plt.bar(xv - 5 / 2., options['Model'] - options['Call'],
                     width=5)
     plt.ylabel('difference')
     plt.xlim(min(xv) - 10, max(xv) + 10)
     plt.tight_layout()
     plt.grid()



#
# Calibration
#
if _ _name_ _ == '_ _main_ _':
    i = 0
    min_RMSE = 100.
     p0 = sop.brute(M76_error_function_FFT, ((0.10, 0.201, 0.025),
                     (0.1, 0.8, 0.1), (-0.4, 0.01, 0.1),
                     (0.00, 0.121, 0.02)), finish=None)


     opt = sop.fmin(M76_error_function_FFT, p0, xtol=0.00001,
                     ftol=0.00001, maxiter=750, maxfun=1500)




8.7.5 Valuation by MCS

#
# Valuation of European Call Options
# in Merton's (1976) Jump Diffusion Model
# via Monte Carlo Simulation
# 08_m76/M76_valuation_MCS.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
import pandas as pd
166                                                DERIVATIVES ANALYTICS WITH PYTHON


from M76_valuation_FFT import M76_value_call_FFT
from M76_valuation_INT import M76_value_call_INT


#
# Model Parameters (from Calibration)
#
S0 = 3225.93 # EURO STOXX 50 level (30.09.2014)
T = 0.22 # shortest maturity
r = 0.005 # assumption


sigma, lamb, mu, delta = [0.113, 3.559, -0.075, 0.041]
  # from calibration



#
# Valuation by Simulation
#
seed = 100000 # seed value
M = 50 # time steps
I = 200000 # paths
disc = 2    # 1 = simple Euler; else = log Euler



def M76_generate_paths(S0, T, r, sigma, lamb, mu, delta, M, I):
    ''' Generate Monte Carlo Paths for M76 Model.
    Parameters
      ==========
      S0: float
          initial stock/index level
      K: float
          strike price
      T: float
          time-to-maturity (for t=0)
      r: float
          constant risk-free short rate
      sigma: float
          volatility factor in diffusion term
      lamb: float
          jump intensity
      mu: float
          expected jump size
      delta: float
          standard deviation of jump
      M: int
          number of time intervals
      I: int
           number of paths
A First Example of Market-Based Valuation                                       167


     Returns
     =======
     S: array
         simulated paths
     '''
     dt = T / M
     rj = lamb * (math.exp(mu + 0.5 * delta ** 2) - 1)
     shape = (M + 1, I)
     S = np.zeros((M + 1, I), dtype=np.float)
     S[0] = S0

     np.random.seed(10000)
     rand1 = np.random.standard_normal(shape)
     rand2 = np.random.standard_normal(shape)
     rand3 = np.random.poisson(lamb * dt, shape)

     for t in xrange(1, M + 1, 1):
          if disc == 1:
              S[t] = S[t - 1] * ((1 + (r - rj) * dt) + sigma
                                 * math.sqrt(dt) * rand1[t]
                                        + (np.exp(mu + delta * rand2[t]) - 1)
                                        * rand3[t])
          else:
                S[t] = S[t - 1] * (np.exp((r - rj - 0.5 * sigma ** 2) * dt
                                   + sigma * math.sqrt(dt) * rand1[t])
                                   + (np.exp(mu + delta * rand2[t]) - 1)
                                        * rand3[t])
     return S


def M76_value_call_MCS(K):
    ''' Function to calculate the MCS estimator given K.


     Parameters
     ==========
     K: float
         strike price


     Returns
     =======
     call_mcs: float
         European call option Monte Carlo estimator
     '''
     return math.exp(-r * T) * np.sum(np.maximum(S[-1] - K, 0)) / I




if _ _name_ _ == '_ _main_ _':
168                                               DERIVATIVES ANALYTICS WITH PYTHON


      # Single Valuation
      S = M76_generate_paths(S0, T, r, sigma, lamb, mu, delta, M, I)
      print "Value of Call Option %8.3f" % M76_value_call_MCS(S0)


      # Value Comparisons
      strikes = np.arange(3000, 3601, 50)
      values = np.zeros((3, len(strikes)), dtype=np.float)
      z = 0
      for k in strikes:
          print "CALL STRIKE       %10.3f" % k
          print "----------------------------"
          values[0, z] = M76_value_call_INT(S0, k, T, r, sigma,
                                         lamb, mu, delta)
          print "Call Value by Int %10.3f" % values[0, z]


          values[1, z] = M76_value_call_FFT(S0, k, T, r, sigma,
                                         lamb, mu, delta)
          print "Call Value by FFT %10.3f" % values[1, z]
          print "Difference FFT/Int%10.3f" % (values[1, z] - values[0, z])
          values[2, z] = M76_value_call_MCS(k)
          print "Call Value by MCS %10.3f" % values[2, z]
          print "Difference MCS/Int%10.3f" % (values[2, z] - values[0, z])
          print "----------------------------"
          z = z + 1

      results = pd.DataFrame(values.T, index=strikes, columns=[
                                            'INT', 'FFT', 'MCS'])
      results.index.name = 'Strike'
                                                                           CHAPTER         9
                                    General Model Framework


9.1 INTRODUCTION

Chapter 8 conducts a model calibration and market-based valuation with the jump-diffusion
model of Merton (1976). The calibration effort reveals that a jump component alone is not
capable of replicating a typical volatility surface. It is rather necessary to include at least a
stochastic volatility component (as already pointed out in Chapter 3). In addition, we also
need a stochastic short rate component to accommodate stylized facts of interest rate markets.
     This chapter therefore introduces in section 9.2 the model framework of Bakshi, Cao
and Chen (1997, BCC97, Bakshi et al. (1997)) that includes as special cases a number of
popular financial models, like the Black-Scholes-Merton model. Section 9.3 briefly recaps
the main statistical features a realistic market model should exhibit. That section also cites
a number of empirical findings regarding the performance of the framework under different
parametrizations. Section 9.5 then concerns itself with the valuation of European options in
the general framework‚Äîa necessary prerequisite for an efficient calibration procedure.



9.2 THE FRAMEWORK

Given is a filtered probability space (Œ©, Óà≤ , F, P) representing uncertainty in the model economy
ÓàπBCC97 with final date T where 0 < T < ‚àû. Œ© denotes the continuous state space, Óà≤ a
ùúé-algebra, F a filtration and P the real or objective probability measure. Traded securities are
a risky stock index S and a risky unit zero-coupon bond B.
     Together, we have the continuous market model

                              ÓàπBCC97 = {(Œ©, Óà≤ , F, P), T, (S, B)}

More specifically, the market model of Bakshi-Cao-Chen is characterized by stochastic volatil-
ity, jump risk and stochastic short rates. The risk-neutral dynamics of the stock index S are
according to the stochastic volatility jump-diffusion model of Bates (1996, B96)
                                                  ‚àö
                          dSt = (rt ‚àí rJ )St dt + vt St dZt1 + Jt St dNt                (9.1)
                                                         ‚àö
                               dvt = ùúÖv (ùúÉv ‚àí vt )dt + ùúév vt dZt2                       (9.2)


                                                                                             169
170                                                             DERIVATIVES ANALYTICS WITH PYTHON


The meanings of the variables and parameters are

   St index level at date t
   rt risk-less short rate at date t
   r ‚â° ùúÜ ‚ãÖ (eùúáJ +ùõø ‚àï2 ‚àí 1) drift correction for jump
                    2
     J
   v variance at date t
     t
   ùúÖ speed of adjustment of v to ‚Ä¶
      v                            t
   ‚Ä¶ ùúÉ , the long-term average of the variance
          v
   ùúé volatility coefficient of the index‚Äôs variance
      v
   Z n standard Brownian motions
      t
   N Poisson process with intensity ùúÜ
       t
   J jump at date t with ‚Ä¶
     t
      ‚Äì ‚Ä¶ distribution log(1 + Jt ) ‚âà N(log(1 + ùúáJ ) ‚àí ùõø2 , ùõø 2 ) ‚Ä¶
                                                            2


      ‚Äì ‚Ä¶ and N as the cumulative distribution function of a standard normal random variable

    Regarding the stochastic short rate, the model uses the setup of Cox, Ingersoll and Ross
(1985, CIR85, Cox et al. (1985)) with the following dynamics for the short rate
                                                           ‚àö
                                 drt = ùúÖr (ùúÉr ‚àí rt )dt + ùúér rt dZt3                           (9.3)

The variables and the parameters of this square-root diffusion have, respectively, the meaning:

   rt short rate at date t
   ùúÖr speed of adjustment of rt to ‚Ä¶
   ‚Ä¶ ùúÉ , the long-term average of the short rate
         r
   ùúé volatility coefficient of the short rate
      r
   Z 3 standard Brownian motion
      t

     All stochastic processes are adapted to the filtration F. Moreover, instantaneous correla-
tions are dZt1 dZt2 ‚â° ùúådt, dZt1 dZt3 ‚â° dZt2 dZt3 ‚â° 0, Nt independent of Ztn , n = 1, 2, 3. The value
of a zero-coupon bond paying one unit of currency at T > t is
                                             (   (          T        ))
                               Bt (T) = EQ    exp ‚àí             ru du
                                         t             ‚à´t

with E being the expectation operator and Q a risk-neutral, P-equivalent probability measure
which we assume to exist (i.e. we assume no free lunches with vanishing risk (NFLVR)). We
define the set of uncertainties by Xt ‚â° (St , vt , rt )‚Äîsomething needed occasionally.


9.3 FEATURES OF THE FRAMEWORK

A market model must, in order to be of any practical use, fulfill a minimum set of requirements.

     statistical properties: a fundamental requirement is that the model be able to replicate the
      most important statistical properties of the stock index and the interest rate to be modeled
General Model Framework                                                                       171


   price replication: another important requirement is that a market model be able to
    replicate market prices from, for example, plain vanilla options like European puts and
    calls on indices and bonds or swaps
   degrees of freedom: from a formal perspective the market model has to offer sufficient

    degrees of freedom, i.e. parameters, to calibrate it to market prices or implied volatilities
    and the yield curve

      Recall the results of Chapter 3. There it is shown that a realistic market model should ‚Ä¶

   ‚Ä¶ take into account that index (implied) volatility
    ‚Äì varies over time (stochasticity, mean reversion, clustering)
    ‚Äì is negatively correlated with returns (leverage effect)
    ‚Äì varies for different option strikes (volatility smile)
    ‚Äì varies for different option maturities (volatility term structure)
   ‚Ä¶ account for jumps in the index development
   ‚Ä¶ take into account that interest rates

    ‚Äì vary over time (positivity, stochasticity, mean reversion)
    ‚Äì vary for different time horizons (term structure)

     The general framework is capable, in principle, of fulfilling several or all of these require-
ments and of reproducing the statistical properties of stock indices sufficiently well. In a
similar vein, it can also reproduce the most important characteristics of interest rates, like
time-varying short rate or horizon-dependent yield (so-called yield curve). These statements
will be substantiated in Chapter 11 where we will see that the general framework indeed repro-
duces the required statistical features sufficiently well. In addition, we will see that quotes
from European call options will also be reproduced satisfactorily.
     As a convenient fact, the framework of BCC97 encompasses as special cases the following
widely applied option pricing models:

   Black-Scholes-Merton (1973, BSM, Black and Scholes (1973) and Merton (1973)):
    a model with geometric Brownian motion as the driving force and constant volatility as
    well as constant short rate (cf. Chapter 5)
   Merton (1976, M76, Merton (1976)): a model that enriches the model of BSM with a

    log-normally distributed jump component (cf. Chapter 8)
   Heston (1993, H93, Heston (1993)): one of the most popular models with stochastic

    volatility and constant short rate
   Bates (1996, B96, Bates (1996)) a model that adds a jump component to the stochastic

    volatility setting of H93

In addition, the general framework allows these special cases to be enriched by stochastic,
instead of constant, short rates.
     BCC97 conduct a number of empirical analyses for different parametrizations of their
general model. Some major findings are:

     quality of calibration: ‚ÄúOur empirical evidence indicates that regardless of performance
      yardstick, taking stochastic volatility into account is of the first-order importance in
      improving upon the BS[M] formula.‚Äù
172                                                           DERIVATIVES ANALYTICS WITH PYTHON


      quality of valuation: ‚ÄúAccording to the out-of-sample pricing measures, adding the ran-
       dom jump feature to the [stochastic volatility] model can further improve its performance,
       especially in pricing short-term options; whereas modeling stochastic interest rates can
       enhance the fit of long-term options.‚Äù
      hedging performance: ‚ÄúFor hedging purposes, however, incorporating either the jump

       or the [stochastic interest rate] feature does not seem to improve the [stochastic volatility]
       model‚Äôs performance further. The [stochastic volatility model] achieves the best hedging
       results among all the models studied, and its remaining hedging errors are generally quite
       small.‚Äù1

    As BCC97, p. 2009, point out, zero correlation between stock index and short rate might
be counter-factual. However, when considering non-zero correlation they find no improvement
upon the model with zero correlation:

         ‚Äú‚Ä¶ when we implement this slightly more general model [with non-zero correlation],
         we find its pricing and hedging performance to be indistinguishable from that of the
         [stochastic volatility, stochastic interest rate] model studied in this article.‚Äù

     All in all, the framework of BCC97 seems well-suited to address the valuation and hedging
of equity derivatives in an integrated manner. Fundamentally, it can be calibrated to observed
market prices due to its sufficient degrees of freedom, it is capable of valuing derivative
assets reasonably accurately and it provides hedging strategies that perform quite well. It also
explicitly models all major market risks that affect equity derivatives, like index risk, volatility
risk, jump risk and interest rate risk.



9.4 ZERO-COUPON BOND VALUATION

The discount factor B0 (T) for discounting cash flows due at time T to time t = 0, i.e. the
present value of a zero-coupon bond paying one unit of currency at T, in the CIR85 model
takes the form (cf. Glasserman (2004), 128‚Äì129)

                                B0 (T) = b1 (T)e‚àíb2 (T)r0                                      (9.4)
                                         [                      ] 2ùúÖr ùúÉr
                                            2ùõæ exp((ùúÖr + ùõæ)T‚àï2)    ùúér2
                                b1 (T) ‚â°                   ùõæT
                                                                                               (9.5)
                                           2ùõæ + (ùúÖr + ùõæ)(e ‚àí 1)
                                                2(eùõæT ‚àí 1)
                                b2 (T) ‚â°                                                       (9.6)
                                         2ùõæ + (ùúÖr + ùõæ)(eùõæT ‚àí 1)
                                         ‚àö
                                     ùõæ ‚â° ùúÖr2 + 2ùúér2                                            (9.7)



1
    All quotes from Bakshi et al. (1997), pp. 2042‚Äì2043.
General Model Framework                                                                      173


The Python script of sub-section 9.7.2 implements formulas (9.4)‚Äì(9.7) for use in the European
option valuation that follows.


9.5 EUROPEAN OPTION VALUATION

This section analyzes the valuation of European (call) options in the general framework. Three
approaches are considered:

   PDE method: the traditional approach to derivative asset valuation is to solve a partial
    differential equation (PDE) that a derivative asset must satisfy given the dynamics of the
    underlying; this approach is sketched in Chapter 5 for the BSM model
   Fourier-based pricing: via Fourier transforms it is possible to derive for a number of

    models (semi-)analytical pricing formulas, i.e. integrals, for certain derivative assets, like
    European call options; Chapter 6 analyzes this approach in some detail
   Monte Carlo simulation: via discretizing the relevant risk-neutral processes and using

    (quasi- or pseudo-)random numbers one can generate random process evolutions and
    thereby values for the derivative asset under consideration at maturity or exercise; iterating
    sufficiently often, discounting the single option values at maturity or exercise back and
    averaging over all discounted option values then yields an estimate of the option value;
    Chapters 7 and 8 use this method

     The valuation formulas obtained by the PDE approach or the transform method may
then be evaluated via numerical integration or Fast Fourier Transform (FFT). However, no
matter what valuation approach or numerical method is used, the general principle is that of
no arbitrage pricing, which Chapter 4 explores comprehensively.
     The PDE approach is quite powerful in addressing general valuation and hedging issues
while the transform method is particularly appropriate for certain models and payoff structures.
The advantage of the latter is, however, the form of the resulting (semi-)analytical valuation
formulas that typically allow for fast numerical solutions. Monte Carlo simulation is most
flexible in terms of models, payoff structures and other features (e.g. early exercise)‚Äîbut
generally also the slowest and least accurate alternative. For practical purposes, one therefore
uses a mix of these approaches. When calibrating models to plain vanilla options, transforms
are generally the method of choice. When valuing complex products with, for example,
multiple underlyings, Asian or American features, Monte Carlo simulation often is the only
practical choice.
     Translated to the context of this book, the formulas from the transform method for plain
vanilla options are used for calibration purposes while Monte Carlo simulation (based on the
already calibrated model) yields numerical values for more complex equity derivatives.


9.5.1 PDE Approach
Omitting time indices, the value of a European call option on the stock index must satisfy‚Äî
according to ItoÃÇ‚Äôs lemma (see section 9.7.1) and given the general market model‚Äîthe PDE as
reported in the following proposition.
174                                                        DERIVATIVES ANALYTICS WITH PYTHON


Proposition 8 (BCC97 PDE). A European call option C(S, v, r, t) must satisfy in the general
market model the PDE

                              1 2 ùúï2C                  ùúïC              ùúï2C
                                vS       + [r ‚àí rJ ]S     + ùúåùúév vS           +
                              2      ùúïS                ùúïS             ùúïSùúïv
                                              1 ùúï2C                     ùúïC
                                           + ùúév2 2 + ùúÖv [ùúÉv ‚àí v]             +
                                              2 ùúïv                       ùúïv
                                 1 ùúï2C                   ùúïC ùúïC
                              + ùúér2 2 + ùúÖr [ùúÉr ‚àí r]          +        ‚àí rC +
                                 2 ùúïr                    ùúïr      ùúït
                  +ùúÜEQ [C(K, T; (1 + J)S, v, r, t) ‚àí C(K, T; S, v, r, t‚àí )] = 0         (9.8)

with suitable boundary conditions and in particular CT (ST , K) = max[ST ‚àí K, 0] as the inner
value of the call option at maturity T.



Proof.   Consider a contingent claim A(S, v, r, t) and apply proposition 9 to it

                                 ùúïA                         ùúïA
                 dA(S, v, r, t) =   (mdt + vdZ 1 + jdN) +       (mdt + vdZ 2 )
                                 ùúïS                          ùúïv
                                   ùúïA                   ùúï2A
                                 +    (mdt + vdZ 3 ) +       vvùúådt
                                   ùúïr(                  ùúïSùúïv            )
                                   1 ùúï 2 A 2 ùúï 2 A 2 ùúï 2 A 2 ùúïA
                                 +          v  +      v  +      v  +       dt
                                   2 ùúïS2          ùúïv2       ùúïr2      ùúït
                                 (
                                   ùúïA      ùúïA       ùúïA      1 ùúï2 A 2
                               =      m+       m+       m+         v
                                   ùúïS      ùúïv       ùúïr      2 ùúïS2
                                                                           )
                                   1 ùúï2A 2 1 ùúï2A 2          ùúï2A        ùúïA
                                 +       v   +        v  +       vvùúå +        dt
                                   2 ùúïv2       2 ùúïr2       ùúïSùúïv         ùúït
                                   ùúïA          ùúïA          ùúïA
                                 +    vdZ 1 +     vdZ 2 +     vdZ 3
                                   ùúïS          ùúïv          ùúïr
    Next, replace drift, volatility and jump terms by their counterparts from BCC97 (omitting
time subscripts)

                                         m = (r ‚àí rJ )S
                                         m = ùúÖv (ùúÉv ‚àí v)
                                         m = ùúÖr (ùúÉr ‚àí r)
                                             ‚àö
                                         v = vS
                                                ‚àö
                                         v = ùúév v
                                                ‚àö
                                         v = ùúér r
                                          j = JS

The PDE (9.8) follows from taking expectation EQ (dA) under the risk-neutral probability
measure Q of the incremental change of the derivative asset‚Äôs value
General Model Framework                                                                              175

                                     (
                                       ùúïA
             EQ (dA(S, v, r, t)) =        (r ‚àí rJ )S + ùúÜEQ (A((1 + J)S, t) ‚àí A(S, t‚àí ))
                                       ùúïS
                                        ùúïA               ùúïA
                                     +     ùúÖ (ùúÉ ‚àí v) +      ùúÖ (ùúÉ ‚àí r)
                                        ùúïv v v           ùúïr r r
                                        1 ùúï2 A 2 1 ùúï2A 2           1 ùúï2 A 2
                                     +        vS   +       ùúé   v +       ùúé r
                                        2 ùúïS2        2 ùúïv2   v     2 ùúïr2 r
                                                           )
                                         ùúï2 A          ùúïA
                                     +        ùúé vSùúå +        dt
                                        ùúïSùúïv v          ùúït

and noting that under risk-neutrality EQ (dA) = rAdt must hold. Dividing by dt, replacing A by
C for the European call option and rearranging yields the PDE (9.8).

    A solution to the central equation (9.8) is

                  Ct (K, T) = St ‚ãÖ Œ†1 (T; S, v, r, t) ‚àí Bt (T) ‚ãÖ K ‚ãÖ Œ†2 (T; S, v, r, t)             (9.9)

where for j = 1, 2
                                                       [ ‚àíiu log(K)                       ]
                                  1 1
                                              ‚àû         e           ùúëj (T; S, v, r, t; u)
              Œ†j (T; S, v, r, t) = +              Re                                          du
                                  2 ùúã ‚à´0                               iu

The ùúëj are characteristic functions as defined in the appendix of BCC97 and Re[x] gives the
real part of x. In what follows, formula (9.9) plays essentially no role. It is nevertheless given
here for reasons of completeness and its resemblance to the famous BSM formula‚Äîwhich is
remarkable since the model of BCC97 is much richer.


9.5.2 Transform Methods
The key to the application of the Fourier transform methods of Lewis (2001) and Carr and
Madan (1999) is knowledge of the characteristic function of the stochastic processes governing
the evolution of the underlying. Chapter 8 illustrates this for the jump-diffusion model of M76
whose jump part is also a component of the general framework. However, the basic processes
are those of H93.
     The characteristic function ùúëH93
                                   0
                                       of the H93 stochastic volatility model is given by (cf.
Heston (1993) or Gatheral (2006), ch. 2)

                                  ùúëH93
                                   0
                                       (u, T) = eH1 (u,T)+H2 (u,T)v0                               (9.10)

with the following definitions

                  c1 ‚â° ùúÖv ùúÉv
                        ‚àö
                  c2 ‚â° ‚àí (ùúåùúév ui ‚àí ùúÖv )2 ‚àí ùúév2 (‚àíui ‚àí u2 )
                         ùúÖv ‚àí ùúåùúév ui + c2
                  c3 ‚â°
                         ùúÖv ‚àí ùúåùúév ui ‚àí c2
    176                                                         DERIVATIVES ANALYTICS WITH PYTHON


                                           {                                [              ]}
                                       c1                                     1 ‚àí c3 ec2 T
               H1 (u, T) ‚â° r0,T uiT +        (ùúÖ v ‚àí ùúåùúév  ui + c2 )T ‚àí 2 log
                                       ùúév2                                      1 ‚àí c3
                                              [              ]
                             ùúÖv ‚àí ùúåùúév ui + c2 1 ‚àí e 2  c  T
               H2 (u, T) ‚â°
                                    ùúév2         1 ‚àí c3 ec2 T

    and all variables as defined as before. In H1 we set r0,T = ‚àí log(B0 (T))‚àïT where we get B0 (T)
    from equations (9.4)‚Äì(9.7) for the CIR85 model.
         For the M76 model we already know the characteristic function ùúëM76 0
                                                                               (u, T); see equations
    (6.14) and (6.15). These have to be adjusted since only the jump part (and not the diffusive
    part) is needed here:
                                              ((                             ) )
                                                   iuùúî + ùúÜ(eiuùúáJ ‚àíu ùõø ‚àï2 ‚àí 1) T
                                                                   2 2
                         ùúëM76J
                          0
                               (u, T) = exp                                                     (9.11)

    where the risk-neutral drift term ùúî now takes the form

                                          ùúî = ‚àíùúÜ(eùúáJ +ùõø ‚àï2 ‚àí 1)
                                                          2
                                                                                                (9.12)

        Due to zero correlation between the H93 index part and the index jump component, the
    characteristic function for the BCC97 model is obtained by simple multiplication as

                                   ùúëBCC97
                                    0
                                          (u, T) = ùúëH93
                                                    0
                                                        ‚ãÖ ùúëM76J
                                                           0
                                                                (u, T)                          (9.13)

    Sub-section 9.7.3 provides a Python script that implements the Lewis formula (6.5) for the
    BCC97 model and the sub-models H93 and M76.


    9.5.3 Monte Carlo Simulation
    Monte Carlo simulation is a rather flexible valuation approach which is capable of much
    more than already seen in Chapters 7 and 8. It is applicable to almost any feature a financial
    product can exhibit: American and Bermudan exercise, Asian and lookback features (i.e. path
    dependency), multiple underlyings (i.e. a basket, for example) or simultaneous dependence on
    stock indices and interest rates (i.e. hybrid products). For a given financial model, Glasserman
    (2004), p. 30, gives the simplified recipe as replicated in Algorithm 4 for the risk-neutral
    valuation of a derivative asset with European exercise via Monte Carlo simulation.


    Algorithm 4: General Monte Carlo Algorithm
1 replace the drift of the given dynamics (SDE) of the underlying with the risk-free short rate
2 discretize the risk-neutral continuous time dynamics to obtain difference equations in
  discrete time
3 simulate (sufficient) paths
4 determine the payoffs of the derivative asset for each path at maturity
5 discount the payoffs with the appropriate discount factor
6 calculate the average of the discounted payoffs over all paths
General Model Framework                                                                       177


     Subsequent chapters show how to apply this recipe to different parametrizations of the
general framework. Previous chapters apply Monte Carlo simulation only to quite simple
settings, i.e. BSM and M76, where exact discretizations are available in simple forms. However,
as will become apparent, the simulation of the H93 model is a particularly tricky task with
regard to the discretization step of Algorithm 4. Therefore, Chapter 10 devotes considerable
attention to this topic. In that chapter, both European options and American options are valued
for a number of different parametrizations for both the market model and the Monte Carlo
simulation setup.


9.6 CONCLUSIONS

This chapter provides a general market model which is capable of addressing the major market
risks affecting equity derivatives: index risk, volatility risk, jump risk and short rate risk. The
following chapters will build on this foundation and will simulate the model, calibrate it and
use it to value European and American options in a market-consistent manner. It will also
be shown how to use numerical procedures to implement dynamic delta hedging strategies in
this model.


9.7 PROOFS AND PYTHON SCRIPTS

9.7.1 It oÃÇ‚Äôs Lemma

Proposition 9 (ItoÃÇ‚Äôs Lemma). Let f : R4 ‚Üí R be a twice continuously differentiable function
and S, v, r be (jump) diffusions

                                         dSt = mt dt + vt dZt1 + jt dNt                     (9.14)
                                        dvt = mt dt + vt dZt2                               (9.15)
                                        drt = mt dt + vt dZt3                               (9.16)
                                  dZt1 dZt2 ‚â° ùúådt
                                dZt3 dZtn‚â†3 ‚â° 0                                             (9.17)
                                  dNt dZtn ‚â° 0                                              (9.18)

with Z n standard Brownian motions and N a Poisson process. Then for f (S, v, r, t) the marginal
change in time is (omitting time subscripts)

                                       ùúïf      ùúïf    ùúïf
                   df (S, v, r, t) =      dS + dv + dr
                                       ùúïS      ùúïv    ùúïr
                                           (                       )
                                         1 ùúï2f 2 ùúï2f 2 ùúï2f 2    ùúïf
                                       +        v + 2v + 2v + 2      dt
                                         2 ùúïS2      ùúïv  ùúïr      ùúït
                                          ùúï2f
                                       +      vvùúådt                                         (9.19)
                                         ùúïSùúïv
178                                                          DERIVATIVES ANALYTICS WITH PYTHON


Proof. First, a Taylor series expansion up to second order yields (suppressing dt2 terms and
other terms of equal or smaller order as well as accounting for the respective zero correlations
(9.17) and (9.18))

                                         ùúïf      ùúïf      ùúïf        ùúïf
                     df (S, v, r, t) =      dS + dv + dr + dt
                                         ùúïS      ùúïv      ùúïr        ùúït
                                             ( 2                            )
                                           1   ùúï f   2   ùúï 2f
                                                                 2    ùúï2f 2
                                         +         dS + 2 dv + 2 dr
                                           2 ùúïS2         ùúïv           ùúïr
                                             ( 2                         )
                                           1 ùúï f              ùúï f
                                                               2
                                         +          dSdv +         dvdS                  (9.20)
                                           2 ùúïSùúïv           ùúïvùúïS

Second, the assumptions about f ensure that the mixed partial derivatives are the same. Third,
it holds

                                              dS2 = v2 dt
                                                     2
                                              dv2 = v dt
                                              dr2 = v2 dt
                                             dSdv = vvùúådt

Substituting these terms and (9.14)‚Äì(9.16) in (9.20) gives (9.19) after rearranging. See also
Brandimarte (2006), pp. 97‚Äì102.




9.7.2 Python Script for Bond Valuation

#
# Valuation of Zero-Coupon Bonds
# in Cox-Ingersoll-Ross (1985) Model
# 09_gmm/CIR_zcb_valuation.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np

#
# Example Parameters CIR85 Model
#
kappa_r, theta_r, sigma_r, r0, T = 0.3, 0.04, 0.1, 0.04, 1.0


#
# Zero-Coupon Bond Valuation Formula
#
General Model Framework                                                   179


def gamma(kappa_r, sigma_r):
    ''' Help Function. '''
    return math.sqrt(kappa_r ** 2 + 2 * sigma_r ** 2)



def b1(alpha):
    ''' Help Function. '''
    kappa_r, theta_r, sigma_r, r0, T = alpha
    g = gamma(kappa_r, sigma_r)
    return (((2 * g * math.exp((kappa_r + g) * T / 2)) /
            (2 * g + (kappa_r + g) * (math.exp(g * T) - 1)))
              ** (2 * kappa_r * theta_r / sigma_r ** 2))


def b2(alpha):
    ''' Help Function. '''
    kappa_r, theta_r, sigma_r, r0, T = alpha
    g = gamma(kappa_r, sigma_r)
    return ((2 * (math.exp(g * T) - 1)) /
              (2 * g + (kappa_r + g) * (math.exp(g * T) - 1)))


def B(alpha):
    ''' Function to value unit zero-coupon bonds in Cox-Ingersoll-Ross (1985)
    model.

    Parameters
    ==========
    r0: float
        initial short rate
    kappa_r: float
        mean-reversion factor
    theta_r: float
        long-run mean of short rate
    sigma_r: float
        volatility of short rate
    T: float
        time horizon/interval


    Returns
    =======
    zcb_value: float
        zero-coupon bond present value
    '''
    b_1 = b1(alpha)
    b_2 = b2(alpha)
    kappa_r, theta_r, sigma_r, r0, T = alpha
    return b_1 * math.exp(-b_2 * r0)
180                                             DERIVATIVES ANALYTICS WITH PYTHON


if _ _name_ _ == '_ _main_ _':
    #
    # Example Valuation
      #
      B0T = B([kappa_r, theta_r, sigma_r, r0, T])
          # discount factor, ZCB value
      print "ZCB Value   %10.4f" % B0T




9.7.3 Python Script for European Call Valuation

#
# Valuation of European Call and Put Options
# Under Stochastic Volatility and Jumps
# 09_gmm/BCC_option_valuation.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import numpy as np
from scipy.integrate import quad
from CIR_zcb_valuation import B
import warnings
warnings.simplefilter('ignore')


#
# Example Parameters B96 Model
#
## H93 Parameters
kappa_v = 1.5
theta_v = 0.02
sigma_v = 0.15
rho = 0.1
v0 = 0.01

## M76 Parameters
lamb = 0.25
mu = -0.2
delta = 0.1
sigma = np.sqrt(v0)

## General Parameters
S0 = 100.0
K = 100.0
T = 1.0
r = 0.05
General Model Framework                                                   181


#
# Valuation by Integration
#


def BCC_call_value(S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0,
                         lamb, mu, delta):
    ''' Valuation of European call option in B96 Model via Lewis (2001)
    Fourier-based approach.

    Parameters
    ==========
    S0: float
        initial stock/index level
    K: float
        strike price
    T: float
        time-to-maturity (for t=0)
    r: float
        constant risk-free short rate
    kappa_v: float
        mean-reversion factor
    theta_v: float
        long-run mean of variance
    sigma_v: float
        volatility of variance
    rho: float
        correlation between variance and stock/index level
    v0: float
        initial level of variance
    lamb: float
        jump intensity
    mu: float
        expected jump size
    delta: float
         standard deviation of jump

    Returns
    =======
    call_value: float
        present value of European call option


    '''
    int_value = quad(lambda u: BCC_int_func(u, S0, K, T, r, kappa_v, theta_v,
                sigma_v, rho, v0, lamb, mu, delta), 0, np.inf, limit=250)[0]
    call_value = max(0, S0 - np.exp(-r * T) * np.sqrt(S0 * K)
                            / np.pi * int_value)
    return call_value
182                                               DERIVATIVES ANALYTICS WITH PYTHON


def H93_call_value(S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0):
    ''' Valuation of European call option in H93 model via Lewis (2001)
    Fourier-based approach.

      Parameters
      ==========
      S0: float
          initial stock/index level
      K: float
          strike price
      T: float
          time-to-maturity (for t=0)
      r: float
          constant risk-free short rate
      kappa_v: float
          mean-reversion factor
      theta_v: float
          long-run mean of variance
      sigma_v: float
          volatility of variance
      rho: float
          correlation between variance and stock/index level
      v0: float
          initial level of variance

      Returns
      =======
      call_value: float
          present value of European call option


      '''
      int_value = quad(lambda u: H93_int_func(u, S0, K, T, r, kappa_v,
                          theta_v, sigma_v, rho, v0), 0, np.inf, limit=250)[0]
      call_value = max(0, S0 - np.exp(-r * T) * np.sqrt(S0 * K)
                              / np.pi * int_value)
      return call_value


def M76_call_value(S0, K, T, r, v0, lamb, mu, delta):
    ''' Valuation of European call option in M76 model via Lewis (2001)
    Fourier-based approach.


      Parameters
      ==========
      S0: float
          initial stock/index level
      K: float
          strike price
General Model Framework                                                     183


    T: float
        time-to-maturity (for t=0)
    r: float
        constant risk-free short rate
    lamb: float
        jump intensity
    mu: float
        expected jump size
    delta: float
         standard deviation of jump

    Returns
    =======
    call_value: float
        present value of European call option
    '''
    sigma = np.sqrt(v0)
    int_value = quad(lambda u: M76_int_func_sa(u, S0, K, T, r,
                        sigma, lamb, mu, delta), 0, np.inf, limit=250)[0]
    call_value = max(0, S0 - np.exp(-r * T) * np.sqrt(S0 * K)
                             / np.pi * int_value)
    return call_value



#
# Integration Functions
#



def BCC_int_func(u, S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0,
                            lamb, mu, delta):
    ''' Valuation of European call option in BCC97 model via Lewis (2001)
    Fourier-based approach: integration function.


    Parameter definitions see function BCC_call_value.'''
    char_func_value = BCC_char_func(u - 1j * 0.5, T, r, kappa_v, theta_v,
                        sigma_v, rho, v0, lamb, mu, delta)
    int_func_value = 1 / (u ** 2 + 0.25) \
            * (np.exp(1j * u * np.log(S0 / K)) * char_func_value).real
    return int_func_value



def H93_int_func(u, S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0):
    ''' Valuation of European call option in H93 model via Lewis (2001)
    Fourier-based approach: integration function.


    Parameter definitions see function H93_call_value.'''
184                                             DERIVATIVES ANALYTICS WITH PYTHON


      char_func_value = H93_char_func(u - 1j * 0.5, T, r, kappa_v,
                                      theta_v, sigma_v, rho, v0)
      int_func_value = 1 / (u ** 2 + 0.25) \
              * (np.exp(1j * u * np.log(S0 / K)) * char_func_value).real
      return int_func_value



def M76_int_func_sa(u, S0, K, T, r, sigma, lamb, mu, delta):
    ''' Valuation of European call option in M76 model via Lewis (2001)
      Fourier-based approach: integration function.

      Parameter definitions see function M76_call_value.'''
      char_func_value = M76_char_func_sa(u - 0.5 * 1j, T, r, sigma,
                                          lamb, mu, delta)
      int_func_value = 1 / (u ** 2 + 0.25) \
              * (np.exp(1j * u * np.log(S0 / K)) * char_func_value).real
      return int_func_value


#
# Characteristic Functions
#



def BCC_char_func(u, T, r, kappa_v, theta_v, sigma_v, rho, v0,
                    lamb, mu, delta):
    ''' Valuation of European call option in BCC97 model via Lewis (2001)
      Fourier-based approach: characteristic function.

      Parameter definitions see function BCC_call_value.'''
      BCC1 = H93_char_func(u, T, r, kappa_v, theta_v, sigma_v, rho, v0)
      BCC2 = M76_char_func(u, T, lamb, mu, delta)
      return BCC1 * BCC2



def H93_char_func(u, T, r, kappa_v, theta_v, sigma_v, rho, v0):
    ''' Valuation of European call option in H93 model via Lewis (2001)
    Fourier-based approach: characteristic function.


      Parameter definitions see function BCC_call_value.'''
      c1 = kappa_v * theta_v
      c2 = -np.sqrt((rho * sigma_v * u * 1j - kappa_v)
              ** 2 - sigma_v ** 2 * (-u * 1j - u ** 2))
      c3 = (kappa_v - rho * sigma_v * u * 1j + c2) \
            / (kappa_v - rho * sigma_v * u * 1j - c2)
      H1 = (r * u * 1j * T + (c1 / sigma_v ** 2)
            * ((kappa_v - rho * sigma_v * u * 1j + c2) * T
                  - 2 * np.log((1 - c3 * np.exp(c2 * T)) / (1 - c3))))
General Model Framework                                                     185


    H2 = ((kappa_v - rho * sigma_v * u * 1j + c2) / sigma_v ** 2
          * ((1 - np.exp(c2 * T)) / (1 - c3 * np.exp(c2 * T))))
    char_func_value = np.exp(H1 + H2 * v0)
    return char_func_value


def M76_char_func(u, T, lamb, mu, delta):
    ''' Valuation of European call option in M76 model via Lewis (2001)
    Fourier-based approach: characteristic function.


    Parameter definitions see function M76_call_value.'''
    omega = -lamb * (np.exp(mu + 0.5 * delta ** 2) - 1)
    char_func_value = np.exp((1j * u * omega + lamb
            * (np.exp(1j * u * mu - u ** 2 * delta ** 2 * 0.5) - 1)) * T)
    return char_func_value


def M76_char_func_sa(u, T, r, sigma, lamb, mu, delta):
    ''' Valuation of European call option in M76 model via Lewis (2001)
    Fourier-based approach: characteristic function "jump component".


    Parameter definitions see function M76_call_value.'''
    omega = r - 0.5 * sigma ** 2 - lamb * (np.exp(mu + 0.5 * delta ** 2) - 1)
    char_func_value = np.exp((1j * u * omega - 0.5 * u ** 2 * sigma ** 2
                + lamb * (np.exp(1j * u * mu - u ** 2 * delta ** 2 * 0.5)
                    - 1)) * T)
    return char_func_value


if _ _name_ _ == '_ _main_ _':
    #
    # Example Parameters CIR85 Model
    #
    kappa_r, theta_r, sigma_r, r0, T = 0.3, 0.04, 0.1, 0.04, T
    B0T = B([kappa_r, theta_r, sigma_r, r0, T]) # discount factor
    r = -np.log(B0T) / T


    #
    # Example Values
    #
    print "M76 Value      %10.4f" \
         % M76_call_value(S0, K, T, r, v0, lamb, mu, delta)
    print "H93 Value   %10.4f" \
        % H93_call_value(S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0)
    print "BCC97 Value %10.4f" \
         % BCC_call_value(S0, K, T, r, kappa_v, theta_v,
                            sigma_v, rho, v0, lamb, mu, delta)
                                                                       CHAPTER         10
                                             Monte Carlo Simulation


10.1 INTRODUCTION

Monte Carlo simulation is among the most important numerical algorithms of the 20th century
(cf. Cipra (2000)) and obviously will remain so in the 21st century as well. Its importance for
financial applications stems from the fact that it is most flexible in terms of financial products
that can be valued. First applied to European option pricing in 1977 by Phelim Boyle (cf.
Boyle (1977)), it took until the 21st century for the problem of valuing American options by
Monte Carlo simulation to be satisfactorily solved by Francis Longstaff and Eduardo Schwartz
(cf. Longstaff and Schwartz (2001)) and others (cf. Chapter 7). Glasserman (2004) provides
a comprehensive introduction to Monte Carlo methods for financial engineering and is a
standard reference. Kohler (2009) is a survey article of regression-based valuation approaches
for American options.
     Although quite flexible, Monte Carlo simulation is generally not very fast (relative to
alternative approaches) since millions of computations are necessary to value a single option.
Consider a simulation run with 100 time intervals (=100 exercise dates) and 100,000 paths
for an American put option on a single stock with constant volatility and constant short rate.
You need 10 million random numbers, several arrays (i.e. matrices) of size 101 times 100,000
and you have to estimate 100 least-squares regressions over 100,000 pairs of numbers as well
as discounting 100 times 100,000 numbers. If you enrich the financial model to include, for
example, stochastic volatility and stochastic interest rates the number of necessary calculations
further increases substantially.
     For practical purposes, it is important to have available efficient, i.e. accurate and fast,
algorithms to value options and other derivatives by Monte Carlo simulation. This chapter
therefore analyzes in detail the simulation of financial models of type (9.1)‚Äì(9.3) as presented
in the previous chapter. The simulation of equation (9.1) turns out be straightforward since
an exact discretization is easily found. However, this is not the case for the two square-root
diffusions (9.2) and (9.3).
     The chapter proceeds as follows. Section 10.2 values zero-coupon bonds in the CIR85
model by Monte Carlo simulation. Here, we only need to consider a single square-root diffu-
sion. Section 10.3 values European options by Monte Carlo simulation in the H93 stochastic
volatility model with constant short rate and without jumps. Section 10.4 then adds stochastic
short rates of CIR85 type to the H93 setting to value American put options by Monte Carlo
simulation. Section 10.5 summarizes the major findings.


                                                                                             187
188                                                          DERIVATIVES ANALYTICS WITH PYTHON


10.2 VALUATION OF ZERO-COUPON BONDS

In this section, we consider the stochastic short rate model ÓàπCIR85 of Cox-Ingersoll-Ross
(cf. Cox et al. (1985)) which is given by the SDE (9.3). We repeat the SDE for convenience:
                                                           ‚àö
                                 drt = ùúÖr (ùúÉr ‚àí rt )dt + ùúér rt dZt

     To simulate the short rate model, it has to be discretized. To this end, we again divide
the given time interval [0, T] in equidistant sub-intervals of length Œît such that now t ‚àà
{0, Œît, 2Œît, ..., T}, i.e. there are M + 1 points in time with M ‚â° T‚àïŒît.
     The exact transition law of the square-root diffusion is known. The article by Broadie
and Kaya (2006) provides an in-depth analysis of this topic. Consider the general square-root
diffusion process
                                                        ‚àö
                                  dxt = ùúÖ(ùúÉ ‚àí xt )dt + ùúé xt dZt                             (10.1)

In Broadie and Kaya (2006) it is shown that xt , given xs with s = t ‚àí Œît, is distributed according
to
                                  (         )       (                     )
                              ùúé 2 1 ‚àí e‚àíùúÖŒît ‚Ä≤ 2           4ùúÖe‚àíùúÖŒît
                       xt =                    ùúíd                      xs
                                    4ùúÖ                ùúé 2 (1 ‚àí e‚àíùúÖŒît )
        ‚Ä≤
where ùúíd2 denotes a non-central chi-squared distributed random variable with

                                                    4ùúÉùúÖ
                                               d=
                                                     ùúé2

degrees of freedom and non-centrality parameter

                                               4ùúÖe‚àíùúÖŒît
                                      l=                    xs
                                           ùúé 2 (1 ‚àí e‚àíùúÖŒît )

For implementation purposes, it may be convenient to sample a chi-squared distributed random
                                                        ‚Ä≤
variable ùúíd2 instead of a non-central chi-squared one, ùúíd2 . If d > 1, the following relationship
holds true

                                   ‚Ä≤
                                           (   ‚àö )2
                                  ùúíd2 (l) = z + l + ùúíd‚àí1
                                                     2



where z is an independent standard normally distributed random variable. Similarly, if d ‚â§ 1,
one has
                                           ‚Ä≤
                                         ùúíd2 (l) = ùúíd+2N
                                                    2


where N is now a Poisson-distributed random variable with intensity l‚àï2. For an algorithmic
representation of this simulation scheme refer to Glasserman (2004), p. 124.
Monte Carlo Simulation                                                                           189


     The exactness comes with a relatively high computational burden which may, however,
be justified by higher accuracy due to faster convergence. In other words, although the com-
putational burden per simulated value of xt may be relatively high with the exact scheme, the
possible reduction in necessary time steps and simulation paths may more than compensate
for this. However, Andersen, JaÃàckel and Kahl argue in Andersen et al. (2010)‚Äîreferring to
the exact simulation approach of Broadie and Kaya (2006)‚Äîthat

      ‚ÄúOne might think that the existence of an exact simulation-scheme ‚Ä¶ would settle
      once and for all the question of how to generate paths of the square-root process.‚Ä¶,
      it seems [nevertheless] reasonable to also investigate the application of simpler sim-
      ulation algorithms. These will typically exhibit a bias for finite values of [M], but
      convenience and speed may more than compensate for this, ‚Ä¶‚Äù

    We therefore also consider a Euler discretization of the square-root diffusion (10.1). A
possible discretization is given by
                                                              ‚àö             ‚àö
                      xÃÉ t = xÃÉ s + ùúÖ(ùúÉ ‚àí max[0, xÃÉ s ])Œît + ùúé max[0, xÃÉ s ] Œîtzt              (10.2)



                                           xt = max[0, xÃÉ s ]                                  (10.3)

with zt standard normal (this scheme is usually called Full Truncation, see below). While xt
cannot reach zero with the exact scheme if the Feller condition 2ùúÖùúÉ > ùúé 2 is met, this is not
the case with the Euler scheme. Therefore, the maximum function is applied several times.1
     The plan now is as follows. We simulate the CIR85 model and derive Monte Carlo
simulation estimates for Zero-Coupon Bond (ZCB) values at different points in time. Since we
know these values in closed form in the CIR85 model, we have a natural benchmark to check
the accuracy of the Monte Carlo simulation implementation. Chapter 9 presents the respective
formula for the present value of the ZCB, i.e. for t = 0. Sub-section 10.6.1 contains a Python
implementation which allows us to freely choose 0 < t ‚â§ T. Two adjustments are made:

    1. The final date T is replaced by time-to-maturity T ‚àí t
    2. The initial rate r0 is replaced by the expectation

                                       E(rt ) = ùúÉr + e‚àíùúÖr t (r0 ‚àí ùúÉr )

     Figure 10.1 shows 20 simulated paths for the short rate process of CIR85 and for the
example parameters of the Python script of sub-section 10.6.2. A Monte Carlo simulation
estimator for the value of the ZCB at t is derived as follows. Consider a certain path i of the
I simulated paths for the short rate process with time grid t ‚àà {0, Œît, 2Œît, ..., T}. We discount


1
 There are number of alternative Euler schemes available which section 10.3 presents and compares with
regard to their performance, i.e. accuracy and speed.
190                                                           DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 10.1     Twenty simulated paths for the CIR85 short rate process


the terminal value of the ZCB, i.e. 1.0, step by step backwards. For t < T and s ‚â° t ‚àí Œît we
have
                                                     rt +rs
                                       Bs,i = Bt,i e‚àí 2 Œît

      The Monte Carlo simulation estimator of the ZCB value at t then is

                                                 1‚àë
                                                     I
                                       BMCS =         B
                                        t        I i=1 t,i

     Figures 10.2 and 10.3 present valuation results for both the exact scheme and the Euler
scheme compared, respectively, to the analytical values for a ZCB maturing at T = 2. The
figures illustrate that with M = 50 time steps and I = 50,000 paths both schemes deliver Monte
Carlo simulation estimates really close to the analytical values. However, the Euler scheme
shows a systematically low bias in this particular case. The errors for the exact scheme are not
only smaller but also negative as well as positive.
     In terms of speed, the Euler scheme is indeed much faster. The generation of I = 50,000
sample paths with M = 50 time steps takes only about one-quarter of the time with the Euler
scheme compared to the exact scheme. As a consequence, one could, for example, double the
number of time steps to M = 100 to increase accuracy of the Euler scheme.
     These numbers and comparisons are illustrative only. They are by no means a ‚Äúproof‚Äù
that the exact scheme easily outperforms a Euler scheme. The subsequent section revisits this
issue in the context of the stochastic volatility model of H93‚Äîin this case we need to correlate
the square-root diffusion with a second process which introduces a new problem area.
FIGURE 10.2 Values for a ZCB maturing at T = 2; line = analytical values, dots = Monte Carlo
simulation estimates from the exact scheme for M = 50 and I = 50,000




FIGURE 10.3 Values for a ZCB maturing at T = 2; line = analytical values, dots = Monte Carlo
simulation estimates from the Euler scheme for M = 50 and I = 50,000
192                                                                  DERIVATIVES ANALYTICS WITH PYTHON



10.3 VALUATION OF EUROPEAN OPTIONS

As the next special case of the general framework ÓàπBCC97 with risk-neutral dynamics given
by (9.1)‚Äì(9.3), we consider the H93 stochastic volatility model ÓàπH93 with constant short rate.
This section values European call and put options in this model by Monte Carlo simulation. As
for the ZCB values, we also have available a (semi-analytical) pricing formula which generates
natural benchmark values against which to compare the Monte Carlo simulation estimates.
     For 0 ‚â§ t ‚â§ T, the risk-neutral dynamics of the index in the H93 stochastic volatility
model are given by
                                                            ‚àö
                                           dSt = rSt dt +    vt St dZt1                         (10.4)

with the variance following the square-root diffusion
                                                                ‚àö
                                      dvt = ùúÖv (ùúÉv ‚àí vt )dt + ùúév vt dZt2                        (10.5)

The two Brownian motions are instantaneously correlated with dZt1 dZt2 = ùúå. This correlation
introduces a new problem dimension into the discretization for simulation purposes (cf. Broadie
and Kaya (2006)). To avoid problems arising from correlating normally distributed increments
(of S) with chi-squared distributed increments (of v), we consider in the following only Euler
schemes for both the S and v processes. This has the advantage that the increments of v become
normally distributed as well and can therefore be easily correlated with the increments of S.
     In total, we consider two discretization schemes for S and seven discretization schemes
for v. For S, we consider the exact log Euler scheme with
                                                               ‚àö ‚àö
                                                                         Œîtz1t
                                         St = Ss e(r‚àívt ‚àï2)Œît+ vt                               (10.6)

where s ‚â° t ‚àí Œît and z1t standard normal. This scheme is obtained by considering the dynamics
of log St and applying ItoÃÇ‚Äôs lemma to it. For illustration purposes, we also consider the naive
Euler discretization (with s ‚â° t ‚àí Œît)
                                               (      ‚àö ‚àö       )
                                        St = Ss erŒît + vt Œîtz1t                                 (10.7)

     These schemes can be combined with any of the following Euler schemes for the square-
root diffusion.2

        Full Truncation
                                                                         ‚àö        ‚àö
                                     xÃÉ t = xÃÉ s + ùúÖ(ùúÉ ‚àí xÃÉ s+ )Œît + ùúé       xÃÉ s+ Œîtzt
                                     xt = xÃÉ t+




2
    In the following, x+ is notation for max[x, 0].
Monte Carlo Simulation                                                                       193


     Partial Truncation
                                                                    ‚àö         ‚àö
                                xÃÉ t = xÃÉ s + ùúÖ(ùúÉ ‚àí xÃÉ s )Œît + ùúé         xÃÉ s+ Œîtzt
                                xt = xÃÉ t+

     Truncation
                                                            ‚àö ‚àö
                           xt = max[0, xs + ùúÖ(ùúÉ ‚àí xs )Œît + ùúé xs Œîtzt ]

     Reflection
                                                                         ‚àö          ‚àö
                             xÃÉ t = ||xÃÉ s || + ùúÖ(ùúÉ ‚àí ||xÃÉ s ||)Œît + ùúé       |xÃÉ s | Œîtzt
                                                                             | |
                             xt = ||xÃÉ t ||

     Higham-Mao
                                                                   ‚àö            ‚àö
                               xÃÉ t = xÃÉ s + ùúÖ(ùúÉ ‚àí xÃÉ s )Œît + ùúé          |xÃÉ s | Œîtzt
                                                                         | |
                               xt = ||xÃÉ t ||

     Simple Reflection

                                     |                     ‚àö ‚àö      |
                                xt = |xs + ùúÖ(ùúÉ ‚àí xs )Œît + ùúé xs Œîtzt |
                                     |                              |
     Absorption
                                                                     ‚àö         ‚àö
                               xÃÉ t = xÃÉ s+ + ùúÖ(ùúÉ ‚àí xÃÉ s+ )Œît + ùúé         xÃÉ s+ Œîtzt
                               xt = xÃÉ t+

     This list contains only Euler schemes and is not exhaustive with regard to discretization
schemes for the square-root diffusion (cf. Andersen et al. (2010), Andersen (2008), Broadie
and Kaya (2006), Glasserman (2004) and Haastrecht and Pelsser (2010)). However, all these
schemes share the convenient feature that correlation of the variance square-root diffusion
with the index process is easily accomplished.
     In the literature, there are a lot of tests and numerical studies available that compare
efficiency of different discretization schemes. But since the approach of this book is a practical
one, we want to implement our own test and comparison procedures. Moreover, we want to
use Python in combination with the data management and analysis library pandas to automate
our tests.
     For our tests, we take four different parametrizations for the H93 model as found in
Medvedev and Scaillet (2010), table 3. In these four model economies, we value the following:
   options: European call and put options
  
                               1
    maturities: we take T ‚àà { 12 , 1, 2}
   strikes: we take K ‚àà {90, 100, 110} for S = 100
                                             0
   time steps: we take M ‚àà {25, 50} steps per year
194                                                     DERIVATIVES ANALYTICS WITH PYTHON


     paths: we take I ‚àà {25,000, 50,000, 75,000, 100,000}
     discretization: we combine all schemes (two for index with seven for variance = 14
      schemes)

    This makes a total of 36 option values per option type. In view of the empirical results
about option spreads and tick sizes, as presented in section 3.5, we say that a valuation is
accurate if

 1. the absolute value difference is smaller than 2.5 cents or
 2. the absolute value difference is smaller than 1.5%

     To improve upon valuation accuracy, we use both moment matching and antithetic paths
for our Python implementation found in sub-section 10.6.3. This script writes all results into
a pandas DataFrame object and saves this in HDF5 format to disk (e.g. for later usage and
analysis).
     To generate antithetic paths (cf. Glasserman (2004), sec. 4.2), we use both the pseudo-
random number zt,i and its negative value ‚àízt,i (where we generate only I‚àï2 random numbers).
With regard to moment matching (cf. Glasserman (2004), sec. 4.5.), we correct the first two
moments of the pseudo-random numbers delivered by Python. The respective code for both
antithetic paths and moment matching looks like this:

def random_number_generator(M, I):
    if antipath:
        rand = np.random.standard_normal((2, M + 1, I / 2))
          rand = np.concatenate((rand, -rand), 2)
      else:
          rand = np.random.standard_normal((2, M + 1, I))
      if momatch:
          rand = rand / np.std(rand)
          rand = rand - np.mean(rand)
      return rand


    Depending on the time interval Œît used, the drift of the index level process may also show
a non-negligible bias (even after correction of the random numbers). We can correct the first
moment of the index level process in a fashion similar to the pseudo-random numbers:

for t in range(1, M + 1, 1):
        ran = np.dot(CM, rand[:, t])
        if momatch:
              bias = np.mean(np.sqrt(v[t]) * ran[row] * sdt)
          if s_disc == ‚ÄôLog‚Äô:
              S[t] = S[t - 1] * np.exp((r - 0.5 * v[t]) * dt +
                      np.sqrt(v[t]) * ran[row] * sdt - bias)
          elif s_disc == ‚ÄôNaive‚Äô:
              S[t] = S[t - 1] * (math.exp(r * dt) +
                        np.sqrt(v[t]) * ran[row] * sdt - bias)
Monte Carlo Simulation                                                                              195


TABLE 10.1 Valuation results for European call and put options in H93 model for parametrizations
from Medvedev and Scaillet (2010) and M0 = 50, I = 100,000. Performance yardsticks are
PY1 = 0.025 and PY1 = 0.015.a

OT        R         I        ID     XD       MM        AP       #ER      #OP         AE           MSE

CALL       5     100,000      L     A       False     False      146     180       0.07670      3.74152
CALL       5     100,000      L     A       False     True       146     180       0.07288      3.75574
CALL       5     100,000      L     A       True      False        3     180       0.00633      0.00136
CALL       5     100,000      L     A       True      True         3     180       0.00468      0.00149
CALL       5     100,000      L     F       False     False      146     180       0.03556      3.63164
CALL       5     100,000      L     F       False     True       148     180       0.03462      3.62426
CALL       5     100,000      L     F       True      False        1     180      ‚àí0.01659      0.00113
CALL       5     100,000      L     F       True      True         1     180      ‚àí0.01299      0.00090
CALL       5     100,000      L     P       False     False      144     180       0.03942      3.68678
CALL       5     100,000      L     P       False     True       145     180       0.04079      3.64441
CALL       5     100,000      L     P       True      False        1     180      ‚àí0.01474      0.00108
CALL       5     100,000      L     P       True      True         1     180      ‚àí0.01128      0.00111
CALL       5     100,000      L     T       False     False      147     180       0.07196      3.72847
CALL       5     100,000      L     T       False     True       145     180       0.07256      3.74803
CALL       5     100,000      L     T       True      False        3     180       0.00340      0.00155
CALL       5     100,000      L     T       True      True         3     180       0.01147      0.00162
PUT        5     100,000      L     A       False     False      143     180       0.04343      0.93155
PUT        5     100,000      L     A       False     True       141     180       0.04284      0.93065
PUT        5     100,000      L     A       True      False       14     180       0.00445      0.00110
PUT        5     100,000      L     A       True      True        20     180       0.00657      0.00149
PUT        5     100,000      L     F       False     False      141     180       0.03198      0.94487
PUT        5     100,000      L     F       False     True       142     180       0.03797      0.94874
PUT        5     100,000      L     F       True      False        9     180      ‚àí0.01349      0.00068
PUT        5     100,000      L     F       True      True        10     180      ‚àí0.01379      0.00083
PUT        5     100,000      L     P       False     False      143     180       0.03593      0.96873
PUT        5     100,000      L     P       False     True       141     180       0.03330      0.94941
PUT        5     100,000      L     P       True      False        3     180      ‚àí0.00881      0.00041
PUT        5     100,000      L     P       True      True         5     180      ‚àí0.00987      0.00056
PUT        5     100,000      L     T       False     False      143     180       0.04830      0.92206
PUT        5     100,000      L     T       False     True       142     180       0.04231      0.92051
PUT        5     100,000      L     T       True      False       10     180       0.00687      0.00111
PUT        5     100,000      L     T       True      True        10     180       0.00445      0.00117
a
  Monte Carlo simulation values benchmarked against semi-analytical values from Fourier-based pricing
approach. The columns report the following values: OT = the option type (call or put), R = number
of valuation runs, I = number of paths per single option valuation, ID = (first letter of) discretization
scheme for index process, XD = (first letter of) discretization scheme for variance process, MM =
moment matching, AP = antithetic paths, #ER = number of errors out of #OP, #OP = number of options
valued, AE = average error over all valuations, MSE = mean squared error of all valuations.

    Table 10.1 reports valuation results for European call and put options with M0 = 50 and
I = 100,000. Here, M0 means steps per year. For example, if time-to-maturity is 2 years, we set
M = 2 ‚ãÖ M0 = 100. The table uses the exact scheme for the index process and combines this
with four different schemes for the variance process (Full Truncation, Partial Truncation,
Truncation and Absorption). It is evident that variance reduction techniques are indispensable
196                                                          DERIVATIVES ANALYTICS WITH PYTHON




      FIGURE 10.4     Boxplot of Monte Carlo valuation errors without and with moment
      matching

in this setting. While antithetic paths have no noticeable influence ceteris paribus, moment
matching significantly increases accuracy of the valuation process. Using moment matching
(with or without antithetic paths) the Full Truncation scheme shows the best overall perfor-
mance. However, for some configurations the Absorption scheme, for example, also performs
quite well. The average absolute valuation errors for the total set of 180 options when using
moment matching mainly range between 0.5 cents and 1 cent. The good performance of the
Full Truncation scheme is in line with results obtained in Lord et al. (2006) who name this
particular scheme as their winner.
     Figure 10.4 illustrates the importance of moment matching techniques in this context. The
correction effect moment matching has for Monte Carlo valuation is impressively illustrated
in that figure.
     Table 10.2 presents further valuation results. This time all possible combinations of the
discretization schemes are considered. Again, the Full Truncation scheme generates good
valuation results‚Äîand, which may come as a surprise, the naive discretization scheme for the
index process also performs relatively well throughout.


10.4 VALUATION OF AMERICAN OPTIONS

We now turn to American (put) options which are a little bit harder to value efficiently, i.e.
accurately and fast, by Monte Carlo simulation.3 The setup for this section is the H93 stochastic

3
 This section is mainly based on a 2011 working paper by the author titled ‚ÄúFast Monte Carlo Valuation
of American Options under Stochastic Volatility and Interest Rates.‚Äù The results of the paper were
presented at the EuroScipy 2011 conference in Paris.
Monte Carlo Simulation                                                                          197


TABLE 10.2 Valuation results for European call and put options in H93 model for parametrizations
from Medvedev and Scaillet (2010) and M0 = 50, I = 100,000. Performance yardsticks are
PY1 = 0.025 and PY1 = 0.015.a

OT        R         I       ID     XD      MM        AP      #ER      #OP         AE          MSE

CALL      5     100,000      L      A       True    True       3      180       0.00468      0.00149
CALL      5     100,000      L      F       True    True       1      180      ‚àí0.01299      0.00090
CALL      5     100,000      L      H       True    True       4      180       0.01169      0.00175
CALL      5     100,000      L      P       True    True       1      180      ‚àí0.01128      0.00111
CALL      5     100,000      L      R       True    True       5      180       0.01208      0.00253
CALL      5     100,000      L      S       True    True      13      180       0.02979      0.00659
CALL      5     100,000      L      T       True    True       3      180       0.01147      0.00162
CALL      5     100,000      N      A       True    True       1      180       0.00805      0.00101
CALL      5     100,000      N      F       True    True       2      180      ‚àí0.01566      0.00104
CALL      5     100,000      N      H       True    True       4      180       0.00545      0.00226
CALL      5     100,000      N      P       True    True       4      180      ‚àí0.01526      0.00120
CALL      5     100,000      N      R       True    True       6      180       0.01221      0.00279
CALL      5     100,000      N      S       True    True      11      180       0.03020      0.00549
CALL      5     100,000      N      T       True    True       3      180       0.00692      0.00174
PUT       5     100,000      L      A       True    True      20      180       0.00657      0.00149
PUT       5     100,000      L      F       True    True      10      180      ‚àí0.01379      0.00083
PUT       5     100,000      L      H       True    True      14      180       0.00808      0.00157
PUT       5     100,000      L      P       True    True       5      180      ‚àí0.00987      0.00056
PUT       5     100,000      L      R       True    True      18      180       0.01005      0.00207
PUT       5     100,000      L      S       True    True      29      180       0.02747      0.00592
PUT       5     100,000      L      T       True    True      10      180       0.00445      0.00117
PUT       5     100,000      N      A       True    True      16      180       0.00084      0.00123
PUT       5     100,000      N      F       True    True       9      180      ‚àí0.01466      0.00075
PUT       5     100,000      N      H       True    True      13      180       0.00402      0.00176
PUT       5     100,000      N      P       True    True       7      180      ‚àí0.01529      0.00070
PUT       5     100,000      N      R       True    True      17      180       0.00987      0.00217
PUT       5     100,000      N      S       True    True      30      180       0.02535      0.00556
PUT       5     100,000      N      T       True    True      11      180       0.00622      0.00106
a
  Monte Carlo simulation values benchmarked against semi-analytical values from Fourier-based pricing
approach. For the meaning of column headings refer to Table 10.1.


volatility (SV) model in combination with the CIR85 stochastic short rate (SI) model. This
model ÓàπSVSI is a special case of the general market model ÓàπBCC97 and exhibits risk-neutral
dynamics as follows:
                                                ‚àö
                                 dSt = rt St dt +   vt St dZt1
                                                              ‚àö
                                 dvt = ùúÖv (ùúÉv ‚àí vt )dt + ùúév vt dZt2
                                                             ‚àö
                                 drt = ùúÖr (ùúÉr ‚àí rt )dt + ùúér rt dZt3


     The major algorithm we apply is the LSM of Longstaff-Schwartz (Longstaff and Schwartz,
2001). However, in addition to moment matching and antithetic variates, we introduce a further
variance reduction technique: control variates.
198                                                         DERIVATIVES ANALYTICS WITH PYTHON


     The LSM estimator (7.15) provides us with an estimate for an American option‚Äôs value.
We correct this estimator by the simulated differences gained from a control variate. Consider
that we have simulated I paths of Xt = (St , vt , rt ) to value an American put option with maturity
T and strike K. Then there are also I simulated present values of the corresponding European
put option. They are given by P0,i = B0 (T)hT (XT,i ), i ‚àà {1, ..., I}, with hT (x) ‚â° max[K ‚àí x, 0].
The correction for the estimator (7.15) is as follows

                                      1 ‚àë(
                                         I
                                                                      )
                             VÃÇ 0CV =       V0,i ‚àí ùúÜ ‚ãÖ (P0,i ‚àí PH93
                                                                0
                                                                    )                        (10.8)
                                      I i=1

For ùúÜ one can use the statistical correlation between the simulated European and American
option present values. However, results from a number of numerical experiments indicate that
simply setting ùúÜ ‚â° 1 yields more accurate results in the test cases covered in this section.

10.4.1 Numerical Results
This sub-section presents numerical results from the simulation study based on American put
options as implemented in the Python script of sub-section 10.6.4.

Parametrized Financial Model We consider all model parametrizations for the H93 and
the CIR85 parts of the financial model from table 3 in Medvedev and Scaillet (2010). These
are four different parameter sets for the financial model.
     Per parameter set, American put options for three different maturities and moneyness
levels, respectively, are valued:
          {         }
   T ‚àà
             1 1 1
               , ,
            12 4 2
   K ‚àà {90, 100, 110}


     All parameter sets and all values for the single options (for a total of 36 option values)
are included in the Python script provided in sub-section 10.6.4. The script uses all seven
discretization schemes for the square-root diffusions. With respect to the index process, it relies
on an additive version of the log Euler scheme. The script implements the LSM algorithm with
certain options to alter algorithm features (like control variates, moment matching or antithetic
paths).
     To measure accuracy, we consider the absolute difference between our script‚Äôs values and
the benchmark values from Medvedev and Scaillet (2010). As benchmark values we take their
LSM estimates obtained by simulations with 50 exercise dates, 500 time steps and 1,000,000
paths. We say that our value estimates are accurate if the absolute difference is either smaller
than 2.5 cents or 1.5% (i.e. we take the same yardsticks as for the European options).
     Medvedev and Scaillet (2010) derive in their paper approximations for American option
values under stochastic volatility (of H93 type) and stochastic interest rates (of CIR85 type)
which can be evaluated very fast. They write on page 16:

      ‚ÄúTo give an idea of the computational advantage of our method, a Matlab code imple-
      menting the algorithm of Longstaff and Schwartz (2001) takes dozens of minutes
      to compute a single option price while our approximation takes roughly a tenth of
      a second.‚Äù
Monte Carlo Simulation                                                                      199


    Apart from accuracy, we therefore want to take a look at how fast we can value options
accurately with our Python implementation. This obviously is an important issue since ‚Äúdozens
of minutes‚Äù per single option price are of course unacceptable for practical applications.

Example Results from Simulation A numerical experiment with 10 simulation runs‚Äîfor
a total of 360 American put option values‚Äîyielded the following results (using control variate,
moment matching and antithetic paths techniques):

   discretization: Full Truncation
   time steps: 20
   paths: 20,000
   simulation runs: 10

   number of options: 360
   number of errors: 13
   average error: ‚àí0.00096

   total time: 29.18 seconds
   time per option: 0.08 seconds



      Three hundred and forty-seven out of 360 American put options are valued accurately
given our yardsticks. The average valuation error is about ‚àí0.001 cents and therewith well
below 1 cent in absolute value. The average relative error is not quite representative since the
relative error for option values of about 0.01 cents easily reaches 100% and more. Nevertheless,
it is only about +4%. Average time per option is about 0.08 seconds‚Äîwhich has to be compared
with the ‚Äúdozens of minutes‚Äù reported in Medvedev and Scaillet (2010). Our approach seems
to be 1,000+ times faster (if we assume a ‚Äòsingle‚Äô dozen of minutes) with an accurateness that
is consistent with a typical market microstructure.

Simulation Results Table 10.3 shows simulation results for different configurations of the
LSM algorithm. Each of the 36 options is valued five times making for a total of 180 option
valuations per configuration.

Interpretation of Results What are the reasons for the combination of reasonable accuracy
and valuation speed of the Python script? Actually, there are a number of reasons:

   implementation: the LSM algorithm has been implemented in Python using the fast
    numerical library NumPy which runs at the speed of C code for certain operations; for
    some applications this may be faster than Matlab or other domain-specific environments
    like R
   discretization: we only use Euler discretization schemes which provide ‚Äúsufficient‚Äù

    accuracy at a high speed; we let the simulated index level paths according to (10.4) drift
    step-by-step by the average of the two relevant short rate values
   control variates: the use of European put options as control variates (cf. Glasserman

    (2004), sec. 4.1) is of high or even highest importance for variance reduction and accuracy
    of the LSM estimator
   moment matching: we correct the set of standard normal pseudo-random numbers gener-

    ated by Python to match the first two moments correctly (cf. Glasserman (2004), sec. 4.5),
200                                                           DERIVATIVES ANALYTICS WITH PYTHON


TABLE 10.3 Valuation results for American put options in H93 and CIR85 model for
parametrizations from Medvedev and Scaillet (2010). Performance yardsticks are PY1 = 0.025 and
PY1 = 0.015.a

R      M         I       XD       CV       MM        AP       #ER       #OP          AE           MSE

5      20     25,000      A       True     True      True       1       180      ‚àí0.00117       0.00064
5      20     25,000      F       True     True      True       1       180      ‚àí0.00105       0.00042
5      20     25,000      H       True     True      True       5       180       0.00043       0.00046
5      20     25,000      P       True     True      True       4       180      ‚àí0.00379       0.00047
5      20     25,000      R       True     True      True       5       180      ‚àí0.00187       0.00058
5      20     25,000      S       True     True      True       3       180      ‚àí0.00290       0.00044
5      20     25,000      T       True     True      True       2       180       0.00072       0.00062
5      20     35,000      A       True     True      True       1       180      ‚àí0.00836       0.00050
5      20     35,000      F       True     True      True       1       180      ‚àí0.00289       0.00043
5      20     35,000      H       True     True      True       5       180      ‚àí0.00205       0.00057
5      20     35,000      P       True     True      True       4       180      ‚àí0.00328       0.00039
5      20     35,000      R       True     True      True       4       180      ‚àí0.00543       0.00051
5      20     35,000      S       True     True      True       2       180      ‚àí0.00408       0.00044
5      20     35,000      T       True     True      True       2       180      ‚àí0.00283       0.00035
5      25     25,000      A       True     True      True       2       180      ‚àí0.00171       0.00045
5      25     25,000      F       True     True      True       1       180       0.00126       0.00039
5      25     25,000      H       True     True      True       2       180      ‚àí0.00177       0.00043
5      25     25,000      P       True     True      True       1       180      ‚àí0.00083       0.00037
5      25     25,000      R       True     True      True       2       180      ‚àí0.00016       0.00059
5      25     25,000      S       True     True      True       4       180       0.00044       0.00050
5      25     25,000      T       True     True      True       3       180      ‚àí0.00173       0.00054
5      25     35,000      A       True     True      True       2       180      ‚àí0.00162       0.00043
5      25     35,000      F       True     True      True       1       180      ‚àí0.00135       0.00045
5      25     35,000      H       True     True      True       2       180      ‚àí0.00166       0.00041
5      25     35,000      P       True     True      True       1       180      ‚àí0.00199       0.00036
5      25     35,000      R       True     True      True       0       180      ‚àí0.00436       0.00028
5      25     35,000      S       True     True      True       5       180      ‚àí0.00429       0.00048
5      25     35000       T       True     True      True       1       180      ‚àí0.00144       0.00045
a
  Monte Carlo simulation estimates benchmarked against LSM values from Medvedev and Scaillet (2010).
The columns report the following values: R = number of valuation runs, M = number of time steps, I =
number of paths per single option valuation, XD = (first letter of) discretization scheme for square-root
diffusions, CV = control variates, MM = moment matching, AP = antithetic paths, #OP = number of
options valued, #ER = number of errors out of #OP, AE = average error over all valuations, MSE =
mean squared error of all valuations.




      i.e. the mean is adjusted to 0.0 and the standard deviation to 1.0; we also correct the first
      moment of the simulated index level paths according to (10.4) step by step to account for
      some remaining errors
     antithetic paths: as a general variance reduction technique we generate, as in Medvedev

      and Scaillet (2010), antithetic paths (cf. Glasserman (2004), sec. 4.2) such that conver-
      gence of the algorithm may improve somewhat
Monte Carlo Simulation                                                                         201


   use of paths: we use only in-the-money paths such that both the estimation of the
    regressions becomes faster (in particular for out-of-the-money options) and convergence
    of the algorithm may improve
   basis functions: we use all in all ten different basis functions for the regressions in the

    LSM implementation
   exercise at t = 0: we allow for exercise at t = 0 such that we get at least the inner value

    as the option price for the in-the-money cases
   paths: our LSM implementation allows a significant reduction in the number of dis-

    cretization intervals (25 instead of 500 as in Medvedev and Scaillet (2010)) and paths
    (35,000 instead of 1,000,000); our approach reduces the number of necessary simulated
    values by a factor of more than 500 and halves the number of regressions (25 exercise
    dates instead of 50)
   recycling: we use the same set of random numbers for the 36 options to be valued per

    simulation run; we also use the same simulated processes for each of the three options
    per time-to-maturity
   hardware: of course, hardware also plays a role; the computational times reported for the

    script are from a server with Intel Xeon CPU E3-1231 v3 @ 3.40GHz; Python 2.7 and
    NumPy ran on a Linux 64 bit operating system; however, better hardware or parallelization
    techniques could further speed up calculations


Importance of Algorithm Features In this sub-section, we report further simulation results
for variants of the LSM algorithm implementation. The aim is to identify those features of the
implementation that indeed contribute to accuracy. Using the same seed value for the Python
pseudo-random number generator, we replicate the 180 American option valuations several
times‚Äîchanging, respectively, features of the algorithm implementation. Table 10.4 shows
the results.
     It is obvious that the use of control variates is of paramount importance for accuracy. By
contrast, moment matching and antithetic variates may be beneficial or not (if at all, then on
a small scale). In view of the rather small additional computational time needed to include
control variates they should be used whenever possible in such a context.



10.4.2 Higher Accuracy vs. Lower Speed
In some circumstances, our yardsticks used to assess accuracy may be too lax. Even if only
for theoretical reasons, one might be interested in the LSM estimator (corrected with the help
of a control variate) being even closer to the true (i.e. theoretical) option value. To this end,
we set the performance yardsticks now to PY1 ‚â° 0.01 currency units (i.e. 1%) and PY2 ‚â° 0.01
(i.e. 1 percent). In particular, the 1 cent threshold is reasonable since it represents the smallest
currency unit in general. Therefore it is often used to judge accuracy. For example, Longstaff
and Schwartz (2001), p. 127, write: ‚ÄúOf the 20 differences shown in Table 1, 16 are less than
or equal to one cent in absolute value.‚Äù
      To better meet the new yardsticks, we increase the number of time intervals to 50 as well
as the number of paths to 100,000 and 200,000, respectively. As the results in Table 10.5 show,
there are six valuation errors for the 180 options in the case of 50 time steps, 100,000 paths
202                                                        DERIVATIVES ANALYTICS WITH PYTHON


TABLE 10.4 Valuation results for American put options in H93 and CIR85 model for
parametrizations from Medvedev and Scaillet (2010). Performance yardsticks are PY1 = 0.025 and
PY1 = 0.015.a

R     M        I       XD       CV       MM        AP       #ER      #OP         AE          MSE

5     20    35,000      A      False     False    False      54      180      ‚àí0.01504      0.00412
5     20    35,000      A      False     False    True       42      180      ‚àí0.01279      0.00365
5     20    35,000      A      False     True     False      43      180      ‚àí0.01126      0.00368
5     20    35,000      A      False     True     True       42      180      ‚àí0.01366      0.00351
5     20    35,000      A      True      False    False       0      180      ‚àí0.00319      0.00041
5     20    35,000      A      True      False    True        2      180      ‚àí0.00594      0.00046
5     20    35,000      A      True      True     False       1      180      ‚àí0.00364      0.00037
5     20    35,000      A      True      True     True        0      180      ‚àí0.00499      0.00045
5     20    35,000      F      False     False    False      44      180      ‚àí0.00894      0.00394
5     20    35,000      F      False     False    True       43      180      ‚àí0.01226      0.00379
5     20    35,000      F      False     True     False      42      180      ‚àí0.01283      0.00374
5     20    35,000      F      False     True     True       46      180      ‚àí0.01179      0.00422
5     20    35,000      F      True      False    False       4      180      ‚àí0.00525      0.00059
5     20    35,000      F      True      False    True        3      180      ‚àí0.00366      0.00038
5     20    35,000      F      True      True     False       2      180      ‚àí0.00416      0.00046
5     20    35,000      F      True      True     True        2      180      ‚àí0.00618      0.00042
5     20    35,000      P      False     False    False      45      180      ‚àí0.01272      0.00432
5     20    35,000      P      False     False    True       44      180      ‚àí0.01313      0.00407
5     20    35,000      P      False     True     False      42      180      ‚àí0.01241      0.00371
5     20    35,000      P      False     True     True       41      180      ‚àí0.01339      0.00385
5     20    35,000      P      True      False    False       3      180      ‚àí0.00337      0.00046
5     20    35,000      P      True      False    True        4      180      ‚àí0.00540      0.00047
5     20    35,000      P      True      True     False       1      180      ‚àí0.00322      0.00036
5     20    35,000      P      True      True     True        3      180      ‚àí0.00154      0.00045
5     20    35,000      T      False     False    False      53      180      ‚àí0.01329      0.00431
5     20    35,000      T      False     False    True       40      180      ‚àí0.01140      0.00374
5     20    35,000      T      False     True     False      42      180      ‚àí0.01210      0.00400
5     20    35,000      T      False     True     True       42      180      ‚àí0.01345      0.00367
5     20    35,000      T      True      False    False       1      180      ‚àí0.00513      0.00050
5     20    35,000      T      True      False    True        1      180      ‚àí0.00530      0.00042
5     20    35,000      T      True      True     False       3      180      ‚àí0.00479      0.00042
5     20    35,000      T      True      True     True        2      180      ‚àí0.00446      0.00039
a
  Monte Carlo simulation estimates benchmarked against LSM values from Medvedev and Scaillet (2010).
For the meaning of column headings refer to Table 10.3.




and the Full Truncation scheme. The average valuation error in this case is around ‚àí0.5 cents.
However, further increasing the number of paths to 200,000 ceteris paribus does not guarantee
better valuation results, as is also illustrated in Table 10.5.
     These results illustrate the trade-off between valuation accuracy and speed quite well. By
increasing the number of time intervals and paths per simulation, you can get closer to the true
(theoretical) value‚Äîjust as the convergence results of CleÃÅment et al. (2002) imply. Longer
valuation times are the price to pay.
Monte Carlo Simulation                                                                          203


TABLE 10.5 Valuation results for American put options in H93 and CIR85 model for
parametrizations from Medvedev and Scaillet (2010). Performance yardsticks are PY1 = 0.01 and
PY1 = 0.01.a

R     M            I     XD      CV      MM        AP      #ER      #OP         AE          MSE

5    20      35,000      A      True     True     True      10      180     ‚àí0.00417      0.00038
5    20      35,000      F      True     True     True      11      180     ‚àí0.00241      0.00043
5    20      35,000      P      True     True     True      10      180     ‚àí0.00323      0.00051
5    20      35,000      T      True     True     True      15      180     ‚àí0.00318      0.00051
5    20     100,000      A      True     True     True      14      180     ‚àí0.00928      0.00048
5    20     100,000      F      True     True     True      15      180     ‚àí0.00857      0.00033
5    20     100,000      P      True     True     True      20      180     ‚àí0.00855      0.00047
5    20     100,000      T      True     True     True      15      180     ‚àí0.00981      0.00047
5    20     200,000      A      True     True     True      17      180     ‚àí0.00966      0.00040
5    20     200,000      F      True     True     True      19      180     ‚àí0.01116      0.00044
5    20     200,000      P      True     True     True      15      180     ‚àí0.01055      0.00043
5    20     200,000      T      True     True     True      16      180     ‚àí0.01032      0.00041
5    50      35,000      A      True     True     True      12      180     ‚àí0.00211      0.00040
5    50      35,000      F      True     True     True      16      180     ‚àí0.00004      0.00048
5    50      35,000      P      True     True     True      14      180      0.00020      0.00043
5    50      35,000      T      True     True     True      15      180     ‚àí0.00258      0.00047
5    50     100,000      A      True     True     True       7      180     ‚àí0.00478      0.00031
5    50     100,000      F      True     True     True       6      180     ‚àí0.00536      0.00028
5    50     100,000      P      True     True     True       7      180     ‚àí0.00657      0.00032
5    50     100,000      T      True     True     True       9      180     ‚àí0.00591      0.00034
5    50     200,000      A      True     True     True       7      180     ‚àí0.00783      0.00034
5    50     200,000      F      True     True     True       7      180     ‚àí0.00720      0.00038
5    50     200,000      P      True     True     True       3      180     ‚àí0.00709      0.00029
5    50     200,000      T      True     True     True       9      180     ‚àí0.00743      0.00032
a
  Monte Carlo simulation values benchmarked against LSM values from Medvedev and Scaillet (2010).
For the meaning of column headings refer to Table 10.3.



10.5 CONCLUSIONS

Monte Carlo simulation is an indispensable tool for the valuation of non-vanilla equity deriva-
tives and for risk management purposes. However, even valuing simple products correctly by
simulation in more complex models‚Äîlike the ones of CIR85, H93 or BCC97‚Äîis already a
daunting task. This chapter first shows how to correctly discretize the square-root diffusion
in the CIR85 model and value zero-coupon bonds numerically. It then proceeds and values
European call and put options in the H93 model where the variance process is discretized by a
Euler scheme‚Äîa total of seven schemes is implemented to allow for numerical comparisons.
     Section 4 then adds the CIR85 short rate model to the H93 model to value American
put options by Monte Carlo simulation and the LSM algorithm. We show that our Python
implementation allows for quite fast valuations in this context‚Äîthe script needs only about
a tenth of a second for a single option valuation. This is, among others, accomplished by the
use of three variance reduction techniques: control variates, moment matching and antithetic
paths. In this context, control variates play a dominant role in increasing valuation accuracy.
204                                             DERIVATIVES ANALYTICS WITH PYTHON


10.6 PYTHON SCRIPTS

10.6.1 General Zero-Coupon Bond Valuation

#
# Valuation of Zero-Coupon Bonds
# in Cox-Ingersoll-Ross (1985) Model
# 09_gmm/CIR_zcb_valuation_gen.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np


#
# Example Parameters CIR85 Model
#
r0, kappa_r, theta_r, sigma_r, t, T = 0.04, 0.3, 0.04, 0.1, 0.5, 5.0

#
# Zero-Coupon Bond Valuation Formula
#



def gamma(kappa_r, sigma_r):
      ''' Help Function. '''
      return np.sqrt(kappa_r ** 2 + 2 * sigma_r ** 2)



def b1(alpha):
    ''' Help Function. '''
      r0, kappa_r, theta_r, sigma_r, t, T = alpha
      g = gamma(kappa_r, sigma_r)
      return (((2 * g * np.exp((kappa_r + g) * (T - t) / 2)) /
              (2 * g + (kappa_r + g) * (np.exp(g * (T - t)) - 1)))
              ** (2 * kappa_r * theta_r / sigma_r ** 2))



def b2(alpha):
    ''' Help Function. '''
      r0, kappa_r, theta_r, sigma_r, t, T = alpha
      g = gamma(kappa_r, sigma_r)
      return ((2 * (np.exp(g * (T - t)) - 1)) /
              (2 * g + (kappa_r + g) * (np.exp(g * (T - t)) - 1)))
Monte Carlo Simulation                                             205


def B(alpha):
    ''' Function to value unit zero-coupon bonds in CIR85 Model.


     Parameters
     ==========
     r0: float
         initial short rate
     kappa_r: float
         mean-reversion factor
     theta_r: float
         long-run mean of short rate
     sigma_r: float
         volatility of short rate
     t: float
         valuation date
     T: float
         time horizon/interval


     Returns
     =======
     zcb_value: float
         value of zero-coupon bond
     '''
     b_1 = b1(alpha)
     b_2 = b2(alpha)
     r0, kappa_r, theta_r, sigma_r, t, T = alpha
     E_rt = theta_r + np.exp(-kappa_r * t) * (r0 - theta_r)
         # expected value of r_t
     zcb_value = b_1 * np.exp(-b_2 * E_rt)
     return zcb_value


if _ _name_ _ == '_ _main_ _':
    #
    # Example Valuation
     #
     BtT = B([r0, kappa_r, theta_r, sigma_r, t, T])
         # discount factor, ZCB value for t & T
     print "ZCB Value    %10.4f" % BtT




10.6.2 CIR85 Simulation and Valuation

#
# Valuation of Zero-Coupon Bonds by Monte Carlo Simulation
# in Cox-Ingersoll-Ross (1985) Model
206                                              DERIVATIVES ANALYTICS WITH PYTHON


# 10_mcs/CIR_zcb_simulation.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import math
import numpy as np
from CIR_zcb_valuation_gen import B
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
from time import time


#
# Simulation of Square Root Diffusion
#



def CIR_generate_paths(x0, kappa, theta, sigma, T, M, I, x_disc='exact'):
    ''' Function to simulate Square-Root Difussion (SRD/CIR) process.


      Parameters
      ==========
      x0: float
          initial value
      kappa: float
          mean-reversion factor
      theta: float
          long-run mean
      sigma: float
          volatility factor
      T: float
          final date/time horizon
      M: int
          number of time steps
      I: int
          number of paths


      Returns
      =======
      x: NumPy array
          simulated paths
      '''
      dt = T / M
      x = np.zeros((M + 1, I), dtype=np.float)
      x[0] = x0
      xh = np.zeros_like(x)
Monte Carlo Simulation                                                        207


     xh[0] = x0
     ran = np.random.standard_normal((M + 1, I))


     if x_disc is 'exact':
         # exact discretization
         d = 4 * kappa * theta / sigma ** 2
          c = (sigma ** 2 * (1 - math.exp(-kappa * dt))) / (4 * kappa)
          if d > 1:
              for t in xrange(1, M + 1):
                    l = x[t - 1] * math.exp(-kappa * dt) / c
                    chi = np.ramdom.chisquare(d - 1, I)
                    x[t] = c * ((ran[t] + np.sqrt(l)) ** 2 + chi)
          else:
              for t in xrange(1, M + 1):
                    l = x[t - 1] * math.exp(-kappa * dt) / c
                    N = np.random.poisson(l / 2, I)
                    chi = np.random.chisquare(d + 2 * N, I)
                    x[t] = c * chi

     else:
          # Euler scheme (full truncation)
          for t in xrange(1, M + 1):
              xh[t] = (xh[t - 1] + kappa * (theta - np.maximum(0, xh[t - 1]))
                        * dt + np.sqrt(np.maximum(0, xh[t - 1]))
                        * sigma * ran[t] * math.sqrt(dt))
               x[t] = np.maximum(0, xh[t])
     return x



#
# Graphical Output of Simulated Paths
#
def plot_paths():
    plt.figure(figsize=(9, 5))
     plt.plot(range(len(r)), r[:, :20])
     plt.grid()
     plt.xlabel('time step')
     plt.ylabel('short rate')

#
# Valuation of ZCB
#
def zcb_estimator(M=50, x_disc='exact'):
     dt = T / M
     r = CIR_generate_paths(r0, kappa_r, theta_r, sigma_r, T, M, I, x_disc)
     zcb = np.zeros((M + 1, I), dtype=np.float)
     zcb[-1] = 1.0       # final value
208                                                DERIVATIVES ANALYTICS WITH PYTHON


      for t in range(M, 0, -1):
          zcb[t - 1] = zcb[t] * np.exp(-(r[t] + r[t - 1]) / 2 * dt)
      return np.sum(zcb, axis=1) / I


#
# Graphical Value Comparison
#
def graphical_comparison(M=50, x_disc='exact'):
    MCS_values = zcb_estimator(M, x_disc)
      CIR_values = []
      dt = T / M
      t_list = np.arange(0.0, T + 0.001, dt)     # dates of interest
      for t in t_list:
          alpha = r0, kappa_r, theta_r, sigma_r, t, T
          CIR_values.append(B(alpha))
            # CIR model values given date list


      fig, ax = plt.subplots(2, sharex=True, figsize=(8, 6))
      ax[0].plot(t_list, MCS_values, 'ro', label='MCS values')
      ax[0].plot(t_list, CIR_values, 'b', label='CIR values')
      ax[0].legend(loc=0)
      ax[0].grid()
      ax[0].set_ylim(min(CIR_values) - 0.005, max(CIR_values) + 0.005)
      ax[0].set_ylabel('option values')
      ax[0].set_title('maturity $T=2$')
      ax[1].bar(t_list - 0.025 / 2., MCS_values - CIR_values,
                      width=0.025)
      plt.ylabel('difference')
      plt.xlim(min(t_list) - 0.1, max(t_list) + 0.1)
      plt.xlabel('time $t$')
      plt.tight_layout()
      plt.grid()

if _ _name_ _ == '_ _main_ _':
      #
      # Model Parameters
      #
      r0, kappa_r, theta_r, sigma_r = [0.01, 0.1, 0.03, 0.2]
      T = 2.0 # time horizon
      M = 50 # time steps
      dt = T / M
      I = 50000 # number of MCS paths
      np.random.seed(50000) # seed for RNG


      r = CIR_generate_paths(r0, kappa_r, theta_r, sigma_r, T, M, I)
Monte Carlo Simulation                                                   209


10.6.3 Automated Valuation of European Options by Monte
Carlo Simulation

#
# Valuation of European Options
# Under Heston (1993) Stochastic Volatility Model
# Comparison of Fourier-based Value and MCS Estimator
# 10_mcs/H93_european_mcs.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.append('09_gmm/')
import math
import string
import numpy as np
np.set_printoptions(precision=3)
import pandas as pd
import itertools as it
from datetime import datetime
from time import time
from BCC_option_valuation import H93_call_value

# Fixed Short Rate
r = 0.05

# Heston (1993) Parameters
# from MS (2009), table 3
para = np.array(((0.01, 1.5, 0.15, 0.1),     # panel 1
             # (v0,kappa_v,sigma_v,rho)
                 (0.04, 0.75, 0.3, 0.1), # panel 2
                 (0.04, 1.50, 0.3, 0.1), # panel 3
                 (0.04, 1.5, 0.15, -0.5))) # panel 4


theta_v = 0.02 # long-term variance level
S0 = 100.0 # initial index level


# General Simulation Parameters
write = True
verbose = False
option_types = ['CALL', 'PUT']     # option types
steps_list = [25, 50] # time steps p.a.
paths_list = [25000, 50000, 75000, 100000]  # number of paths per valuation
s_disc_list = ['Log', 'Naive'] # Euler scheme: log vs. naive
x_disc_list = ['Full Truncation', 'Partial Truncation', 'Truncation',
210                                                   DERIVATIVES ANALYTICS WITH PYTHON


                   'Absorption', 'Reflection', 'Higham-Mao', 'Simple Reflection']
                    # discretization schemes for SRD process


anti_paths = [False, True]
  # antithetic paths for variance reduction
moment_matching = [False, True]
    # random number correction (std + mean + drift)

t_list = [1.0 / 12, 1.0, 2.0]       # maturity list
k_list = [90, 100, 110]     # strike list
PY1 = 0.025 # performance yardstick 1: abs. error in currency units
PY2 = 0.015 # performance yardstick 2: rel. error in decimals
runs = 5 # number of simulation runs
np.random.seed(250000) # set RNG seed value


#
# Function for Short Rate and Volatility Processes
#



def SRD_generate_paths(x_disc, x0, kappa, theta, sigma,
                       T, M, I, rand, row, cho_matrix):
    ''' Function to simulate Square-Root Diffusion (SRD/CIR) process.


      Parameters
      ==========
      x0: float
          initial value
      kappa: float
          mean-reversion factor
      theta: float
          long-run mean
      sigma: float
          volatility factor
      T: float
          final date/time horizon
      M: int
          number of time steps
      I: int
          number of paths
      row: int
          row number for random numbers
      cho_matrix: NumPy array
          Cholesky matrix

      Returns
      =======
Monte Carlo Simulation                                                       211


     x: NumPy array
         simulated variance paths
     '''
     dt = T / M
     x = np.zeros((M + 1, I), dtype=np.float)
     x[0] = x0
     xh = np.zeros_like(x)
     xh[0] = x0
     sdt = math.sqrt(dt)
     for t in xrange(1, M + 1):
         ran = np.dot(cho_matrix, rand[:, t])
         if x_disc == 'Full Truncation':
               xh[t] = (xh[t - 1] + kappa * (theta -
                    np.maximum(0, xh[t - 1])) * dt +
                   np.sqrt(np.maximum(0, xh[t - 1])) * sigma * ran[row] * sdt)
              x[t] = np.maximum(0, xh[t])
          elif x_disc == 'Partial Truncation':
               xh[t] = (xh[t - 1] + kappa * (theta - xh[t - 1]) * dt +
                    np.sqrt(np.maximum(0, xh[t - 1])) * sigma * ran[row] * sdt)
               x[t] = np.maximum(0, xh[t])
          elif x_disc == 'Truncation':
              x[t] = np.maximum(0, x[t - 1]
                   + kappa * (theta - x[t - 1]) * dt +
                   np.sqrt(x[t - 1]) * sigma * ran[row] * sdt)
          elif x_disc == 'Reflection':
              xh[t] = (xh[t - 1]
                    + kappa * (theta - abs(xh[t - 1])) * dt +
                    np.sqrt(abs(xh[t - 1])) * sigma * ran[row] * sdt)
               x[t] = abs(xh[t])
          elif x_disc == 'Higham-Mao':
              xh[t] = (xh[t - 1] + kappa * (theta - xh[t - 1]) * dt +
                   np.sqrt(abs(xh[t - 1])) * sigma * ran[row] * sdt)
              x[t] = abs(xh[t])
          elif x_disc == 'Simple Reflection':
              x[t] = abs(x[t - 1] + kappa * (theta - x[t - 1]) * dt +
                   np.sqrt(x[t - 1]) * sigma * ran[row] * sdt)
          elif x_disc == 'Absorption':
               xh[t] = (np.maximum(0, xh[t - 1])
                    + kappa * (theta - np.maximum(0, xh[t - 1])) * dt +
                    np.sqrt(np.maximum(0, xh[t - 1])) * sigma * ran[row] * sdt)
              x[t] = np.maximum(0, xh[t])
          else:
              print x_disc
             print "No valid Euler scheme."
             sys.exit(0)
     return x
212                                              DERIVATIVES ANALYTICS WITH PYTHON


#
# Function for Heston Index Process
#


def H93_generate_paths(S0, r, v, row, cho_matrix):
    ''' Simulation of Heston (1993) index process.


      Parameters
      ==========
      S0: float
          initial value
      r: float
          constant short rate
      v: NumPy array
          simulated variance paths
      row: int
          row/matrix of random number array to use
      cho_matrix: NumPy array
          Cholesky matrix


      Returns
      =======
      S: NumPy array
          simulated index level paths
      '''
      S = np.zeros((M + 1, I), dtype=np.float)
      S[0] = S0
      bias = 0.0
      sdt = math.sqrt(dt)
      for t in xrange(1, M + 1, 1):
          ran = np.dot(cho_matrix, rand[:, t])
          if momatch:
              bias = np.mean(np.sqrt(v[t]) * ran[row] * sdt)
          if s_disc == 'Log':
              S[t] = S[t - 1] * np.exp((r - 0.5 * v[t]) * dt +
                      np.sqrt(v[t]) * ran[row] * sdt - bias)
          elif s_disc == 'Naive':
              S[t] = S[t - 1] * (math.exp(r * dt) +
                      np.sqrt(v[t]) * ran[row] * sdt - bias)
          else:
              print "No valid Euler scheme."
              exit(0)
      return S



def random_number_generator(M, I):
      ''' Function to generate pseudo-random numbers.
Monte Carlo Simulation                                                     213


     Parameters
     ==========
     M: int
         time steps
     I: int
         number of simulation paths


     Returns
     =======
     rand: NumPy array
         random number array
     '''
     if antipath:
         rand = np.random.standard_normal((2, M + 1, I / 2))
         rand = np.concatenate((rand, -rand), 2)
     else:
         rand = np.random.standard_normal((2, M + 1, I))
     if momatch:
         rand = rand / np.std(rand)
         rand = rand - np.mean(rand)
     return rand

#
# Valuation
#


t0 = time()

results = pd.DataFrame()


tmpl_1 = '%4s | %3s | %6s | %6s | %6s | %6s | %5s | %5s' \
            % ('T', 'K', 'V0', 'V0_MCS', 'err', 'rerr', 'acc1', 'acc2')
tmpl_2 = '%4.3f | %3d | %6.3f | %6.3f | %6.3f | %6.3f | %5s | %5s'


if _ _name_ _ == '_ _main_ _':

     for alpha in it.product(option_types, steps_list, paths_list, s_disc_list,
                              x_disc_list, anti_paths, moment_matching):
          print '\n\n', alpha, '\n'
          option, M0, I, s_disc, x_disc, antipath, momatch = alpha
          for run in range(runs):
              for panel in range(4):
                  # Correlation Matrix
                    v0, kappa_v, sigma_v, rho = para[panel]
                    covariance_matrix = np.zeros((2, 2), dtype=np.float)
                    covariance_matrix[0] = [1.0, rho]
                    covariance_matrix[1] = [rho, 1.0]
214                                   DERIVATIVES ANALYTICS WITH PYTHON


      cho_matrix = np.linalg.cholesky(covariance_matrix)
      if verbose:
          print "nResults for Panel %dn" % (panel + 1)
          print tmpl_1
      for T in t_list: # maturity list
          # memory clean-up
          v, S, rand, h = 0.0, 0.0, 0.0, 0.0
          M = int(M0 * T) # number of total time steps
          dt = T / M # time interval in years
          # random numbers
          rand = random_number_generator(M, I)
          # volatility process paths
          v = SRD_generate_paths(x_disc, v0, kappa_v, theta_v,
                          sigma_v, T, M, I, rand, 1, cho_matrix)
          # index level process paths
          S = H93_generate_paths(S0, r, v, 0, cho_matrix)
          for K in k_list:
              # European option values
              B0T = math.exp(-r * T) # discount factor
              # European call option value (semi-analytical)
              C0 = H93_call_value(S0, K, T, r, kappa_v,
                                   theta_v, sigma_v, rho, v0)
              P0 = C0 + K * B0T - S0
              if option is 'PUT':
                  # benchmark value
                  V0 = P0
                  # inner value matrix put
                  h = np.maximum(K - S, 0)
              elif option is 'CALL':
                  # benchmark value
                  V0 = C0
                  # inner value matrix call
                  h = np.maximum(S - K, 0)
              else:
                  print "No valid option type."
                  sys.exit(0)
              pv = B0T * h[-1] # present value vector
              V0_MCS = np.sum(pv) / I   # MCS estimator
              SE = np.std(pv) / math.sqrt(I)
                # standard error
              error = V0_MCS - V0
              rel_error = (V0_MCS - V0) / V0
              PY1_acc = abs(error) < PY1
              PY2_acc = abs(rel_error) < PY2
              res = pd.DataFrame({'timestamp': datetime.now(),
                  'otype': option, 'runs': runs, 'steps': M0,
                  'paths': I, 'index_disc': s_disc,
                  'var_disc': x_disc, 'anti_paths': antipath,
Monte Carlo Simulation                                                       215


                              'moment_matching': momatch, 'panel': panel,
                              'maturity': T, 'strike': K, 'value': V0,
                              'MCS_est': V0_MCS, 'SE': SE, 'error': error,
                              'rel_error': rel_error, 'PY1': PY1, 'PY2': PY2,
                              'PY1_acc': PY1_acc, 'PY2_acc': PY2_acc,
                              'PY_acc': PY1_acc or PY2_acc},
                              index=[0,])

                          if verbose:
                              print tmpl_2 % (T, K, V0, V0_MCS, error,
                                          rel_error, PY1_acc, PY2_acc)


                          results = results.append(res, ignore_index=True)


     if write:
         d = str(datetime.now().replace(microsecond=0))
         d = d.translate(string.maketrans("-:", "_ _"))
          h5 = pd.HDFStore('10_mcs/mcs_european_%s_%s.h5'
                              % (d[:10], d[11:]), 'w')
          h5['results'] = results
          h5.close()

     print "Total time in minutes %8.2f" % ((time() - t0) / 60)




10.6.4 Automated Valuation of American Put Options by
Monte Carlo Simulation

#
# Script for American Put Option Valuation by MCS/LSM
# in H93 and CIR85 model
#
# Examples from Medvedev & Scaillet (2010):
# "Pricing American Options Under Stochastic Volatility
# and Stochastic Interest Rates."
#
# 10_mcs/SVSI_american_mcs.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import gc
import sys
sys.path.append('09_gmm/')
import math
import string
216                                             DERIVATIVES ANALYTICS WITH PYTHON


import numpy as np
import pandas as pd
import itertools as it
from datetime import datetime
from BCC_option_valuation import H93_call_value
from H93_european_mcs import SRD_generate_paths
from CIR_zcb_valuation_gen import B
from time import time


# 'True' American Options Prices by Monte Carlo
# from MS (2009), table 3
benchmarks = np.array(((0.0001, 1.0438, 9.9950, 0.0346, 1.7379, 9.9823,
                   0.2040, 2.3951, 9.9726),       # panel 1
                  (0.0619, 2.1306, 10.0386, 0.5303, 3.4173, 10.4271,
                   1.1824, 4.4249, 11.0224),      # panel 2
                  (0.0592, 2.1138, 10.0372, 0.4950, 3.3478, 10.3825,
                   1.0752, 4.2732, 10.8964),      # panel 3
                  (0.0787, 2.1277, 10.0198, 0.6012, 3.4089, 10.2512,
                   1.2896, 4.4103, 10.6988)))    # panel 4


# Cox, Ingersoll, Ross (1985) Parameters
# from MS (2009), table 3, panel 1
r0 = 0.04
kappa_r = 0.3
theta_r = 0.04
sigma_r = 0.1


# Heston (1993) Parameters
# from MS (2009), table 3
para = np.array(((0.01, 1.50, 0.15, 0.10),    # panel 1
            # (v0, kappa_v, sigma_v, rho)
             (0.04, 0.75, 0.30, 0.10), # panel 2
             (0.04, 1.50, 0.30, 0.10),   # panel 3
             (0.04, 1.50, 0.15, -0.50))) # panel 4


theta_v = 0.02 # long-term variance level
S0 = 100.0 # initial index level
D = 10   # number of basis functions

# General Simulation Parameters
write = True
verbose = False


py_list = [(0.025, 0.015)] # , (0.01, 0.01)]
  # combinations of performance yardsticks (absolute, relative)
  # performance yardstick 1: abs. error in currency units
  # performance yardstick 2: rel. error in decimals
Monte Carlo Simulation                                                    217


m_list = [20, 25] # number of time intervals
paths_list = [25000, 35000] # number of paths per valuation


x_disc_list = ['Full Truncation', 'Partial Truncation', 'Truncation',
               'Absorption', 'Reflection', 'Higham-Mao', 'Simple Reflection']
                # discretization schemes for SRD process


control_variate = [False, True]
  # use of control variate
anti_paths = [False, True]
  # antithetic paths for variance reduction
moment_matching = [False, True]
  # random number correction (std + mean + drift)


t_list = [1.0 / 12, 0.25, 0.5]      # maturity list
k_list = [90., 100., 110.]          # strike list


runs = 5    # number of simulation runs

np.random.seed(250000)    # set RNG seed value




#
# Function for Heston Index Process
#



def H93_index_paths(S0, r, v, row, cho_matrix):
     ''' Simulation of the Heston (1993) index process.


     Parameters
     ==========
     S0: float
         initial value
     r: NumPy array
         simulated short rate paths
     v: NumPy array
         simulated variance paths
     row: int
         row/matrix of random number array to use
     cho_matrix: NumPy array
         Cholesky matrix


     Returns
     =======
     S: NumPy array
218                                              DERIVATIVES ANALYTICS WITH PYTHON


          simulated index level paths
      '''
      sdt = math.sqrt(dt)
      S = np.zeros((M + 1, I), dtype=np.float)
      S[0] = math.log(S0)
      for t in xrange(1, M + 1, 1):
          ran = np.dot(cho_matrix, rand[:, t])
          S[t] += S[t - 1]
          S[t] += ((r[t] + r[t - 1]) / 2 - v[t] / 2) * dt
          S[t] += np.sqrt(v[t]) * ran[row] * sdt
          if momatch is True:
              S[t] -= np.mean(np.sqrt(v[t]) * ran[row] * sdt)
      return np.exp(S)



def random_number_generator(M, I):
    ''' Function to generate pseudo-random numbers.


      Parameters
      ==========
      M: int
          time steps
      I: int
          number of simulation paths

      Returns
      =======
      rand: NumPy array
          random number array
      '''
      if antipath:
          rand = np.random.standard_normal((3, M + 1, I / 2))
          rand = np.concatenate((rand, -rand), 2)
      else:
          rand = np.random.standard_normal((3, M + 1, I))
      if momatch:
          rand = rand / np.std(rand)
          rand = rand - np.mean(rand)
      return rand


#
# Valuation
#
t0 = time()

results = pd.DataFrame()
Monte Carlo Simulation                                                        219


tmpl_1 = '%5s | %3s | %6s | %6s | %6s | %6s | %6s | %6s | %6s | %5s | %5s'
tmpl_2 = '%4.3f | %3d ' + 7 * '| %6.3f ' + '| %5s | %5s'


for alpha in it.product(py_list, x_disc_list, m_list, paths_list,
                        control_variate, anti_paths, moment_matching):
    print '\n\n', alpha, '\n'
     (PY1, PY2), x_disc, M, I, convar, antipath, momatch = alpha
     for run in xrange(runs): # simulation runs
         for panel in xrange(4): # panels
               if verbose:
                   print "\nResults for Panel %d\n" % (panel + 1)
                   print tmpl_1 % ('T', 'K', 'V0', 'V0_LSM', 'V0_CV', 'P0',
                       'P0_MCS', 'err', 'rerr', 'acc1', 'acc2')
               # correlation matrix, cholesky decomposition
               v0, kappa_v, sigma_v, rho = para[panel]
               correlation_matrix = np.zeros((3, 3), dtype=np.float)
               correlation_matrix[0] = [1.0, rho, 0.0]
               correlation_matrix[1] = [rho, 1.0, 0.0]
               correlation_matrix[2] = [0.0, 0.0, 1.0]
               cho_matrix = np.linalg.cholesky(correlation_matrix)


               z = 0 # option counter
               S, r, v, h, V, matrix = 0, 0, 0, 0, 0, 0
               gc.collect()
               for T in t_list: # times-to-maturity
                   # discount factor
                    B0T = B([r0, kappa_r, theta_r, sigma_r, 0.0, T])
                    # average constant short rate/yield
                    ra = -math.log(B0T) / T
                    # time interval in years
                    dt = T / M
                    # pseudo-random numbers
                    rand = random_number_generator(M, I)
                    # short rate process paths
                    r = SRD_generate_paths(x_disc, r0, kappa_r, theta_r,
                                            sigma_r, T, M, I, rand, 0, cho_matrix)
                    # volatility process paths
                    v = SRD_generate_paths(x_disc, v0, kappa_v, theta_v,
                                            sigma_v, T, M, I, rand, 2, cho_matrix)
                    # index level process paths
                    S = H93_index_paths(S0, r, v, 1, cho_matrix)
                    for K in k_list: # strikes
                        # inner value matrix
                         h = np.maximum(K - S, 0)
                         # value/cash flow matrix
                         V = np.maximum(K - S, 0)
220                               DERIVATIVES ANALYTICS WITH PYTHON


      for t in xrange(M - 1, 0, -1):
          df = np.exp(-(r[t] + r[t + 1]) / 2 * dt)
          # select only ITM paths
          itm = np.greater(h[t], 0)
          relevant = np.nonzero(itm)
          rel_S = np.compress(itm, S[t])
          no_itm = len(rel_S)
          if no_itm == 0:
              cv = np.zeros((I), dtype=np.float)
          else:
              rel_v = np.compress(itm, v[t])
              rel_r = np.compress(itm, r[t])
              rel_V = (np.compress(itm, V[t + 1])
                         * np.compress(itm, df))
              matrix = np.zeros((D + 1, no_itm), dtype=np.float)
              matrix[10] = rel_S * rel_v * rel_r
              matrix[9] = rel_S * rel_v
              matrix[8] = rel_S * rel_r
              matrix[7] = rel_v * rel_r
              matrix[6] = rel_S ** 2
              matrix[5] = rel_v ** 2
              matrix[4] = rel_r ** 2
              matrix[3] = rel_S
              matrix[2] = rel_v
              matrix[1] = rel_r
              matrix[0] = 1
              reg = np.linalg.lstsq(matrix.transpose(), rel_V)
              cv = np.dot(reg[0], matrix)
          erg = np.zeros((I), dtype=np.float)
          np.put(erg, relevant, cv)
          V[t] = np.where(h[t] > erg, h[t], V[t + 1] * df)


      # final discounting step
      df = np.exp(-(r[0] + r[1]) / 2 * dt)


      ## European Option Values
      C0 = H93_call_value(S0, K, T, ra, kappa_v,
                           theta_v, sigma_v, rho, v0)

      P0 = C0 + K * B0T - S0
      P0_MCS = B0T * np.sum(h[-1]) / I

      x = B0T * h[-1]
      y = V[1] * df

      ## Control Variate Correction
      if convar is True:
Monte Carlo Simulation                                                            221


                             # statistical correlation
                             b = (np.sum((x - np.mean(x)) * (y - np.mean(y)))
                              / np.sum((x - np.mean(x)) ** 2))
                             # correction
                             y_cv = y - 1.0 * (B0T * h[-1] - P0)
                               # set b instead of 1.0
                               # to use stat. correlation
                         else:
                             y_cv = y
                         # standard error
                         SE = np.std(y_cv) / math.sqrt(I)
                         # benchmark value
                         V0 = benchmarks[panel, z]
                         # LSM control variate
                         V0_CV = max(np.sum(y_cv) / I, h[0, 0])
                         # pure LSM
                         V0_LSM = max(np.sum(y) / I, h[0, 0])


                         ## Errors
                         error = V0_CV - V0
                         rel_error = error / V0
                         PY1_acc = abs(error) < PY1
                         PY2_acc = abs(rel_error) < PY2
                         res = pd.DataFrame({'timestamp': datetime.now(),
                             'runs': runs, 'PY1': PY1, 'PY2': PY2,
                             'var_disc': x_disc, 'steps': M, 'paths': I,
                             'control_variate': convar, 'anti_paths': antipath,
                             'moment_matching': momatch, 'panel': panel,
                             'maturity': T, 'strike': K, 'benchmark': V0,
                             'V0_euro': P0, 'MCS_euro': P0_MCS,
                             'LSM_pure': V0_LSM, 'LSM_convar': V0_CV,
                             'SE': SE, 'error': error, 'rel_error': rel_error,
                             'PY1_acc': PY1_acc, 'PY2_acc': PY2_acc,
                             'PY_acc': PY1_acc or PY2_acc},
                             index=[0,])

                         z += 1 # option counter


                         if verbose:
                             print tmpl_2 % (T, K, V0, V0_LSM, V0_CV, P0,
                                 P0_MCS, error, rel_error, PY1_acc, PY2_acc)

                         results = results.append(res, ignore_index=True)


if write:
    d = str(datetime.now().replace(microsecond=0))
     d = d.translate(string.maketrans("-:", "_ _"))
222                                             DERIVATIVES ANALYTICS WITH PYTHON


      h5 = pd.HDFStore('10_mcs/mcs_american_%s_%s.h5' % (d[:10], d[11:]), 'w')
      h5['results'] = results
      h5.close()


print "Total time in minutes %8.2f" % ((time() - t0) / 60)
                                                                       CHAPTER        11
                                                         Model Calibration


11.1 INTRODUCTION

Historically, theoretical valuation has been seen as a process where a number of input param-
eters of a model or formula determine the price/value of a derivative instrument. The fun-
damental assumption behind this reasoning is that you can observe, in principle, anything in
the markets that finally determines the price/value of a security‚Äîmarkets should be, after all,
informationally efficient. A major example is the Black-Scholes-Merton formula which takes
as input six variables‚Äîinitial price level of the underlying, the underlying‚Äôs volatility, the
strike price of the option at hand, time-to-maturity, short rate and maybe dividends paid by the
underlying. If you put in numerical values for the six variables, the formula returns a value for
the option at hand.
      However, if ‚Äúthe market is always right‚Äù, what does a model price/value mean which
deviates from an observable market value? As earlier chapters discuss, market-based valuation
refers to the process where more complex derivatives are valued ‚Äúin consistency‚Äù with observed
market prices of plain vanilla derivatives. Therefore, today‚Äôs valuation practice requires in the
first place that valuation models be capable of replicating observed market values of vanilla
products sufficiently well.
      This chapter is concerned with the calibration of the general market model to observed
market quotes for such vanilla products, i.e. European call options in particular. In comparison
to the historical approach, instrument prices/values are not the objective of the effort in the
first place. The objective is rather to get a parameter set for a certain model that leads to
market-consistent values for vanilla products. In that sense, the whole theoretical valuation
procedure is turned upside down.
      Section 11.2 concerns itself with some fundamental questions in the context of model
calibration (like which market data to use). Section 11.3 calibrates the CIR85 short rate model
to the Euribor term structure. Finally, section 11.4 implements a calibration procedure for the
equity component of the BCC97 model, based on EURO STOXX 50 European call option
quotes. As before, a complete set of self-contained Python scripts is provided.

11.2 GENERAL CONSIDERATIONS

In Chapter 8 calibration is done ‚Äúad hoc‚Äù. However, when calibrating a financial market
model, fundamental questions arise that have to be carefully addressed. This sub-section


                                                                                             223
224                                                             DERIVATIVES ANALYTICS WITH PYTHON


briefly discusses the most important ones against the background of the book‚Äôs main
objectives.


11.2.1 Why Calibration at All?
In a narrow sense (i.e. in the theory of continuous processes), market incompleteness implies
that a given derivative asset cannot be replicated perfectly by trading in its underlying(s) (cf.
BjoÃàrk (2004), ch. 8 and ch. 15). In a wider sense (i.e. in the theory of processes with jumps),
market incompleteness implies that a given derivative asset cannot be replicated perfectly even
if trading in all available (derivative) assets is allowed (cf. Cont and Tankov (2004a), ch. 9
and ch. 10).
      Regarding the special cases of the general market model ÓàπBCC97 , one can say the
following. The model of BSM is complete. The model of H93 is incomplete in a narrow sense
but complete in a wider sense since a derivative asset generally can be replicated by trading
in both the underlying and another derivative asset.1 The model of M76 is incomplete even
in a wider sense which is due to the jump component having stochastic jump size. To hedge
jump risk perfectly, an over-countably infinite number of traded assets would be necessary;
of course something not found, neither in practice nor in theory. As Tankov and Voltchkova
(2009), p. 16, point out:

      ‚ÄúSince typically the jump size is not known in advance, the risk associated to jumps
      cannot be hedged away completely: we are in an incomplete market. In this setting,
      the hedging becomes an approximation problem: instead of replicating an option,
      one tries to minimize the residual hedging error.‚Äù

     As a consequence, the model of BCC97 is incomplete in a wider sense, implying that
perfect hedges are not possible. Formally speaking, incompleteness leads to non-uniqueness
of the risk-neutral probability measure Q and to multiple prices of derivative assets consistent
with the absence of arbitrage. A simple example illustrates this insight.

Example 4 (Incomplete Market).           Consider a simple financial market with two dates
t ‚àà {0, 1} and three states of the economy tomorrow, i.e. at t = 1, which occur with equal
probability. There are two assets. First, a risk-less bond Bt which pays tomorrow B1 = 10
units of currency for sure and whose price today is B0 = 10 = (1 + r)‚àí1 ‚ãÖ B1 such that r = 0.0.
Second, a risky security, called the index, which costs S0 = 10 today and pays tomorrow

                                                    ‚éõ20‚éû
                                               S1 = ‚éú10‚éü
                                                    ‚éú ‚éü
                                                    ‚éù0‚é†

    By standard results from linear algebra, the financial market is incomplete (in a narrow
sense) since not every payoff at t = 1 can be replicated via trading in the available securities.2


1
  Roughly speaking, there are two sources of risk in H93‚Äîindex risk and volatility risk‚Äîsuch that one
needs (at least) two instruments to hedge away all risk.
2
  Two linearly independent vectors are not enough to form a basis of the R3 . At least three are necessary.
Model Calibration                                                                            225


Consider now the derivative asset

                                                ‚éõ16‚éû
                                           A1 = ‚éú 4 ‚éü
                                                ‚éú ‚éü
                                                ‚éù0‚é†

which should be valued. Simple calculations show that perfect replication is not possible.
However, absence of arbitrage must hold such that there exists by the Fundamental Theorem
of Asset Pricing (cf. Theorem 1 in Chapter 4 or BjoÃàrk (2004), p. 29) a martingale measure Q
such that

                                               EQ (S t) = S0
                                                0 1
                           ‚áí q1 ‚ãÖ 20 + q2 ‚ãÖ 10 + q3 ‚ãÖ 0 = 10
                                                 ‚áî q2 = 1 ‚àí 2 ‚ãÖ q1

with qs > 0 and q1 + q2 + q3 = 1 for Q to be a (risk-neutral) probability measure. One gets

                                  q1 + (1 ‚àí 2 ‚ãÖ q1 ) + q3 = 1
                                                   ‚áî q3 = q1

As a consequence, every risk-neutral probability measure from the set

                          ‚éß          ‚éõq1 ‚éû ‚éõ ùúà ‚éû                  ‚é´
                          ‚é™                                     1 ‚é™
                      Q = ‚é®Q ‚àà R++ : ‚éúq2 ‚éü ‚â° ‚éú1 ‚àí 2ùúà ‚éü , 0 < ùúà < ‚é¨
                                3

                          ‚é™          ‚éú   ‚éü   ‚éú       ‚éü          4 ‚é™
                                     ‚éùq ‚é† ‚éù ùúà ‚é†
                                       3
                          ‚é©                                       ‚é≠

makes the index a martingale consistent with the absence of arbitrage. Also, every price A0 of
the derivative asset A1 which lies in the open interval ]A0 , A0 [ with

                                    A0 ‚â° EQ(ùúà=0) [A1 ] = 4.0

and

                              A0 ‚â° EQ(ùúà=0.25) [A1 ] = 1 + 8 = 9.0

is consistent with the absence of arbitrage.

     Market incompleteness leaves one with the unsatisfactory situation that there are multiple
prices for derivative assets. To resolve this problem, calibration comes into play. Because
there is, in general, no simple criterion to choose among the possible risk-neutral probability
measures, one has to ask the market for the right one‚Äîthis is what calibration is about. Or as
BjoÃàrk (2004), p. 221, puts it: ‚ÄúQuestion: Who chooses the martingale measure? ‚Ä¶ Answer:
The market!‚Äù
     Therefore, calibration yields the market-consistent risk-neutral probability measure in the
sense that (i) liquidly traded plain vanilla options are priced correctly and (ii) other (exotic)
226                                                           DERIVATIVES ANALYTICS WITH PYTHON


derivatives are priced such that prices are both consistent with the absence of arbitrage and
indeed unique.


11.2.2 Which Role Do Different Model Components Play?
Formally speaking, calibration means to find parameters for a given model such that it is
market-consistent as explained before. Chapter 8 shows that the model of M76 is not capable
of perfectly replicating prices for multiple strikes and maturities. However, for the short
maturity and a subset of option prices the fit is pretty good. Therefore, the jump component
of the general model of BCC97 will take care of short-term option prices. On the other hand,
it is well-known (cf. Gatheral (2006), ch. 3) that the model of H93 is capable of replicating
option prices of longer maturities pretty well. Therefore, when calibrating a financial market
model simultaneously to short as well as longer maturities one needs both a jump component
and stochastic volatility. Gallucio and Le Cam (2008), p. 9, conclude:

      ‚Äú‚Ä¶ no matter how parameters are chosen, it is impossible to make a pure [stochastic
      volatility] or jumps model consistent with the observed shape of the smile ‚Ä¶ This
      further reinforces the view that option markets are consistent with the simultaneous
      presence of both jumps and stochastic volatility in the asset dynamics.‚Äù

     The model of B96 is one of the simplest to accommodate both jumps and stochastic
volatility.3 Its attractiveness further stems from the fact that the two sub-models, H93 and
M76, are well understood and widely applied in theory and practice.
     What about stochastic short rates? It is well-known that the impact of short rate volatility
is almost negligible when calibrating models to short maturity option prices (cf. Bakshi et al.
(1997)). However, the longer the maturities become the more important becomes short rate
volatility such that it obviously cannot be neglected in the context of equity derivatives‚Äîwhich
can have pretty long maturities.4
     Stochastic short rates play a dual role in the general market model. First, they are important
factors in the risk-neutral valuation and hedging of derivative assets in general. Second, they are
central for determining present values of deterministic cash flows, like, for instance, liabilities
or cash flows from bonds. Again, the model of CIR85 is well understood and widely applied
(cf. BjoÃàrk (2004), ch. 22, or Brigo and Mercurio (2006)) and therefore an obvious choice.
     The short rate model is to be calibrated to the term structure of interest rates such that it is
replicated reasonably well and short rate sensitive instruments, like bonds, options on bonds
or swaptions are correctly priced. Due to the zero correlation between the short rate and the
index model, the task of calibrating the general model can be separated in two independent
procedures.

3
  There exist richer models that allow, among others, for time-dependent parameters (cf. Galluccio and
Le Cam (2008)), jumps in the volatility process (cf. Duffie et al. (2000)) or generalizations of the H93
volatility process (cf. Grzelak et al. (2012)).
4
  Many life insurance products, like variable annuities with guarantee components, have features that
resemble typical equity derivatives. This requires that they be valued/priced accordingly as well as
hedged like equity derivatives by the insurance company. Such products tend to have relatively long
maturities typically well beyond 10 years and up to 30 years.
Model Calibration                                                                                   227


11.2.3 What Objective Function?
To calibrate a financial market model, one needs a performance yardstick for the quality of
the calibration‚Äîformally, an objective or error function which is to be minimized. In general,
model selection and selection of an objective or error function are treated as separate tasks.
However, as Christoffersen and Jacobs (2004), pp. 314‚Äì315, point out:

      ‚ÄúThe key is that one should stop thinking of the specification of a theoretical model
      as separate from the choice of the loss function. When operationalizing a determin-
      istic theoretical model, whether for estimation or evaluation purposes, one has to
      impose a statistical structure. This statistical structure is an integral part of empirical
      model specification, and the choice of loss function is a major part of the statistical
      structure.‚Äù

    A multitude of candidate objective functions is available, three of which Christoffersen
and Jacobs analyze in detail:

   mean squared error (MSE) of the price differences in currency units
   MSE of the relative price differences
   MSE of the implied volatility differences



They identify these to be among the most commonly used in the literature. The first one takes
on the form

                                          1 ‚àë( ‚àó
                                             N
                                                               )2
                                    min         Cn ‚àí Cnmod (p)                                 (11.1)
                                     p    N n=1

with the Cn‚àó being the market or input prices and the Cnmod being the model or output prices
for options n = 1, ‚Ä¶ , N given parameter vector p. For example, Bakshi et al. (1997) and
Reinsberg (2006) use this particular function for the calibration. The second one is similar but
includes a scaling term
                                                    (                     )2
                                       1 ‚àë
                                            N
                                                        Cn‚àó ‚àí Cnmod (p)
                                   min                                                         (11.2)
                                    p N
                                         n=1
                                                             Cn‚àó

Finally, the third one resembles the first one with the option prices replaced by the implied
volatilities

                                          1 ‚àë( ‚àó
                                                N
                                                               )2
                                    min         ùúén ‚àí ùúénmod (p)                                 (11.3)
                                      p   N n=1

Here, ùúén‚àó is the volatility that gives a BSM option value equal to Cn‚àó and ùúénmod analogous. These
values are called market and model implied volatilities, respectively.
     Christoffersen and Jacobs (2004) stress that the choice of an objective function for
calibration purposes should take into account the specific objective itself (e.g. valuation,
228                                                             DERIVATIVES ANALYTICS WITH PYTHON


hedging, speculation). Although they do not favor one function over another, they find that
their ‚Äú‚Ä¶ results indicate that the $MSE estimates perform the best across different loss func-
tions. The $MSE may thus serve as a good general-purpose loss function in option valuation
applications‚Äù (p. 316). By $MSE they mean function (11.1).
     Regarding functions (11.1)‚Äì(11.3) it is not uncommon to include a square root to obtain
RMSE instead of MSE (cf. Chapter 8 function (8.4); Schoutens et al. (2004) also use RMSE
alongside other candidate functions). Also, some authors include weighting terms (like vega,
bid-ask spread or implied volatility of the respective option), cf. Cont and Tankov (2004b)
and Detlefsen (2005), to avoid biases due to the error function specification.5 Additionally,
it cannot be excluded that the function to be minimized has multiple local minima such that
it is not assured that‚Äîdepending on the optimization algorithm‚Äîthe global minimum is
identified. Some regularization procedure might be necessary in such a case (cf. Cont and
Tankov (2004b), Galluccio and Le Cam (2008)).
     Often the implied volatilities are the target of the calibration procedure. This chapter
illustrates this approach as well, making use of a variant of function (11.3). In particular, we
use the following error function specification:
                                        (                     )2
                                  1 ‚àë ( ‚àó
                                     N
                                                     ) ùúïCnBSM
                              min         ùúén ‚àí ùúén (p) ‚ãÖ
                                                mod
                                                                                                    (11.4)
                               p N
                                    n=1
                                                        ùúïùúén‚àó

Here, the differences between the model and market implied volatilities are respectively
weighted by the vega of the Black-Scholes-Merton option price at the market implied volatility.
This approach takes into account how sensitive vanilla options are with respect to changes in
volatility for different strikes and maturities. A look at Figure 5.7 in Chapter 5 reveals that
vega in general increases with closeness to the ATM strike level and with longer maturities.
This error function specification therefore gives, for example, less weight to implied volatility
differences for short-term far ITM or OTM options.
     In this chapter, function (11.1) is used throughout for the calibration to market quotes
since this specification is in line with the main objective ‚Äúvaluation‚Äù and since corresponding
numerical results are accurate enough in view of the chapter‚Äôs general scope.6 When calibrating
to implied volatilites‚Äîwith the main objective, for example, being ‚Äúhedging‚Äù‚Äîfunction (11.4)
is used.


11.2.4 What Market Data?
The first question regarding market data of course is what the relevant index is when analyzing
equity index derivatives. This generally is pretty easy to answer; S&P 500, EURO STOXX
50, DAX or SMI could be candidates. The second is also relatively easy: which interest
rates, yields, bond prices, etc. to use for the calibration of the short rate model. The third‚Äî
more difficult to answer‚Äîquestion is about the concrete option quotes to be included in the

5
  For example, in function (11.1) options with high prices possibly gain too much weight while in function
(11.2) this is the case for options with prices near zero; cf. Bakshi et al. (1997), p. 2016.
6
  Numerical experiments conducted with a Python script regarding the two functions RMSE (8.4) and
MSE (11.1) suggest that there are, if at all, only negligible differences in terms of optimization speed or
accuracy.
Model Calibration                                                                                     229


calibration. If one has decided upon the option provider itself‚Äîsay, for example, the Eurex
for the EURO STOXX 50 index‚Äîthe decision is about the option maturities and strikes to be
included. In addition, there are different quotes per option, like bid, ask, last and settlement
price. For discussions in this regard refer to Bakshi et al. (1997) or Detlefsen (2005). There is
also no guarantee that market prices are arbitrage-free such that the need to adjust raw market
data may arise (cf. Fries (2008), Kahale (2004)).
     Section 11.4 implements an approach similar to the one of Galluccio and Le Cam (2008)
who propose to use (at least) three different options per maturity. They choose the at-the-
money (ATM) option, one in-the-money (ITM) option and one out-of-the-money (OTM)
option because ‚Äú[t]his is the minimal number of instruments to calibrate ATM volatility level,
smile slope and convexity for a given maturity‚Äù
                                             ‚àö     (p. 20). For the ITM and‚àö  OTM option strike
levels they propose K ITM  =K   ATM +ùúé  ATM    T and K OTM    =K ATM  ‚àíùúé ATM    T, respectively.
     Somewhat deviating from the suggestions in Galluccio and Le Cam (2008), we use a set
of 15 market quotes for European call options as follows:

       maturities: three maturities (all shorter than 1 year)
       strikes: five strikes per maturity

     In summary, since the subsequent analysis focuses on equity derivatives on the EURO
STOXX 50 index, the following market data is used for calibration of the BCC97 model (all
data from 30. September 2014):

       short rate component (section 11.3): Eonia rate and Euribor rates (up to 1 year)7
       equity component (section 11.4): European call options on the EURO STOXX 50 offered
        by the Eurex in Frankfurt


11.2.5 What Optimization Algorithm?
The calibration in Chapter 8 uses a two-step procedure: global minimization (i.e. brute force)
followed by local minimization. In what follows, this approach is augmented by another, higher
ranking four-step procedure. First, the stochastic short rate model is calibrated. Second, the
H93 stocahstic volatility model is calibrated via global and local optimization. Third, taking as
input the results from the stochastic volatility calibration, the jump component of the general
market model BCC97 is calibrated‚Äîfirst via global and then via local optimization. Lastly,
the stochastic volatility component of BCC97 is calibrated‚Äîvia local optimization, taking
as input the results of all other calibrations. During the last step, the jump parameters are,
however, freed again to attain a better overall fit.8


7
  Cf. Hull and White (2013) for an in-depth discussion of the appropriate risk-free discounting rate for
derivative instruments. As in FilipovicÃÅ (2009), p. 8, Euribor rates are considered risk-free rates in this
book.
8
  Note that this procedure is only possible since the general market model assumes zero correlation
between the short rate and the equity component. In principle, the general market model could be
calibrated in a single step, at the cost of having a high dimensional parameter space leading to a pretty
high computational burden for the single step.
230                                                                DERIVATIVES ANALYTICS WITH PYTHON


     Regarding global and local optimization algorithms there are a number of candidates
available. Detlefsen (2005) and Mikhailov and NoÃàgel (2003) discuss this topic in the context
of option model calibration. Liberti (2008) offers a more general and more comprehensive
discussion of alternative optimization algorithms.



11.3 CALIBRATION OF SHORT RATE COMPONENT

This section provides the required tool set to calibrate the CIR85 short rate model to market
rates.


11.3.1 Theoretical Foundations
The short rate model of CIR85 is widely applied in theory and practice. This section does
not treat it in its full richness but concentrates rather on the calibration procedure for
which only several standard results are needed.9 Recall the CIR85 stochastic differential
equation (9.3)

                                                            ‚àö
                                  drt = ùúÖr (ùúÉr ‚àí rt )dt + ùúér rt dZt

    The task of calibration is to minimize, for all considered times t and a parameter set
ùõº = (ùúÖr , ùúÉr , ùúér , r0 ), simultaneously the differences

                                 Œîf (0, t) ‚â° f (0, t) ‚àí f CIR85 (0, t; ùõº)

where f (0, t) is the current market implied forward rate for time t and f CIR85 (0, t; ùõº) is the
current model implied forward rate for time t given parameter set ùõº. If Bt (T), t < T, denotes
the time t price of a zero-coupon bond maturing at time T and paying one unit of currency at
that date, then the (instantaneous) forward rate at time t for time T is defined by

                                                        ùúïBt (T)
                                         f (t, T) ‚â° ‚àí                                          (11.5)
                                                         ùúïT

with f (0, t) as an obvious special case. Furthermore, the short rate at time t follows from
rt = f (t, t). The other way round (cf. BjoÃàrk (2004), p. 305) zero-coupon bond prices are
uniquely determined by the forward rate curve

                                              (            T                )
                                  Bt (T) = exp ‚àí               f (t, s)ds
                                                      ‚à´t


9
Svoboda (2002) provides a detailed account of the CIR85 model and a number of alternative short rate
models. For a comprehensive overview of interest models in general refer to Brigo and Mercurio (2006).
Model Calibration                                                                                       231


     With this background knowledge, the usefulness of the following formula for the forward
rates in the CIR85 short rate model becomes clear10

                                                     ùúÖr ùúÉr (eùõæt ‚àí 1)
                           f CIR85 (0, t; ùõº) =
                                                 2ùõæ + (ùúÖr + ùõæ)(eùõæt ‚àí 1)
                                                                 4ùõæ 2 eùõæt
                                                 + r0                                                (11.6)
                                                        (2ùõæ + (ùúÖr + ùõæ)(eùõæt ‚àí 1))2

where
                                                   ‚àö
                                             ùõæ‚â°     ùúÖr2 + 2ùúér2

with the parameters and variables as defined in section 9.2.
     The time t price a of zero-coupon bond maturing at time T and paying one unit of currency
is given by the affine formula11

                                                                   Q
                                      Bt (T) = a(t, T)e‚àíb(t,T)E0 (rt )                               (11.7)

where

                                       [                                 ] 2ùúÖr ùúÉr
                                      2ùõæ exp(0.5(ùúÖr + ùõæ)(T ‚àí t))            ùúér2
                            a(t, T) ‚â°                                                                (11.8)
                                      2ùõæ + (ùúÖr + ùõæ)(eùõæ(T‚àít) ‚àí 1)

and

                                                   2(eùõæ(T‚àít) ‚àí 1)
                                 b(t, T) ‚â°                                                           (11.9)
                                             2ùõæ + (ùúÖr + ùõæ)(eùõæ(T‚àít) ‚àí 1)

For the expectation value of rt it holds EQ (r ) = ùúÉr + e‚àíùúÖr t (r0 ‚àí ùúÉr ).
                                          0 t
     This completes the tool set for the calibration of the CIR85 model.12


11.3.2 Calibration to Euribor Rates
Forward rates are seldom quoted directly in the market. However, what is generally publicly
available is yields, reference or swap rates, like US Treasury yields, German Bund yields,
LIBOR, Euribor, OIS or Eonia spot rates and respective swap rates, for different maturities.

10
   The formula presented is from London (2005), pp. 542 and 433. Heath, Jarrow and Morton (Heath
et al., 1992), pioneered the approach of taking the forward rate curve as initial input for the modeling of
interest rates.
11
   In general, it is a desirable feature of short rate models to be affine. This is due to the fact that such
models yield essentially closed-form expressions for zero-coupon bond prices. Cf. Dai and Singleton
(2000).
12
   Refer to Svoboda (2002) for a detailed derivation of the bond formula (11.7) with (11.8) and (11.9)
from which the forward rate formula (11.6) follows via (11.5).
232                                                       DERIVATIVES ANALYTICS WITH PYTHON


    There is a one-to-one correspondence between zero-coupon bond yields for different
maturities and forward rates via (cf. Baxter and Rennie (1996), p. 134)

                                                      ùúïY(0, T)
                               f (0, T) = Y(0, T) +            ‚ãÖT                       (11.10)
                                                        ùúïT
with Y(0, T) as the yield today of a bond maturing at T. The (continuous) yield for a zero-
coupon bond solves the equation

                                BT (T) = B0 (T)eY(0,T)‚ãÖT
                                         log BT (T) ‚àí log B0 (T)
                             ‚áî Y(0, T) =
                                                    T
With the final value of the bond normalized to 1, one has

                                                  log(B0 (T))
                                    Y(0, T) = ‚àí
                                                      T
The same relationship holds true for continuous Euribor rates analogously. For coupon bonds,
the formula is not as simple because the single coupon payments up to maturity have to be
accounted for (cf. FilipovicÃÅ (2009), ch. 3).
     Unfortunately, spot rates and bond yields are generally only quoted for selected, dis-
crete maturities so that the need arises to interpolate between the single data points. With a
continuously differentiable interpolating function‚Äîe.g. from a cubic splines regression (cf.
Brandimarte (2006), pp. 183‚Äì188)‚Äîone can derive the partial derivative in (11.10) and there-
with forward rates for arbitrary times T.
     Euribor rates are quoted on a 30/360 day count basis. For what follows, Euribor rates
therefore have to be transformed into continuous rates (continuous yield of a unit zero-coupon
bond). As an example, take the 6-month Euribor rate which is 0.043%. The corresponding
factor is

                                fs6m = 1 + 180‚àï360 ‚ãÖ 0.00043

The equivalent annualized continuous rate then is

                                  fc6m = 360‚àï180 ‚ãÖ log (fs6m )

This ensures that
                                                                 6m
                               1 + 180‚àï360 ‚ãÖ fs6m = e180‚àï360‚ãÖfc

holds.
      The Python script in sub-section 11.6.1 implements this transformation and the necessary
interpolation for the Euribor term structure from 30. September 2014. The Euribor data set is
complemented by the Eonia rate as the time t = 0 short rate (‚Äúmaturity of one day‚Äù) from 01.
October 2014.
      Figure 11.1 shows the spot rates for different maturities, the interpolated rate curve and
its first derivative.
Model Calibration                                                                                    233




     FIGURE 11.1 Euribor term structure up to 12 months (incl. Eonia rate); points = market
     quotes from 30. September 2014, line = interpolated curve, dashed line = 1st derivative of
     term structure curve



     To calibrate the CIR85 model to the forward rates, the MSE of the market implied and
model implied forward rate curve at selected discrete points in time is minimized. Given a
fixed r0 and an equidistant spacing of [0, T] by Œît with M ‚â° T‚àïŒît, the task is to


                                  1 ‚àë
                                      M
                            min         (f (0, mŒît) ‚àí f CIR85 (0, mŒît; ùõº))2                      (11.11)
                              ùõº   M m=0


A respective algorithm is found in the Python script of sub-section 11.6.1. The results of the
calibration are shown graphically in Figure 11.2.13
     Finally, Figure 11.3 shows values for a unit zero-coupon bonds maturing 2 years out
according to the bond valuation formula for the CIR85 model as provided in (11.7) and given
the calibration results.



11.4 CALIBRATION OF EQUITY COMPONENT

This section now deals with the required tools and approaches to calibrate the BCC97 market
model to market observed option quotes.


13
  Using a deterministic-shift approach, one can make the calibration of the model perfect while preserving
the affine structure. Cf. Brigo and Mercurio (2001).
FIGURE 11.2 Market and model implied forward rates for Euribor; line = market forward rates
from 30. September 2014, dots = model implied forward rates; bars = the difference between the
model and market forward rates




    FIGURE 11.3     Unit zero-coupon bond values at time t maturing at time T = 2
Model Calibration                                                                            235


11.4.1 Valuation via Fourier Transform Method
The previous section provides a calibrated short rate model so that market consistent short
rates are now available for the valuation of plain vanilla European call options. This is the
major prerequisite for the calibration of the general market model in terms of the equity
component. This section applies the Fourier transform method and makes heavy use of the
following formula for call options
                                                  ‚àö     1
                           C0 (K, T) = S0 ‚àí B0 (T) S0 K
                                                        ùúã
                                               ‚àû
                                                                               du
                                      ‚ãÖ            Re[e‚àíiuk ùúô0 (u ‚àí i‚àï2, T)] 2            (11.12)
                                          ‚à´0                                u + 1‚àï4
with k ‚â° log(S0 ‚àïK) and ùúë0 the characteristic function of the model at hand‚Äîin our case
ÓàπBCC97 . B0 (T) is the appropriate discount factor, i.e. bond present value, for the option
maturity from the calibrated CIR85 model. The related Python scripts work with a constant
short rate where a value rÃÑ is used that solves the equation B0 (T) = e‚àíÃÑrT . This is made for
simplicity and is possible because of European exercise. Sub-section 9.7.3 offers Python
implementations for the BCC97 model and the special cases of M76 and H93.
     The script in sub-section 9.7.3 provides characteristic function implementations for M76
(on a stand-alone basis), for H93 (on a stand-alone basis) and for BCC97 (combination of H93
and jump component of M76). The characteristic function of the BCC97 model with constant
short rate is simply the product of the characteristic function of the M76 jump component (see
also equations (6.14) and (6.15))

                                   (u, T) = exp((iuùúî + ùúÜ(eiuùúáJ ‚àíu ùõø ‚àï2 ‚àí 1))T)
                                                                     2 2
                             ùúëM76J
                              0
                                                                                          (11.13)

where the risk-neutral drift (correction) term ùúî takes now on the form

                                           ùúî ‚â° ‚àíùúÜ(eùúáJ +ùõø ‚àï2 ‚àí 1)
                                                             2
                                                                                          (11.14)

and the characteristic function of the H93 model14

                                      ùúëH93
                                       0
                                           (u, T) = eH1 (u,T)+H2 (u,T)v0                  (11.15)

with the following definitions

                      c1 ‚â° ùúÖv ùúÉv
                            ‚àö
                      c2 ‚â° ‚àí (ùúåùúév ui ‚àí ùúÖv )2 ‚àí ùúév2 (‚àíui ‚àí u2 )
                           ùúÖv ‚àí ùúåùúév ui + c2
                      c3 ‚â°
                           ùúÖv ‚àí ùúåùúév ui ‚àí c2
                                          {                           [              ]}
                                       c                                1 ‚àí c1 ec3 T
               H1 (u, T) ‚â° r0,T uiT + 12 (ùúÖv ‚àí ùúåùúév ui + c2 )T ‚àí 2 log
                                       ùúév                                 1 ‚àí c3
                                            [              ]
                           ùúÖ ‚àí ùúåùúév ui + c2 1 ‚àí e 2   c T
               H2 (u, T) ‚â° v
                                   ùúév2        1 ‚àí c3 ec2 T

14
     See Cherubini et al. (2009), app. G, Gatheral (2006), ch. 2, or Heston (1993).
236                                                             DERIVATIVES ANALYTICS WITH PYTHON


and all variables as defined as before. In H1 we set r0,T = ‚àí log(B0 (T))‚àïT where we get B0 (T)
from equations (9.4)‚Äì(9.7) for the CIR85 model.
     Therefore, the characteristic function for BCC97 with constant short rate is the product
of (11.15) and (11.13)
                                 ùúëBCC97
                                  0
                                        (u, T) = ùúëH93
                                                  0
                                                      ‚ãÖ ùúëM76J
                                                         0
                                                              (u, T)                           (11.16)

         This completes the necessary ingredients for the calibration of the equity component.


11.4.2 Calibration to EURO STOXX 50 Option Quotes
To have a small but still meaningful subset of market prices in terms of maturities, the
subsequent analysis considers three maturities:

      17. October 2014 (17 days)
      19. December 2014 (80 days)
      20. March 2015 (171 days)



Maturity day generally is the third Friday of the month if this is a business day.
    Per maturity, we consider five different strikes: 3,000, 3,100, 3,200, 3,300, 3,400‚Äîgiven
a spot closing level of 3,225.93 of the EURO STOXX 50 on 30. September 2014.
    The calibration is done for the EURO STOXX 50 index and on the basis of European call
options from the Eurex.15 The calibration takes a total of 15 European call option quotes into
account.
    Before proceeding, the right short rates have to be derived from the calibrated CIR85
model since the Fourier transform pricing formula is for constant short rates only. One can
recover the right short rate for option maturity T in knowledge of the bond price B0 (T) via

                                                       log B0 (T)
                                        rÃÑ ‚àó (T) = ‚àí
                                                           T
which is equivalent to the continuous yield of the respective zero-coupon bond. This approach
is used in the calibration scripts to derive equivalent constant short rates for each maturity,
respectively.


11.4.3 Calibration of H93 Model
Before going on to the general market model BCC97, we look first at a model calibration of
the H93 stochastic volatility model without jump component. Sub-section 11.6.2 contains the
Python script for the model calibration.
     Figure 11.4 shows the results of the calibration which are already quite good. The MSE
of this calibration is 0.307 and the optimal parameters are as follows:

        ùúÖv = 18.447
        ùúÉv = 0.026

15
  Reinsberg (2006), for example, is an empirical study of option pricing models similar to Bakshi et al.
(1997) and also with the EURO STOXX 50 as the benchmark index.
Model Calibration                                                                                 237




         FIGURE 11.4 Results of H93 model calibration to EURO STOXX 50 option quotes; line =
         market quotes from 30. September 2014, red dots = model values after calibration


      ùúév = 0.978
      ùúå = ‚àí0.821
      v = 0.035
        0

     Figure 11.5 shows the resulting model implied volatilities compared to the market implied
volatilities‚Äîincluding absolute differences. The figures are generated with the Python script
in sub-section 11.6.3. The implied volatility fit is also quite good.

11.4.4 Calibration of Jump Component
It is well-known that the problem of calibrating a jump-diffusion model‚Äîand in particular the
M76 one‚Äîsuffers from two major problems (cf. the in-depth discussion in Galluccio and Le
Cam (2008)):

      degeneracy: different parameter combinations may yield the same values for the error
       function
      indeterminacy: the error function is not strictly convex and may exhibit many local

       minima

This so-called ill-posedness is of importance when calibrating models for the first time but in
particular when re-calibrating them. Practitioners look for stable parameters in calibrations16

16
  This is mainly due to the fact that in general hedging programs depend on the parameters of the model
used. Strongly varying parameters could therefore lead to highly oscillating hedge positions.
238                                         DERIVATIVES ANALYTICS WITH PYTHON




      FIGURE 11.5 Implied volatilities from H93 model calibration
      to EURO STOXX 50 option quotes from 30. September 2014
Model Calibration                                                                                239


and with degeneracy and indeterminacy parameters might ‚Äújump‚Äù significantly when re-
calibrating models. A solution to this is the regularization of the error function‚Äîwhere MSE
is used in the following‚Äîvia, for example, Tikhonov regularization. To this end, the error
function used for the local optimization is enhanced by a penalty term of the form (cf.
Cherubini et al. (2009))
                                                     ‚àö
                                      Penalty(p) ‚â°       (p0 ‚àí p)2                            (11.17)

where p0 is the initial input parameter vector for the local optimization (here coming from
the global optimization) and p the current parameter vector. Term (11.17) penalizes deviations
from the initial inputs‚Äîand thereby avoids unjustifiable deviations from the preliminary global
optimum and undesired jumps of parameter values.
     The problem of calibrating the BCC97 model therefore is (cf. equation (11.1)) in its
general form, including the penalty term

                             1 ‚àë( ‚àó
                                  N
                                                   )2
                         min       Cn ‚àí CnBCC97 (p) + w ‚ãÖ Penalty(p)
                          p N
                               n=1

with the Cn‚àó being the market or input prices and the CnBCC97 being the model or output prices
given parameter vector p. w is a weighting parameter which can be used to give the penalty
more influence if necessary.
    Sub-section 11.6.4 contains the Python script that implements the second part of the equity
component calibration. Here the jump part of the equity component is calibrated to the five
options with the shortest maturity, first via global then via local optimization using Tikhonov
regularization. The script uses the results of the H93 calibration for the stochastic volatility
parametrization. The calibration yields the following optimal results:

   ùúÜ = 0.008
   ùúá = ‚àí0.600
   ùõø = 0.001



    Figure 11.6 shows the calibration results graphically. The fit for the shortest maturity has
an MSE of 0.558.

11.4.5 Complete Calibration of BCC97 Model
In the third part of the equity component calibration, the results from the H93 model calibration
and from the jump component calibration are taken as input parameters (ùúÖv , ùúÉv , ùúév , ùúå, v0 , ùúÜ, ùúá, ùõø)
for the local optimization procedure. The Python script in sub-section 11.6.5 calibrates the
BCC97 model to all options and simultaneously derives‚Äîvia local optimization‚Äîoptimal
values for all parameters of BCC97 (with constant but maturity-dependent short rate). The
MSE decreases to a rather low 0.104 and the optimal parameters are:

   ùúÖv = 22.212
   ùúÉv = 0.025
   ùúé = 0.952
     v
240                                                       DERIVATIVES ANALYTICS WITH PYTHON




FIGURE 11.6 Results of BCC97 jump-diffusion part calibration to five European call options on the
EURO STOXX 50 with 17 days maturity; market quotes from 30. September 2014


   ùúå = ‚àí0.999
   v0 = 0.036
   ùúÜ = 0.008

   ùúá = ‚àí0.501
   ùõø = 0.000



    Figure 11.7 compares the market quotes with the option values generated by the calibrated
BCC97 model.
    Finally, Figure 11.8 compares the market implied volatilities with the model implied
volatilities after calibration of the BCC97 model.


11.4.6 Calibration to Implied Volatilities
Depending on the specific purpose of the calibration a good implied volatility fit may
be more important than a good price fit. This final sub-section, therefore, calibrates the
BCC97 model to market implied volatilities directly. To this end, one needs to calcu-
late market implied volatilities first and model implied volatilities per iteration of local
optimization runs.
Model Calibration                                                                              241




       FIGURE 11.7 Results of simultaneous BCC97 jump-diffusion and stochastic
       volatility part calibration to 15 European call options on the EURO STOXX 50 with 17,
       80 and 171 days maturity, respectively; quotes from 30. September 2014



     The Python script in sub-section 11.6.6 implements a local calibration procedure in this
regard, taking the optimal parameters from the previous BCC97 model calibration (to market
quotes) as starting values. The major difference is the specification of the error function
according to (11.4). The vega-weighted MSE in this case is pretty low with 0.083 for the
following optimal parameters:


   ùúÖv = 28.473
   ùúÉv = 0.025
   ùúé = 1.175
     v
   ùúå = ‚àí0.953
   v = 0.039
     0
   ùúÜ = 0.007
   ùúá = ‚àí0.600
   ùõø = 0.000




     Figure 11.9 shows the resulting model values compared to the market quotes of the EURO
STOXX 50 call options. Although not the direct target of the optimization, the value fits are
again quite good.
     Figure 11.10 shows the resulting model implied volatilities compared to the market implied
volatilities. Here, it is important to recall that the error function (11.4) gives less weight to
errors for (far) OTM/ITM options and more weight to errors for options with longer maturities
ceteris paribus.
242                                         DERIVATIVES ANALYTICS WITH PYTHON




      FIGURE 11.8 Implied volatilities from BCC97 model
      calibration to EURO STOXX 50 option quotes from 30.
      September 2014
Model Calibration                                                                         243




           FIGURE 11.9 Results of BCC97 calibration to 15 market implied volatilities
           of EURO STOXX 50 European call options with 17, 80 and 171 days maturity,
           respectively; market quotes from 30. September 2014



11.5 CONCLUSIONS

‚ÄúThe market is always right.‚Äù This is the credo of this chapter. In this sense, the chapter
takes market interest rates and market quotes for plain vanilla instruments as given and tries
to find‚Äîby global and local optimization‚Äîthose parameters for the BCC97 model that best
replicate the observed option quotes.
     A central question in this context is to what market data one should try to calibrate
the model. This question cannot be answered with any generality. The answer depends, in
a complex fashion, on the task at hand and on the particular products one wishes to trade,
price/value or hedge.
     However, the chapter illustrates that the model of BCC97 is rich enough to replicate
observed yields and option quotes as well as implied volatilities of quoted options reasonably
well. Equipped with a market-calibrated model, the next two chapters can now proceed with
the market-based valuation and hedging of equity derivatives, respectively.



11.6 PYTHON SCRIPTS FOR COX-INGERSOLL-ROSS MODEL

11.6.1 Calibration of CIR85

#
# Calibration of CIR85 model
# to Euribor Rates from 30. September 2014
# 11_cal/CIR_calibration.py
#
244                                           DERIVATIVES ANALYTICS WITH PYTHON




      FIGURE 11.10 Implied volatilities from BCC97 model
      calibration to EURO STOXX 50 implied volatilities from 30.
      September 2014
Model Calibration                                                     245


# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.append('10_mcs')
import math
import numpy as np
np.set_printoptions(suppress=True,
                    formatter={'all': lambda x: '%7.6f' % x})
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
import scipy.interpolate as sci
from scipy.optimize import fmin
from CIR_zcb_valuation_gen import B

#
# Market Data: Eonia rate (01.10.2014) + Euribor rates
# Source: http://www.emmi-benchmarks.eu
# on 30. September 2014
#
t_list = np.array((1, 7, 14, 30, 60, 90, 180, 270, 360)) / 360.
r_list = np.array((-0.032, -0.013, -0.013, 0.007, 0.043,
                      0.083, 0.183, 0.251, 0.338)) / 100

factors = (1 + t_list * r_list)
zero_rates = 1 / t_list * np.log(factors)

r0 = r_list[0]


#
# Interpolation of Market Data
#


tck = sci.splrep(t_list, zero_rates, k=3)    # cubic splines
tn_list = np.linspace(0.0, 1.0, 24)
ts_list = sci.splev(tn_list, tck, der=0)
de_list = sci.splev(tn_list, tck, der=1)

f = ts_list + de_list * tn_list
    # forward rate transformation

def plot_term_structure():
     plt.figure(figsize=(8, 5))
     plt.plot(t_list, r_list, 'ro', label='rates')
     plt.plot(tn_list, ts_list, 'b', label='interpolation', lw=1.5)
        # cubic splines
246                                              DERIVATIVES ANALYTICS WITH PYTHON


      plt.plot(tn_list, de_list, 'g--', label='1st derivative', lw=1.5)
        # first derivative
      plt.legend(loc=0)
      plt.xlabel('time horizon in years')
      plt.ylabel('rate')
      plt.grid()



#
# Model Forward Rates
#
def CIR_forward_rate(opt):
      ''' Function for forward rates in CIR85 model.


      Parameters
      ==========
      kappa_r: float
          mean-reversion factor
      theta_r: float
          long-run mean
      sigma_r: float
          volatility factor


      Returns
      =======
      forward_rate: float
          forward rate
      '''
      kappa_r, theta_r, sigma_r = opt
      t = tn_list
      g = np.sqrt(kappa_r ** 2 + 2 * sigma_r ** 2)
      sum1 = ((kappa_r * theta_r * (np.exp(g * t) - 1)) /
            (2 * g + (kappa_r + g) * (np.exp(g * t) - 1)))
      sum2 = r0 * ((4 * g ** 2 * np.exp(g * t)) /
              (2 * g + (kappa_r + g) * (np.exp(g * t) - 1)) ** 2)
      forward_rate = sum1 + sum2
      return forward_rate


#
# Error Function
#
def CIR_error_function(opt):
    ''' Error function for CIR85 model calibration. '''
      kappa_r, theta_r, sigma_r = opt
      if 2 * kappa_r * theta_r < sigma_r ** 2:
          return 100
      if kappa_r < 0 or theta_r < 0 or sigma_r < 0.001:
Model Calibration                                                         247


         return 100
     forward_rates = CIR_forward_rate(opt)
     MSE = np.sum((f - forward_rates) ** 2) / len(f)
     # print opt, MSE
     return MSE


#
# Calibration Procedure
#
def CIR_calibration():
    opt = fmin(CIR_error_function, [1.0, 0.02, 0.1],
            xtol=0.00001, ftol=0.00001,
             maxiter=300, maxfun=500)
     return opt


#
# Graphical Results Output
#
def plot_calibrated_frc(opt):
    ''' Plots market and calibrated forward rate curves. '''
     forward_rates = CIR_forward_rate(opt)
     plt.figure(figsize=(8, 7))
     plt.subplot(211)
     plt.grid()
     plt.ylabel('forward rate $f(0,T)$')
     plt.plot(tn_list, f, 'b', label='market')
     plt.plot(tn_list, forward_rates, 'ro', label='model')
     plt.legend(loc=0)
     plt.axis([min(tn_list) - 0.05, max(tn_list) + 0.05,
           min(f) - 0.005, max(f) * 1.1])
     plt.subplot(212)
     plt.grid(True)
     wi = 0.02
     plt.bar(tn_list - wi / 2, forward_rates - f, width=wi)
     plt.xlabel('time horizon in years')
     plt.ylabel('difference')
     plt.axis([min(tn_list) - 0.05, max(tn_list) + 0.05,
           min(forward_rates - f) * 1.1, max(forward_rates - f) * 1.1])
     plt.tight_layout()



def plot_zcb_values(p0, T):
    ''' Plots unit zero-coupon bond values (discount factors). '''
     t_list = np.linspace(0.0, T, 20)
     r_list = B([r0, p0[0], p0[1], p0[2], t_list, T])
     plt.figure(figsize=(8, 5))
     plt.plot(t_list, r_list, 'b')
248                                               DERIVATIVES ANALYTICS WITH PYTHON


      plt.plot(t_list, r_list, 'ro')
      plt.xlabel('time horizon in years')
      plt.ylabel('unit zero-coupon bond value')
      plt.grid()




11.6.2 Calibration of H93 Stochastic Volatility Model

#
# Calibration of Bakshi, Cao and Chen (1997)
# Stoch Vol Jump Model to EURO STOXX Option Quotes
# Data Source: www.eurexchange.com
# via Numerical Integration
# 11_cal/BCC97_calibration_2.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.append('09_gmm')
import math
import numpy as np
np.set_printoptions(suppress=True,
                    formatter={'all': lambda x: '%5.3f' % x})
import pandas as pd
from scipy.optimize import brute, fmin, minimize
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
from BCC_option_valuation import H93_call_value
from CIR_calibration import CIR_calibration, r_list
from CIR_zcb_valuation import B

#
# Calibrate Short Rate Model
#
kappa_r, theta_r, sigma_r = CIR_calibration()


#
# Market Data from www.eurexchange.com
# as of 30. September 2014
#
h5 = pd.HDFStore('08_m76/option_data.h5', 'r')
data = h5['data'] # European call & put option data (3 maturities)
h5.close()
S0 = 3225.93 # EURO STOXX 50 level 30.09.2014
r0 = r_list[0]     # initial short rate
Model Calibration                                                       249



#
# Option Selection
#
tol = 0.02 # percent ITM/OTM options
options = data[(np.abs(data['Strike'] - S0) / S0) < tol]


# options = data[data['Strike'].isin([3100, 3150, 3225, 3300, 3350])]


#
# Adding Time-to-Maturity and Short Rates
#
for row, option in options.iterrows():
    T = (option['Maturity'] - option['Date']).days / 365.
     options.ix[row, 'T'] = T
     B0T = B([kappa_r, theta_r, sigma_r, r0, T])
     options.ix[row, 'r'] = -math.log(B0T) / T


#
# Calibration Functions
#
i = 0
min_MSE = 500
def H93_error_function(p0):
    ''' Error function for parameter calibration in BCC97 model via
    Lewis (2001) Fourier approach.


     Parameters
     ==========
     kappa_v: float
         mean-reversion factor
     theta_v: float
         long-run mean of variance
     sigma_v: float
         volatility of variance
     rho: float
         correlation between variance and stock/index level
     v0: float
         initial, instantaneous variance


     Returns
     =======
     MSE: float
         mean squared error
     '''
     global i, min_MSE
     kappa_v, theta_v, sigma_v, rho, v0 = p0
250                                                DERIVATIVES ANALYTICS WITH PYTHON


      if kappa_v < 0.0 or theta_v < 0.005 or sigma_v < 0.0 or \
                  rho < -1.0 or rho > 1.0:
         return 500.0
      if 2 * kappa_v * theta_v < sigma_v ** 2:
         return 500.0
      se = []
      for row, option in options.iterrows():
          model_value = H93_call_value(S0, option['Strike'], option['T'],
                              option['r'], kappa_v, theta_v, sigma_v, rho, v0)
          se.append((model_value - option['Call']) ** 2)
      MSE = sum(se) / len(se)
      min_MSE = min(min_MSE, MSE)
      if i % 25 == 0:
          print '%4d |' % i, np.array(p0), '| %7.3f | %7.3f' % (MSE, min_MSE)
      i += 1
      return MSE


def H93_calibration_full():
    ''' Calibrates H93 stochastic volatility model to market quotes. '''
    # first run with brute force
      # (scan sensible regions)
      p0 = brute(H93_error_function,
                  ((2.5, 10.6, 5.0),   # kappa_v
                   (0.01, 0.041, 0.01), # theta_v
                   (0.05, 0.251, 0.1), # sigma_v
                   (-0.75, 0.01, 0.25), # rho
                   (0.01, 0.031, 0.01)),   # v0
                   finish=None)


      # second run with local, convex minimization
      # (dig deeper where promising)
      opt = fmin(H93_error_function, p0,
                   xtol=0.000001, ftol=0.000001,
                   maxiter=750, maxfun=900)
      np.save('11_cal/opt_sv', np.array(opt))
      return opt


def H93_calculate_model_values(p0):
    ''' Calculates all model values given parameter vector p0. '''
    kappa_v, theta_v, sigma_v, rho, v0 = p0
      values = []
      for row, option in options.iterrows():
          model_value = H93_call_value(S0, option['Strike'], option['T'],
                              option['r'], kappa_v, theta_v, sigma_v, rho, v0)
          values.append(model_value)
      return np.array(values)
Model Calibration                                                             251


11.6.3 Comparison of Implied Volatilities

#
# Black-Scholes-Merton Implied Volatilities of
# of Calibrated BCC97 Model
# Data Source: www.eurexchange.com, 30. September 2014
# 11_cal/plot_implied_volatilities.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.extend(['03_stf', '09_gmm'])
import math
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
from BSM_imp_vol import call_option
from CIR_zcb_valuation import B
from H93_calibration import S0, r0, kappa_r, theta_r, sigma_r


#
# Calibration Results
#


def calculate_implied_volatilities(filename):
    ''' Calculates market and model implied volatilities. '''
     h5 = pd.HDFStore(filename, 'r')
     options = h5['options']
     h5.close()
     for row, option in options.iterrows():
         T = (option['Maturity'] - option['Date']).days / 365.
         B0T = B([kappa_r, theta_r, sigma_r, r0, T])
          r = -math.log(B0T) / T
          call = call_option(S0, option['Strike'], option['Date'],
                              option['Maturity'], option['r'], 0.1)
          options.ix[row, 'market_iv'] = call.imp_vol(option['Call'], 0.15)
          options.ix[row, 'model_iv'] = call.imp_vol(option['Model'], 0.15)
     return options

def plot_implied_volatilities(options, model):
     ''' Plots market implied volatilities against model implied ones. '''
     mats = sorted(set(options.Maturity))
     for mat in mats:
          opts = options[options.Maturity == mat]
252                                           DERIVATIVES ANALYTICS WITH PYTHON


        plt.figure(figsize=(8, 6))
        plt.subplot(211)
        plt.grid()
        plt.ylabel('implied volatility')
        plt.plot(opts.Strike, opts.market_iv, 'b', label='market', lw=1.5)
        plt.plot(opts.Strike, opts.model_iv, 'ro', label='model')
        plt.legend(loc=0)
        plt.axis([min(opts.Strike) - 10, max(opts.Strike) + 10,
              min(opts.market_iv) - 0.015, max(opts.market_iv) + 0.015])
        plt.title('Maturity %s' % str(mat)[:10])
        plt.subplot(212)
        plt.grid(True)
        wi = 5.0
        diffs = opts.model_iv.values - opts.market_iv.values
        plt.bar(opts.Strike - wi / 2, diffs, width=wi)
        plt.ylabel('difference')
        ymi = min(diffs) - (max(diffs) - min(diffs)) * 0.1
        yma = max(diffs) + (max(diffs) - min(diffs)) * 0.1
        plt.axis([min(opts.Strike) - 10, max(opts.Strike) + 10, ymi, yma])
        plt.tight_layout()
        plt.savefig('../images/11_cal/%s_calibration_iv_%s.pdf'
                        % (model, str(mat)[:10]))




11.6.4 Calibration of Jump-Diffusion Part of BCC97

#
# Calibration of Bakshi, Cao and Chen (1997)
# Stoch Vol Jump Model to EURO STOXX Option Quotes
# Data Source: www.eurexchange.com
# via Numerical Integration
# 11_cal/BCC97_calibration_short.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.append('09_gmm')
import math
import numpy as np
np.set_printoptions(suppress=True,
                    formatter={'all': lambda x: '%5.3f' % x})
import pandas as pd
from scipy.optimize import brute, fmin
import matplotlib.pyplot as plt
Model Calibration                                                    253


import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
from BCC_option_valuation import BCC_call_value
from CIR_calibration import CIR_calibration, r_list
from CIR_zcb_valuation import B
from H93_calibration import options


#
# Calibrate Short Rate Model
#
kappa_r, theta_r, sigma_r = CIR_calibration()


#
# Market Data from www.eurexchange.com
# as of 30. September 2014
#
S0 = 3225.93 # EURO STOXX 50 level
r0 = r_list[0] # initial short rate
#
# Option Selection
#
mats = sorted(set(options['Maturity']))
options = options[options['Maturity'] == mats[0]]
  # only shortest maturity


#
# Initial Parameter Guesses
#
kappa_v, theta_v, sigma_v, rho, v0 = np.load('11_cal/opt_sv.npy')
    # from H93 model calibration



#
# Calibration Functions
#
i = 0
min_MSE = 5000.0
local_opt = False
def BCC_error_function(p0):
     ''' Error function for parameter calibration in M76 Model via
     Carr-Madan (1999) FFT approach.


     Parameters
     ==========
     lamb: float
          jump intensity
254                                             DERIVATIVES ANALYTICS WITH PYTHON


      mu: float
          expected jump size
      delta: float
          standard deviation of jump

      Returns
      =======
      MSE: float
          mean squared error
      '''
      global i, min_MSE, local_opt, opt1
      lamb, mu, delta = p0
      if lamb < 0.0 or mu < -0.6 or mu > 0.0 or delta < 0.0:
          return 5000.0
      se = []
      for row, option in options.iterrows():
          model_value = BCC_call_value(S0, option['Strike'], option['T'],
                              option['r'], kappa_v, theta_v, sigma_v, rho, v0,
                              lamb, mu, delta)
          se.append((model_value - option['Call']) ** 2)
      MSE = sum(se) / len(se)
      min_MSE = min(min_MSE, MSE)
      if i % 25 == 0:
          print '%4d |' % i, np.array(p0), '| %7.3f | %7.3f' % (MSE, min_MSE)
      i += 1
      if local_opt:
          penalty = np.sqrt(np.sum((p0 - opt1) ** 2)) * 1
          return MSE + penalty
      return MSE


#
# Calibration
#


def BCC_calibration_short():
    ''' Calibrates jump component of BCC97 model to market quotes. '''
    # first run with brute force
      # (scan sensible regions)
      opt1 = 0.0
      opt1 = brute(BCC_error_function,
                  ((0.0, 0.51, 0.1), # lambda
                  (-0.5, -0.11, 0.1), # mu
                  (0.0, 0.51, 0.25)), # delta
                  finish=None)

      # second run with local, convex minimization
      # (dig deeper where promising)
Model Calibration                                                       255


     local_opt = True
     opt2 = fmin(BCC_error_function, opt1,
                 xtol=0.0000001, ftol=0.0000001,
                 maxiter=550, maxfun=750)
     np.save('11_cal/opt_jump', np.array(opt2))
     return opt2


def BCC_jump_calculate_model_values(p0):
     ''' Calculates all model values given parameter vector p0. '''
     lamb, mu, delta = p0
     values = []
     for row, option in options.iterrows():
         T = (option['Maturity'] - option['Date']).days / 365.
         B0T = B([kappa_r, theta_r, sigma_r, r0, T])
          r = -math.log(B0T) / T
          model_value = BCC_call_value(S0, option['Strike'], T, r,
                              kappa_v, theta_v, sigma_v, rho, v0,
                             lamb, mu, delta)
         values.append(model_value)
     return np.array(values)


#
# Graphical Results Output
#
def plot_calibration_results(p0):
     options['Model'] = BCC_jump_calculate_model_values(p0)
     plt.figure(figsize=(8, 6))
     plt.subplot(211)
     plt.grid()
     plt.title('Maturity %s' % str(options['Maturity'].iloc[0])[:10])
     plt.ylabel('option values')
     plt.plot(options.Strike, options.Call, 'b', label='market')
     plt.plot(options.Strike, options.Model, 'ro', label='model')
     plt.legend(loc=0)
     plt.axis([min(options.Strike) - 10, max(options.Strike) + 10,
           min(options.Call) - 10, max(options.Call) + 10])
     plt.subplot(212)
     plt.grid(True)
     wi = 5.0
     diffs = options.Model.values - options.Call.values
     plt.bar(options.Strike - wi / 2, diffs, width=wi)
     plt.ylabel('difference')
     plt.axis([min(options.Strike) - 10, max(options.Strike) + 10,
           min(diffs) * 1.1, max(diffs) * 1.1])
     plt.tight_layout()
256                                             DERIVATIVES ANALYTICS WITH PYTHON


11.6.5 Calibration of Complete Model of BCC97

#
# Calibration of Bakshi, Cao and Chen (1997)
# Stoch Vol Jump Model to EURO STOXX Option Quotes
# Data Source: www.eurexchange.com
# via Numerical Integration
# 11_cal/BCC97_calibration_full.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.append('09_gmm')
import math
import numpy as np
np.set_printoptions(suppress=True,
                    formatter={'all': lambda x: '%5.3f' % x})
import pandas as pd
from scipy.optimize import brute, fmin, minimize
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
from BCC_option_valuation import BCC_call_value
from CIR_calibration import CIR_calibration, r_list
from CIR_zcb_valuation import B
from H93_calibration import options

#
# Calibrate Short Rate Model
#
kappa_r, theta_r, sigma_r = CIR_calibration()

#
# Market Data from www.eurexchange.com
# as of 30. September 2014
#
S0 = 3225.93 # EURO STOXX 50 level
r0 = r_list[0] # initial short rate
#
# Parameters from H93 & jump calibrations
#
kappa_v, theta_v, sigma_v, rho, v0 = np.load('11_cal/opt_sv.npy')
lamb, mu, delta = np.load('11_cal/opt_jump.npy')
p0 = [kappa_v, theta_v, sigma_v, rho, v0, lamb, mu, delta]

#
# Calibration Functions
Model Calibration                                                          257


#
i = 0
min_MSE = 5000.0
def BCC_error_function(p0):
    ''' Error function for parameter calibration in BCC97 model via
    Lewis (2001) Fourier approach.


     Parameters
     ==========
     kappa_v: float
         mean-reversion factor
     theta_v: float
         long-run mean of variance
     sigma_v: float
         volatility of variance
     rho: float
         correlation between variance and stock/index level
     v0: float
         initial, instantaneous variance
     lamb: float
         jump intensity
     mu: float
         expected jump size
     delta: float
         standard deviation of jump


     Returns
     =======
     MSE: float
            mean squared error
     '''
     global i, min_MSE
     kappa_v, theta_v, sigma_v, rho, v0, lamb, mu, delta = p0
     if kappa_v < 0.0 or theta_v < 0.005 or sigma_v < 0.0 or \
            rho < -1.0 or rho > 1.0 or v0 < 0.0 or lamb < 0.0 or \
            mu < -.6 or mu > 0.0 or delta < 0.0:
           return 5000.0
     if 2 * kappa_v * theta_v < sigma_v ** 2:
        return 5000.0
     se = []
     for row, option in options.iterrows():
         model_value = BCC_call_value(S0, option['Strike'], option['T'],
                             option['r'], kappa_v, theta_v, sigma_v, rho, v0,
                             lamb, mu, delta)
         se.append((model_value - option['Call']) ** 2)
     MSE = sum(se) / len(se)
     min_MSE = min(min_MSE, MSE)
258                                                DERIVATIVES ANALYTICS WITH PYTHON


      if i % 25 == 0:
          print '%4d |' % i, np.array(p0), '| %7.3f | %7.3f' % (MSE, min_MSE)
      i += 1
      return MSE

def BCC_calibration_full():
      ''' Calibrates complete BCC97 model to market quotes. '''
      # local, convex minimization for all parameters
      opt = fmin(BCC_error_function, p0,
                   xtol=0.000001, ftol=0.000001,
                   maxiter=450, maxfun=650)
      np.save('11_cal/opt_full', np.array(opt))
      return opt


def BCC_calculate_model_values(p0):
    ''' Calculates all model values given parameter vector p0. '''
    kappa_v, theta_v, sigma_v, rho, v0, lamb, mu, delta = p0
      values = []
      for row, option in options.iterrows():
          model_value = BCC_call_value(S0, option['Strike'], option['T'],
                              option['r'], kappa_v, theta_v, sigma_v, rho, v0,
                              lamb, mu, delta)
          values.append(model_value)
      return np.array(values)




11.6.6 Calibration of BCC97 Model to Implied Volatilities

#
# Calibration of Bakshi, Cao and Chen (1997)
# Stoch Vol Jump Model to EURO STOXX Option Quotes
# Data Source: www.eurexchange.com
# via Numerical Integration
# 11_cal/BCC97_calibration_iv.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.append('09_gmm')
import math
import numpy as np
np.set_printoptions(suppress=True,
                    formatter={'all': lambda x: '%5.3f' % x})
import pandas as pd
from scipy.optimize import brute, fmin, minimize
Model Calibration                                                        259


import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
from BSM_imp_vol import call_option
from BCC_option_valuation import BCC_call_value
from CIR_calibration import CIR_calibration, r_list
from CIR_zcb_valuation import B
from H93_calibration import options

#
# Calibrate Short Rate Model
#
kappa_r, theta_r, sigma_r = CIR_calibration()


#
# Market Data from www.eurexchange.com
# as of 30. September 2014
#
S0 = 3225.93 # EURO STOXX 50 level 30.09.2014
r0 = r_list[0] # initial short rate


#
# Market Implied Volatilities
#
for row, option in options.iterrows():
    call = call_option(S0, option['Strike'], option['Date'],
                        option['Maturity'], option['r'], 0.15)
     options.ix[row, 'Market_IV'] = call.imp_vol(option['Call'], 0.15)

#
# Calibration Functions
#
i = 0
min_MSE = 5000.0
def BCC_iv_error_function(p0):
     ''' Error function for parameter calibration in BCC97 model via
     Lewis (2001) Fourier approach.


     Parameters
     ==========
     kappa_v: float
         mean-reversion factor
     theta_v: float
         long-run mean of variance
     sigma_v: float
         volatility of variance
     rho: float
          correlation between variance and stock/index level
260                                                   DERIVATIVES ANALYTICS WITH PYTHON


      v0: float
          initial, instantaneous variance
      lamb: float
          jump intensity
      mu: float
          expected jump size
      delta: float
          standard deviation of jump


      Returns
      =======
      MSE: float
             mean squared error
      '''
      global i, min_MSE
      kappa_v, theta_v, sigma_v, rho, v0, lamb, mu, delta = p0
      if kappa_v < 0.0 or theta_v < 0.005 or sigma_v < 0.0 or \
             rho < -1.0 or rho > 1.0 or v0 < 0.0 or lamb < 0.0 or \
             mu < -.6 or mu > 0.0 or delta < 0.0:
            return 5000.0
      if 2 * kappa_v * theta_v < sigma_v ** 2:
         return 5000.0
      se = []
      for row, option in options.iterrows():
          call = call_option(S0, option['Strike'], option['Date'],
                              option['Maturity'], option['r'],
                                 option['Market_IV'])
             model_value = BCC_call_value(S0, option['Strike'], option['T'],
                                 option['r'], kappa_v, theta_v, sigma_v, rho, v0,
                                 lamb, mu, delta)
             model_iv = call.imp_vol(model_value, 0.15)
          se.append(((model_iv - option['Market_IV']) * call.vega()) ** 2)
      MSE = sum(se) / len(se)
      min_MSE = min(min_MSE, MSE)
      if i % 25 == 0:
          print '%4d |' % i, np.array(p0), '| %7.3f | %7.3f' % (MSE, min_MSE)
      i += 1
      return MSE

def BCC_iv_calibration_full():
      ''' Calibrates complete BCC97 model to market implied volatilities. '''

      p0 = np.load('11_cal/opt_full.npy')


      # local, convex minimization
      opt = fmin(BCC_iv_error_function, p0,
                      xtol=0.000001, ftol=0.000001,
Model Calibration                                                           261


                  maxiter=450, maxfun=650)
     np.save('11_cal/opt_iv', opt)
     return opt


def BCC_calculate_model_values(p0):
    ''' Calculates all model values given parameter vector p0. '''
     kappa_v, theta_v, sigma_v, rho, v0, lamb, mu, delta = p0
     values = []
     for row, option in options.iterrows():
          model_value = BCC_call_value(S0, option['Strike'], option['T'],
                              option['r'], kappa_v, theta_v, sigma_v, rho, v0,
                              lamb, mu, delta)
         values.append(model_value)
     return np.array(values)
                                                                       CHAPTER         12
         Simulation and Valuation in the General
                             Model Framework


12.1 INTRODUCTION

Monte Carlo simulation (MCS) is an efficient and flexible method to evaluate financial models
and derivative pricing formulas numerically. The first step when valuing derivative instruments
via MCS is to discretize the stochastic differential equations (SDE) that govern the dynamics
of a given model. The correct and efficient discretization of SDEs is all but trivial and there is
a large body of literature that deals with this particular topic. Chapter 10 addresses this topic
in detail and introduces a number of correct and approximate discretization schemes for both
the index process and the square-root diffusions of the general model framework ÓàπBCC97 .
     The didactical approach of this book is to illustrate the translation of theoretical models
into executable Python scripts. Therefore, the exposition in this chapter only applies one
discretization scheme for the index and the other processes, respectively.
     Section 12.2 simulates the calibrated model ÓàπBCC97 of the previous chapter. Apart from
being calibrated, the model now includes the jump component‚Äîa topic not addressed in
Chapter 10. Section 12.3 then proceeds by valuing European and American options in this
set-up by means of MCS.


12.2 SIMULATION OF BCC97 MODEL

Given is the general market model ÓàπBCC97 of Chapter 9. To begin with, divide the time interval
[0, T] in equidistant sub-intervals of length Œît such that one has t ‚àà {0, Œît, 2Œît, ‚Ä¶ , T}, i.e.
M + 1 discrete points in time with M ‚â° T‚àïŒît. A discretization of the general market model
(9.1), (9.2) and (9.3) then looks like (with s ‚â° t ‚àí Œît)
                                 (                 ‚àö ‚àö 1      (           ) )
                     St = Ss e(ÃÑrt ‚àírJ ‚àívt ‚àï2)Œît+ vt Œîtzt + eùúáJ +ùõø zt ‚àí 1 yt
                                                                      2 4
                                                                                         (12.1)
                                                         ‚àö ‚àö
                     vÃÉ t = vÃÉ s + ùúÖv (ùúÉv ‚àí vÃÉ +
                                               s )Œît + ùúév vÃÉ+
                                                            s   Œîtz2t                    (12.2)
                     vt = vÃÉ t +
                                                         ‚àö ‚àö
                      rÃÉt = rÃÉs + ùúÖr (ùúÉr ‚àí rÃÉs+ )Œît + ùúér rÃÉs+ Œîtz3t
                      rt = rÃÉt+                                                          (12.3)


                                                                                             263
264                                                              DERIVATIVES ANALYTICS WITH PYTHON




           FIGURE 12.1 Ten simulated short rate paths from calibrated CIR85 model for a
           time horizon of 1 year (starting 30. September 2014) and 25 time intervals




            FIGURE 12.2 Ten simulated volatility paths from calibrated BCC97 model for a
            time horizon of 1 year (starting 30. September 2014) and 25 time intervals


for t ‚àà {Œît, ‚Ä¶ , T} with rÃÑt ‚â° (rt + rs )‚àï2, the znt being standard normally distributed and the yt
being Poisson distributed with intensity ùúÜ. Here, the z1t and z2t are correlated with ùúå while all
other random variables are uncorrelated.1 x+ is notation for max[x, 0].2
     Sub-section 12.5.1 contains a Python script for numerically generating discrete processes
according to equations (12.1)‚Äì(12.3). From an implementation point of view, the vt and the rt
have to be calculated first because they represent input factors for the calculation of the St .
     To make MCS more efficient, there are a number of so-called variance reduction tech-
niques available. Among them are control variates, antithetic paths and importance sampling

1
    However, the script implementing the scheme allows for arbitrary correlations.
2
    This discretization scheme is usually called Full Truncation, cf. Lord et al. (2006) and Chapter 10.
Simulation and Valuation in the General Model Framework                                   265




FIGURE 12.3 Ten simulated EURO STOXX 50 level paths from calibrated BCC97 model for a
time horizon of 1 year (starting 30. September 2014) and 25 time intervals


(cf. Glasserman (2004), ch. 4). The script in sub-section 12.5.1 implements with optionality
antithetic paths and moment matching‚Äîsimple forms of generic variance reduction tech-
niques. However, as Glasserman (2004), ch. 4 points out, the most efficient techniques in this
regard are those which exploit problem-specific features‚Äîsomething illustrated in Chapter 10
by the use of control variates.
     Figures 12.1‚Äì12.4 show simulation results from the Python script. Figure 12.3 exhibits
some large jumps which finally lead to a significant deviation of the EURO STOXX 50 level
frequency distribution from log-normality (see Figure 12.4).




     FIGURE 12.4 Histogram of simulated EURO STOXX 50 levels from calibrated BCC97
     model after a time period of 1 year (i.e. on 30. September 2015)
     266                                                       DERIVATIVES ANALYTICS WITH PYTHON


     12.3 VALUATION OF EQUITY OPTIONS

     12.3.1 European Options
     Equipped with a Python script for the simulation of the BCC97 model, valuation of European
     options is only one additional step away. As in the most simple case, we ‚Äújust‚Äù simulate
     end-of-period index levels and calculate the MCS estimator as

                                                   1‚àë
                                                      I
                                  C0MCS = B0 (T)         max[ST,i ‚àí K, 0]
                                                   I i=1

          The Python script in sub-section 12.5.2 uses the simulation functions from the simulation
     script and scales the number of time steps with the time horizon T. The script yields, for
     instance, the results as listed below (with wall times). The first parametrization‚Äî50 time steps
     p.a. and 50,000 paths‚Äîleads to a systematic valuation bias with MCS estimators much too
     high in general.

 1    In [1]: %time compare_values(M0=50, I=50000)
 2          T |      K |      C0 |     MCS |    DIFF
 3         0.083 |    3050 | 193.692 | 195.584 |          1.892
 4         0.083 |    3225 | 62.147 | 64.162 |            2.016
 5         0.083 |    3400 |   1.967 |   2.544 |          0.577
 6         0.500 |    3050 | 259.126 | 272.960 |          13.834
 7         0.500 |    3225 | 146.891 | 164.333 |          17.443
 8         0.500 |    3400 | 67.142 | 85.330 |            18.188
 9         1.000 |    3050 | 321.419 | 344.280 |          22.861
10         1.000 |    3225 | 216.227 | 243.415 |          27.188
11         1.000 |    3400 | 133.950 | 162.403 |          28.453
12         1.500 |    3050 | 378.978 | 407.035 |          28.057
13         1.500 |    3225 | 276.942 | 309.251 |          32.309
14         1.500 |    3400 | 193.333 | 227.887 |          34.554
15         2.000 |    3050 | 435.337 | 470.659 |          35.322
16         2.000 |    3225 | 335.010 | 374.315 |          39.305
17         2.000 |    3400 | 250.314 | 291.888 |          41.574
18         3.000 |    3050 | 549.127 | 594.413 |          45.287
19         3.000 |    3225 | 450.522 | 499.873 |          49.350
20      3.000 |   3400 | 364.049 | 416.300 | 52.252
21    CPU times: user 5.77 s, sys: 164 ms, total: 5.93 s
22    Wall time: 5.93 s


           Increasing the number of paths does not really help with valuation accuracy in this case.

 1    In [2]: %time compare_values(M0=50, I=200000)
 2             T |       K |      C0 |     MCS |           DIFF
 3         0.083 |    3050 | 193.692 | 195.870 |          2.178
 4         0.083 |    3225 | 62.147 | 64.609 |            2.462
     Simulation and Valuation in the General Model Framework                            267


 5       0.083 |      3400 |   1.967 |   2.606 |           0.639
 6       0.500 |      3050 | 259.126 | 273.046 |          13.920
 7       0.500 |      3225 | 146.891 | 164.698 |          17.807
 8       0.500 |      3400 | 67.142 | 85.852 |            18.710
 9       1.000 |      3050 | 321.419 | 342.696 |          21.277
10       1.000 |      3225 | 216.227 | 241.375 |          25.148
11       1.000 |      3400 | 133.950 | 160.706 |          26.756
12       1.500 |      3050 | 378.978 | 407.341 |          28.363
13       1.500 |      3225 | 276.942 | 309.124 |          32.182
14       1.500 |      3400 | 193.333 | 227.473 |          34.140
15       2.000 |      3050 | 435.337 | 470.323 |          34.986
16       2.000 |      3225 | 335.010 | 373.940 |          38.930
17       2.000 |      3400 | 250.314 | 291.583 |          41.268
18       3.000 |      3050 | 549.127 | 597.571 |          48.444
19      3.000 |   3225 | 450.522 | 503.362 | 52.840
20      3.000 |   3400 | 364.049 | 420.019 | 55.970
21    CPU times: user 23.2 s, sys: 848 ms, total: 24.1 s
22    Wall time: 24.1 s



         However, increasing the number of time steps used for the discretization has a huge
     impact.


 1    In [3]: %time compare_values(M0=200, I=50000)
 2          T |      K |      C0 |     MCS |    DIFF
 3       0.083 |      3050 | 193.692 | 193.241 |          -0.450
 4       0.083 |      3225 | 62.147 | 61.595 |            -0.552
 5       0.083 |      3400 |   1.967 |   2.581 |           0.614
 6       0.500 |      3050 | 259.126 | 259.140 |           0.014
 7       0.500 |      3225 | 146.891 | 149.090 |           2.199
 8       0.500 |      3400 | 67.142 | 71.122 |             3.980
 9       1.000 |      3050 | 321.419 | 322.117 |           0.697
10       1.000 |      3225 | 216.227 | 219.528 |           3.301
11       1.000 |      3400 | 133.950 | 139.285 |           5.335
12       1.500 |      3050 | 378.978 | 377.499 |          -1.479
13       1.500 |      3225 | 276.942 | 278.276 |           1.334
14       1.500 |      3400 | 193.333 | 197.137 |           3.804
15       2.000 |      3050 | 435.337 | 435.067 |          -0.270
16       2.000 |      3225 | 335.010 | 337.597 |           2.587
17       2.000 |      3400 | 250.314 | 255.541 |           5.227
18       3.000 |      3050 | 549.127 | 552.842 |           3.715
19       3.000 |      3225 | 450.522 | 457.774 |           7.252
20      3.000 |   3400 | 364.049 | 374.340 | 10.291
21    CPU times: user 21.8 s, sys: 914 ms, total: 22.7 s
22    Wall time: 22.7 s
23
     268                                                      DERIVATIVES ANALYTICS WITH PYTHON


         Too few time steps obviously lead to a systematic valuation bias. Increasing the number of
     paths does not really help‚Äîhowever, increasing the number of time steps leads to significant
     accuracy improvements with valuation errors being much smaller and both positive as well as
     negative. This makes clear that using Euler discretization schemes makes a large number of
     time steps necessary to achieve sufficient accuracy with such complex models.


     12.3.2 American Options
     Now we can add the LSM algorithm to the script‚Äîsee sub-section 12.5.3‚Äîto value put options
     with American, i.e. early, exercise feature. The script generates, for instance, the following
     results, illustrating the early exercise premium for American put options vs. their European
     counterparts (for longer maturities):


 1    In [4]: %time lsm_compare_values(M0=150, I=50000)
 2          T |      K |      P0 |     LSM |    DIFF
 3         0.083 |    3050 |    17.681 |    17.431 |    -0.250
 4         0.083 |    3225 |    61.131 |    61.001 |    -0.130
 5         0.083 |    3400 | 175.947 | 181.565 |         5.619
 6         0.500 |    3050 | 77.963 | 84.277 |           6.314
 7         0.500 |    3225 | 140.428 | 149.270 |         8.842
 8         0.500 |    3400 | 235.379 | 246.148 |        10.769
 9         1.000 |    3050 | 124.220 | 136.155 |        11.934
10         1.000 |    3225 | 192.808 | 207.958 |        15.149
11         1.000 |    3400 | 284.311 | 302.051 |        17.740
12         1.500 |    3050 | 155.970 | 174.835 |        18.865
13         1.500 |    3225 | 226.234 | 250.278 |        24.044
14         1.500 |    3400 | 314.923 | 344.215 |        29.292
15         2.000 |    3050 | 177.841 | 206.460 |        28.619
16         2.000 |    3225 | 247.834 | 282.910 |        35.077
17         2.000 |    3400 | 333.458 | 376.640 |        43.182
18         3.000 |    3050 | 201.032 | 249.858 |        48.826
19         3.000 |    3225 | 267.549 | 328.487 |        60.937
20      3.000 |   3400 | 346.197 | 421.464 | 75.267
21    CPU times: user 37.1 s, sys: 935 ms, total: 38 s
22    Wall time: 38 s
23




           Obviously, the early exercise premium rises with an increase in time-to-maturity.



     12.4 CONCLUSIONS

     This chapter illustrates how to numerically evaluate the general market model‚Äîbased on
     the calibrated model parameters‚Äîby the means of Monte Carlo simulation. It also values
Simulation and Valuation in the General Model Framework                                    269


European as well as American call options by simulation. In a sense, it merely glues together
the single pieces worked out in previous chapters to finally arrive at a market-based valuation
of European and American index options.



12.5 PYTHON SCRIPTS

12.5.1 Simulating the BCC97 Model

#
# Monte Carlo Simulation of BCC97 Model
# 12_val/BCC97_simulation.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.append('11_cal')
import math
import numpy as np
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
import matplotlib.pyplot as plt
from H93_calibration import S0, kappa_r, theta_r, sigma_r, r0


#
# Model Parameters
#
opt = np.load('11_cal/opt_full.npy')
kappa_v, theta_v, sigma_v, rho, v0, lamb, mu, delta = opt



#
# Simulation Parameters
#
T = 1.0 # time horizon
M = 25 # time steps
I = 10000 # number of replications per valuation
anti_paths = True # antithetic paths for variance reduction
moment_matching = True        # moment matching for variance reduction
np.random.seed(100000)        # seed value for random number generator



#
# Random Number Generation
#
270                                             DERIVATIVES ANALYTICS WITH PYTHON


def generate_cholesky(rho):
    ''' Function to generate Cholesky matrix.


      Parameters
      ==========
      rho: float
          correlation between index level and variance


      Returns
      =======
      matrix: NumPy array
          Cholesky matrix
      '''
      rho_rs = 0 # correlation between index level and short rate
      covariance = np.zeros((4, 4), dtype=np.float)
      covariance[0] = [1.0, rho_rs, 0.0, 0.0]
      covariance[1] = [rho_rs, 1.0, rho, 0.0]
      covariance[2] = [0.0, rho, 1.0, 0.0]
      covariance[3] = [0.0, 0.0, 0.0, 1.0]
      cho_matrix = np.linalg.cholesky(covariance)
      return cho_matrix


def random_number_generator(M, I, anti_paths, moment_matching):
    ''' Function to generate pseudo-random numbers.


      Parameters
      ==========
      M: int
          time steps
      I: int
          number of simulation paths
      anti_paths: bool
          flag for antithetic paths
      moment_matching: bool
          flag for moment matching


      Returns
      =======
      rand: NumPy array
          random number array
      '''
      if anti_paths:
          rand = np.random.standard_normal((4, M + 1, I / 2))
          rand = np.concatenate((rand, -rand), 2)
      else:
          rand = np.random.standard_normal((4, M + 1, I))
Simulation and Valuation in the General Model Framework                 271


     if moment_matching:
         for a in range(4):
               rand[a] = rand[a] / np.std(rand[a])
               rand[a] = rand[a] - np.mean(rand[a])
     return rand

#
# Function for Short Rate and Volatility Processes
#


def SRD_generate_paths(x0, kappa, theta, sigma, T, M, I,
                       rand, row, cho_matrix):
    ''' Function to simulate Square-Root Difussion (SRD/CIR) process.


     Parameters
     ==========
     x0: float
         initial value
     kappa: float
         mean-reversion factor
     theta: float
         long-run mean
     sigma: float
         volatility factor
     T: float
         final date/time horizon
     M: int
         number of time steps
     I: int
         number of paths
     row: int
         row number for random numbers
     cho_matrix: NumPy array
          Cholesky matrix

     Returns
     =======
     x: NumPy array
         simulated variance paths
     '''
     dt = T / M
     x = np.zeros((M + 1, I), dtype=np.float)
     x[0] = x0
     xh = np.zeros_like(x)
     xh[0] = x0
     sdt = math.sqrt(dt)
     for t in range(1, M + 1):
272                                               DERIVATIVES ANALYTICS WITH PYTHON


          ran = np.dot(cho_matrix, rand[:, t])
          xh[t] = (xh[t - 1] + kappa * (theta -
               np.maximum(0, xh[t - 1])) * dt +
               np.sqrt(np.maximum(0, xh[t - 1])) * sigma * ran[row] * sdt)
          x[t] = np.maximum(0, xh[t])
      return x

#
# Function for B96 Index Process
#

def B96_generate_paths(S0, r, v, lamb, mu, delta, rand, row1, row2,
                         cho_matrix, T, M, I, moment_matching):
      ''' Simulation of Bates (1996) index process.

      Parameters
      ==========
      S0: float
          initial value
      r: NumPy array
          simulated short rate paths
      v: NumPy array
          simulated variance paths
      lamb: float
          jump intensity
      mu: float
          expected jump size
      delta: float
          standard deviation of jump
      rand: NumPy array
          random number array
      row1, row2: int
          rows/matrices of random number array to use
      cho_matrix: NumPy array
          Cholesky matrix
      T: float
          time horizon, maturity
      M: int
          number of time intervals, steps
      I: int
          number of paths to simulate
      moment_matching: bool
          flag for moment matching

      Returns
      =======
      S: NumPy array
          simulated index level paths
Simulation and Valuation in the General Model Framework                           273


     '''
     S = np.zeros((M + 1, I), dtype=np.float)
     S[0] = S0
     dt = T / M
     sdt = math.sqrt(dt)
     ranp = np.random.poisson(lamb * dt, (M + 1, I))
     rj = lamb * (math.exp(mu + 0.5 * delta ** 2) - 1)
     bias = 0.0
     for t in xrange(1, M + 1, 1):
          ran = np.dot(cho_matrix, rand[:, t, :])
          if moment_matching:
              bias = np.mean(np.sqrt(v[t]) * ran[row1] * sdt)
          S[t] = S[t - 1] * (np.exp(((r[t] + r[t -1]) / 2 - 0.5 * v[t]) * dt +
                          np.sqrt(v[t]) * ran[row1] * sdt - bias)
                              + (np.exp(mu + delta * ran[row2]) - 1) * ranp[t])
     return S



if __name__ == '__main__':
    #
     # Simulation
     #
     cho_matrix = generate_cholesky(rho)
     rand = random_number_generator(M, I, anti_paths, moment_matching)
     r = SRD_generate_paths(r0, kappa_r, theta_r, sigma_r, T, M, I,
                             rand, 0, cho_matrix)
     v = SRD_generate_paths(v0, kappa_v, theta_v, sigma_v, T, M, I,
                             rand, 2, cho_matrix)
     S = B96_generate_paths(S0, r, v, lamb, mu, delta, rand, 1, 3,
                                   cho_matrix, T, M, I, moment_matching)



def plot_rate_paths(r):
    plt.figure(figsize=(8, 4))
     plt.plot(r[:, :10])
     plt.xlabel('time step')
     plt.ylabel('short rate level')
     plt.title('Short Rate Simulated Paths')
     plt.grid()


def plot_volatility_paths(v):
    plt.figure(figsize=(8, 4))
    plt.plot(np.sqrt(v[:, :10]))
     plt.xlabel('time step')
     plt.ylabel('volatility level')
     plt.title('Volatility Simulated Paths')
     plt.grid()
274                                                DERIVATIVES ANALYTICS WITH PYTHON


def plot_index_paths(S):
    plt.figure(figsize=(8, 4))
    plt.plot(S[:, :10])
      plt.xlabel('time step')
      plt.ylabel('index level')
      plt.title('EURO STOXX 50 Simulated Paths')
      plt.grid()

def plot_index_histogram(S):
      plt.figure(figsize=(8, 4))
      plt.hist(S[-1], bins=30)
      plt.xlabel('index level')
      plt.ylabel('frequency')
      plt.title('EURO STOXX 50 Values after 1 Year')
      plt.grid()




12.5.2 Valuation of European Call Options by MCS

#
# Valuation of European Options in BCC97 Model
# by Monte Carlo Simulation
# 12_val/BCC97_valuation_comparison.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.extend(['09_gmm', '10_mcs'])
import math
from BCC_option_valuation import *
from CIR_zcb_valuation_gen import B
from BCC97_simulation import *


#
# Parameters
#
t_list = [1 / 12., 0.5, 1.0, 1.5, 2.0, 3.0]
k_list = [3050, 3225, 3400]


#
# Valuation for Different Strikes & Maturities
#
def compare_values(M0=50, I=50000):
    results = []
      for T in t_list:
Simulation and Valuation in the General Model Framework                       275


          #
          # Simulation
          #
          M = int(M0 * T)
          cho_matrix = generate_cholesky(rho)
          rand = random_number_generator(M, I, anti_paths, moment_matching)
          r = SRD_generate_paths(r0, kappa_r, theta_r, sigma_r, T, M, I,
                                  rand, 0, cho_matrix)
          v = SRD_generate_paths(v0, kappa_v, theta_v, sigma_v, T, M, I,
                                  rand, 2, cho_matrix)
          S = B96_generate_paths(S0, r, v, lamb, mu, delta, rand, 1, 3,
                                      cho_matrix, T, M, I, moment_matching)
          for K in k_list:
               #
               # Valuation
               #
               h = np.maximum(S[-1] - K, 0)
               B0T = B([r0, kappa_r, theta_r, sigma_r, 0.0, T])
               V0_mcs = B0T * np.sum(h) / I # MCS estimator
               #
               # European Call Option via Fourier
               #
               ra = -math.log(B0T) / T # average short rate/yield
               C0 = BCC_call_value(S0, K, T, ra, kappa_v, theta_v, sigma_v,
                                         rho, v0, lamb, mu, delta)

               results.append((T, K, C0, V0_mcs, V0_mcs - C0))

     print " %6s | %6s | %7s | %7s | %7s" % ('T', 'K', 'C0', 'MCS', 'DIFF')
     for res in results:
         print " %6.3f | %6d | %7.3f | %7.3f | %7.3f" % res



12.5.3 Valuation of American Call Options by MCS

#
# Valuation of American Options in BCC97 Model
# by Least-Squares Monte Carlo Algorithm
# 12_val/BCC97_american_valuation.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.extend(['09_gmm', '10_mcs'])
import math
from BCC_option_valuation import *
276                                             DERIVATIVES ANALYTICS WITH PYTHON


from CIR_zcb_valuation_gen import B
from BCC97_simulation import *
#
# Additional Parameters
#
D = 10 # number of basis functions
t_list = [1 / 12., 0.5, 1.0, 1.5, 2.0, 3.0]
k_list = [3050, 3225, 3400]


#
# LSM Valuation Function
#
def BCC97_lsm_valuation(S, r, v, K, T, M, I):
    ''' Function to value American put options by LSM algorithm.


      Parameters
      ==========
      S: NumPy array
          simulated index level paths
      r: NumPy array
          simulated short rate paths
      v: NumPy array
          simulated variance paths
      K: float
          strike of the put option
      T: float
          final date/time horizon
      M: int
          number of time steps
      I: int
          number of paths


      Returns
      =======
      LSM_value: float
          LSM Monte Carlo estimator of American put option value
      '''
      dt = T / M
      # inner value matrix
      h = np.maximum(K - S, 0)
      # value/cash flow matrix
      V = np.maximum(K - S, 0)
      for t in xrange(M - 1, 0, -1):
          df = np.exp(-(r[t] + r[t + 1]) / 2 * dt)
          # select only ITM paths
          itm = np.greater(h[t], 0)
          relevant = np.nonzero(itm)
Simulation and Valuation in the General Model Framework                           277


          rel_S = np.compress(itm, S[t])
          no_itm = len(rel_S)
          if no_itm == 0:
              cv = np.zeros((I), dtype=np.float)
          else:
              rel_v = np.compress(itm, v[t])
               rel_r = np.compress(itm, r[t])
               rel_V = (np.compress(itm, V[t + 1])
                          * np.compress(itm, df))
               matrix = np.zeros((D + 1, no_itm), dtype=np.float)
               matrix[10] = rel_S * rel_v * rel_r
               matrix[9] = rel_S * rel_v
               matrix[8] = rel_S * rel_r
               matrix[7] = rel_v * rel_r
               matrix[6] = rel_S ** 2
               matrix[5] = rel_v ** 2
               matrix[4] = rel_r ** 2
               matrix[3] = rel_S
               matrix[2] = rel_v
               matrix[1] = rel_r
               matrix[0] = 1
               reg = np.linalg.lstsq(matrix.transpose(), rel_V)
               cv = np.dot(reg[0], matrix)
          erg = np.zeros((I), dtype=np.float)
          np.put(erg, relevant, cv)
          V[t] = np.where(h[t] > erg, h[t], V[t + 1] * df)
             # exercise decision
     df = np.exp(-((r[0] + r[1]) / 2) * dt)
     LSM_value = max(np.sum(V[1, :] * df) / I, h[0, 0])         # LSM estimator
     return LSM_value


#
# Valuation for Different Strikes & Maturities
#
def lsm_compare_values(M0=50, I=50000):
    results = []
    for T in t_list:
          #
          # Simulation
          #
          M = int(M0 * T)
          cho_matrix = generate_cholesky(rho)
          rand = random_number_generator(M, I, anti_paths, moment_matching)
          r = SRD_generate_paths(r0, kappa_r, theta_r, sigma_r, T, M, I,
                                  rand, 0, cho_matrix)
          v = SRD_generate_paths(v0, kappa_v, theta_v, sigma_v, T, M, I,
                                         rand, 2, cho_matrix)
278                                                DERIVATIVES ANALYTICS WITH PYTHON


          S = B96_generate_paths(S0, r, v, lamb, mu, delta, rand, 1, 3,
                                      cho_matrix, T, M, I, moment_matching)
          for K in k_list:
              #
              # Valuation
              #
              h = np.maximum(S[-1] - K, 0)
              B0T = B([r0, kappa_r, theta_r, sigma_r, 0.0, T])
              V0_lsm = BCC97_lsm_valuation(S, r, v, K, T, M, I)
                  # LSM estimator
              #
              # European Call Option via Fourier
              #
              ra = -math.log(B0T) / T   # average short rate/yield
              C0 = BCC_call_value(S0, K, T, ra, kappa_v, theta_v, sigma_v,
                                  rho, v0, lamb, mu, delta)
              P0 = C0 + K * B0T - S0


              results.append((T, K, P0, V0_lsm, V0_lsm - P0))


      print " %6s | %6s | %7s | %7s | %7s" % ('T', 'K', 'P0', 'LSM', 'DIFF')
      for res in results:
          print " %6.3f | %6d | %7.3f | %7.3f | %7.3f" % res
                                                                        CHAPTER         13
                                                               Dynamic Hedging


13.1 INTRODUCTION

In a friction-less market, dynamic delta hedging is a perfect method to hedge against price
changes of a derivative instrument when the underlying of the option is the only source of
risk, its price paths are continuous and volatility is constant. This is, for example, the case
in the benchmark model of Black-Scholes-Merton (BSM, cf. Wilmott et al. (1995), ch. 3). In
fact, it is one approach‚Äîanother one being an equilibrium argument‚Äîto come up with the
famous analytical formula of BSM. Independent of the particular model at hand, the delta of,
for example, a put option P is defined by the first derivative of the option‚Äôs value with respect
to the value of the underlying S

                                                    ùúïPt
                                            ŒîPt ‚â°
                                                    ùúïSt

Delta hedging the put P then says that adding ‚àíŒîPt units of the underlying at time t to the
put option completely neutralizes the price changes in the put option due to changes in the
underlying. One then has for all t that

                                        dPt ‚àí ŒîPt dSt = 0

     Investment banks are also often interested in replicating the payoff of such a put (or
another option). This is accomplished by setting up a replication portfolio consisting of ŒîPt
units of the underlying and ùõæt ‚â° Pt ‚àí ŒîPt St units of the risk-less bond Bt such that the resulting
portfolio value equals the option value at any time t

                                        Pt = ŒîPt St + ùõæt Bt

or

                                      dPt = ŒîPt dSt + ùõæt dBt

For a plain vanilla put option this generally implies being short the underlying (ŒîPt < 0) and
long the bond. For a call option (ŒîCt > 0) this implies the opposite.



                                                                                              279
280                                                                 DERIVATIVES ANALYTICS WITH PYTHON


    A replication strategy (ŒîPt , ùõæt ), t ‚àà {0, ..., ùúè ‚àí Œît}, is called self-financing if for t > 0 and
ùúè being the exercise date (i.e. ùúè = T for a European option)

                                 ŒîPt St + ùõæt Bt = ŒîPt‚àíŒît St + ùõæt‚àíŒît Bt

     By the means of two simulation studies, this chapter implements the idea of dynamic
delta hedging in the BSM model (section 13.2) and the general market model of BCC97
(section 13.3), respectively. While the strategy works quite well in the BSM framework,
jumps allow us to break down the strategy frequently in the BCC97 model.


13.2 HEDGING STUDY FOR BSM MODEL

This section illustrates dynamic replication of an American put option in the BSM model.
The example is taken from the seminal paper on the LSM by Longstaff and Schwartz (2001).
We use an approximative method based on the LSM algorithm to numerically derive option
deltas. The approach comprises two parts, an initial one and one that is replicated as often as
necessary.1 These are:

     initial delta: the initial delta ŒîP0 is estimated via a difference quotient of the form

                                          PLSM
                                           0
                                               (S0 + 0.01) ‚àí PLSM
                                                              0
                                                                  (S0 )
                                  ŒîP0 ‚â°                                                          (13.1)
                                                           0.01

    where the two option values are derived from two separate LSM valuations of the put,
    changing the starting value of the underlying as indicated
   subsequent deltas: all other deltas ŒîP , t ‚àà {Œît, ..., ùúè ‚àí Œît}, with ùúè being the exercise
                                            t
    time, are estimated via the regression function available at each time step using the same
    difference quotient as before

                                              VÃÇ t (SÃÇ t + 0.01) ‚àí VÃÇ t (SÃÇ t )
                                      ŒîPt ‚â°                                                      (13.2)
                                                            0.01

      here, VÃÇ t is the LSM regression estimate of the American put option value at date t given
      the simulated index level SÃÇ t

     The Python script in sub-section 13.5.1 implements this simple, approximative algorithm
for the American put option in the BSM setting.2 In the script, the replicating portfolio is

1
  Cf. Wallner and Wystup (2004) for the numerical estimation of price sensitivities for options with
American exercise. The method introduced here is a so-called first order approximation.
2
  The approach presented here is similar in spirit to that of Wang and Calfisch (2010) but is even ‚Äúmore
simple and approximative‚Äù.
Dynamic Hedging                                                                                  281




    FIGURE 13.1   Dynamic replication of American put option in BSM model with profit at exercise



considered to be self-financing which implies that there are neither cash inflows nor out-
flows after t = 0. The respective values of the portfolio are benchmarked against an out-of-
sample valuation3 of the American put option given time t and the then current level of the
underlying St .
     Figure 13.1 illustrates a replicating strategy for a randomly chosen path from the original
valuation. In this particular run, the replicating strategy has over-replicated the option‚Äôs payoff
leading to a positive difference, i.e. a profit, at the exercise date.
     Figure 13.2 shows another path where the replicating strategy underperforms, leading
to a significant loss at the exercise date. Two aspects are noteworthy. First, the regression
coefficients are estimated only once at the beginning and used for every time step up to
exercise or maturity. Second, the performance of the second delta hedging program is quite
good on average in the short run but becomes worse the longer the option remains alive.
With a constant reassessment of the regression coefficients the performance of the hedge
program could be improved. In practical applications, this is what one would do at least on a
daily basis.


3
 This is to make sure that there is not an in-sample bias of the replicating strategy which would make
the calculated profit and loss (P&L) too optimistic.
       The single position adjustments for a particular dynamic hedge might look as follows:

 1   DYNAMIC HEDGING OF PUT
 2   -----------------------------
 3   Initial Hedge
 4   Stocks               -0.587
 5   Bonds                   25.585
 6   Cost                     4.469
 7
 8   Regular Rehedges
 9   --------------------------------------------------------------------------
10   step|     S_t|    Port|     Put|    Diff|   Stock|    Bond|    Cost|
11      1|   37.509|    3.615|    3.535|     0.079|    -0.450|   20.483|     3.615|
12      2|   38.126|    3.362|    3.186|     0.176|    -0.477|   21.566|     3.362|
13      3|   38.338|    3.287|    3.074|     0.212|    -0.481|   21.730|     3.287|
14      4|   37.493|    3.719|    3.551|     0.168|    -0.554|   24.483|     3.719|
15      5|   36.652|    4.214|    4.048|     0.166|    -0.657|   28.278|     4.214|
16      6|   36.894|    4.089|    3.897|     0.192|    -0.616|   26.802|     4.089|
17      7|   37.780|    3.576|    3.390|     0.186|    -0.557|   24.603|     3.576|
18      8|   39.197|    2.817|    2.664|     0.153|    -0.474|   21.401|     2.817|
19      9|   39.449|    2.723|    2.545|     0.178|    -0.461|   20.912|     2.723|
20     10|   39.621|    2.669|    2.471|     0.198|    -0.433|   19.829|     2.669|
21     11|   38.791|    3.052|    2.853|     0.199|    -0.501|   22.493|     3.052|
22     12|   39.174|    2.887|    2.673|     0.214|    -0.473|   21.409|     2.887|
23     13|   39.432|    2.791|    2.563|     0.227|    -0.434|   19.910|     2.791|
24     14|   37.930|    3.467|    3.298|     0.169|    -0.567|   24.979|     3.467|
25     15|   37.582|    3.694|    3.481|     0.213|    -0.598|   26.153|     3.694|
26     16|   38.677|    3.071|    2.915|     0.157|    -0.516|   23.024|     3.071|
27     17|   37.774|    3.565|    3.373|     0.191|    -0.595|   26.033|     3.565|
28     18|   39.876|    2.346|    2.373|    -0.027|    -0.426|   19.323|     2.346|
29     19|   40.624|    2.050|    2.078|    -0.028|    -0.370|   17.072|     2.050|
30     20|   40.949|    1.951|    1.959|    -0.008|    -0.349|   16.245|     1.951|
31     21|   40.166|    2.243|    2.248|    -0.004|    -0.408|   18.646|     2.243|
32     22|   39.944|    2.356|    2.341|     0.015|    -0.410|   18.724|     2.356|
33     23|   39.836|    2.423|    2.383|     0.040|    -0.418|   19.066|     2.423|
34     24|   40.601|    2.127|    2.079|     0.048|    -0.360|   16.738|     2.127|
35     25|   39.229|    2.640|    2.653|    -0.013|    -0.502|   22.331|     2.640|
36     26|   39.436|    2.564|    2.564|    -0.000|    -0.494|   22.050|     2.564|
37     27|   38.928|    2.841|    2.797|     0.044|    -0.538|   23.785|     2.841|
38     28|   38.055|    3.339|    3.218|     0.121|    -0.626|   27.144|     3.339|
39     29|   38.333|    3.198|    3.075|     0.123|    -0.604|   26.369|     3.198|
40     30|   38.445|    3.162|    3.010|     0.152|    -0.598|   26.157|     3.162|
41     31|   39.784|    2.392|    2.406|    -0.014|    -0.466|   20.944|     2.392|
42     32|   40.044|    2.296|    2.299|    -0.002|    -0.447|   20.205|     2.296|
43     33|   39.356|    2.628|    2.588|     0.040|    -0.516|   22.935|     2.628|
44     34|   38.360|    3.170|    3.047|     0.123|    -0.626|   27.200|     3.170|
45     35|   36.726|    4.226|    3.969|     0.257|    -0.781|   32.916|     4.226|
46     36|   37.156|    3.930|    3.705|     0.225|    -0.745|   31.611|     3.930|
47     37|   36.722|    4.291|    3.976|     0.314|    -0.794|   33.447|     4.291|
48   MSE                 0.023
49   Average Error       0.118
50   Total P&L           4.485
     Dynamic Hedging                                                                                   283




      FIGURE 13.2      Dynamic replication of American put option in BSM model with loss at exercise



          Finally, Figure 13.3 shows the frequency distribution of the discounted P&L at exercise
     of 10,000 dynamic replications for this case (see the Python script in sub-section 13.5.2).
     This simulation is based on 50 time steps for the discretization and 10,000 paths. Summary
     statistics are:



 1    SUMMARY STATISTICS FOR P&L
 2    ---------------------------------
 3    Dynamic Replications        10000
 4    Time Steps                     50
 5    Paths for Valuation                  10000
 6    Maximum                              5.447
 7    Average                              0.041
 8    Median                      0.036
 9    Minimum                   -11.475
10    ---------------------------------
11    CPU times: user 19 s, sys: 4 ms, total: 19 s
12    Wall time: 19 s
     284                                                        DERIVATIVES ANALYTICS WITH PYTHON




           FIGURE 13.3 Frequency distribution of (discounted) P&L at exercise date of 10,000
           dynamic replications of American put option in BSM model



         The average hedge error is 0.4 cents only which is not too bad given the simplicity of the
     approach. The highest loss is ‚àí11.37 and the highest profit +5.446 (as very exceptions).
         The hedge errors (i.e. the P&L) can be controlled for by increasing both the number of
     time steps and paths. This is illustrated in Figure 13.4 and by the following summary statistics
     based on 200 time steps and 150,000 paths.




 1    SUMMARY STATISTICS FOR P&L
 2    ---------------------------------
 3    Dynamic Replications        10000
 4    Time Steps                            200
 5    Paths for Valuation                150000
 6    Maximum                             2.118
 7    Average                             0.003
 8    Median                              0.016
 9    Minimum                            -1.328
10    ---------------------------------
11    CPU times: user 45.3 s, sys: 208 ms, total: 45.6 s
12    Wall time: 45.5 s
Dynamic Hedging                                                                                       285




          FIGURE 13.4 Frequency distribution of (discounted) P&L at exercise date of 10,000
          dynamic replications of American put option in BSM model with more time steps and
          paths used


    In this case, the average hedge error is 0.1 cents only while the maximum profit is 1.35
and the maximum loss is reduced to ‚àí3.66.


13.3 HEDGING STUDY FOR BCC97 MODEL

The previous section introduces a simple, approximative algorithm to delta hedge an American
option‚Äîthe major advantage of it being the low computational burden which results from
recycling the regression coefficients from an initial LSM simulation run. This section now
applies this algorithm with a second order approximation formula to dynamically replicate an
American index put option in the calibrated BCC97 setting.
     For 0 ‚â§ a ‚â§ 2 and ŒîSt > 0, the deltas are approximated along an index level path through
the following difference quotients:4

        initial delta: the initial delta ŒîP0 is estimated via a difference quotient of the form
                                         (                  )       (             )
                                    PLSM
                                     0
                                          S0 + (2 ‚àí a) ‚ãÖ ŒîS0 ‚àí PLSM
                                                                0
                                                                     S0 ‚àí a ‚ãÖ ŒîS0
                            ŒîP0 ‚â°                                                                   (13.3)
                                                         2 ‚ãÖ ŒîS0

4
    Refer to Wallner and Wystup (2004) for this kind of second order approximation to option sensitivities.
     286                                                                DERIVATIVES ANALYTICS WITH PYTHON


           where the two option values are derived from two separate LSM valuations of the put,
           changing the starting value of the underlying as indicated
          subsequent deltas: all other deltas ŒîP , t ‚àà {Œît, ..., ùúè ‚àí Œît}, with ùúè being the exercise
                                                   t
           time, are estimated via the regression function available at each time step using a similar
           difference quotient as before

                                      (                           )+       (                     )+
                                                            |                              |
                                  VÃÇ t SÃÇ t + (2 ‚àí a) ‚ãÖ ŒîSt |XÃÇ t    ‚àí VÃÇ t SÃÇ t ‚àí a ‚ãÖ ŒîSt |XÃÇ t
                                                            |                              |
                            ŒîPt ‚â°                                                                         (13.4)
                                                               2 ‚ãÖ ŒîSt

           here, VÃÇ t is the LSM regression estimate of the American put option value5 using all
           (simulated) state variables XÃÇt = (SÃÇt , vÃÇt , rÃÇt ), i.e. the index level, the variance level and the
           short rate at date t

         By varying a and ŒîSt one can fine-tune the approximations. In particular, it is important to
     adjust ŒîSt such that it reflects the initial index level S0 and the later index levels St . Therefore,
     we set for 0 ‚â§ t < T

                                                    ŒîSt = 0.01 ‚ãÖ SÃÇ t

          Figure 13.5 shows a delta hedging procedure along a specific simulated EURO STOXX
     50 index level path (sub-section 13.5.3 provides the Python script for the valuation of the
     American put and the dynamic delta hedging, respectively). Here, the hedge strategy super-
     replicates the option, i.e. it produces a profit at maturity. In comparison, Figure 13.6 illustrates
     that losses can also accumulate in significant amounts, with the portfolio value even ending in
     the negatives. Finally, Figure 13.7 (cf. sub-section 13.5.4 for the script) shows the discounted
     P&L of 10,000 dynamic replications. Summary statistics are:


 1       SUMMARY STATISTICS FOR P&L
 2       ---------------------------------
 3       Dynamic Replications        10000
 4       Time Steps                    150
 5       Paths for Valuation                 150000
 6       Maximum                            143.354
 7       Average                             4.343
 8       Median                             15.136
 9       Minimum                         -1014.275
10       ---------------------------------
11       CPU times: user 42.6 s, sys: 887 ms, total: 43.4 s
12       Wall time: 43.4 s



     5
      Note that simple evaluation of the regression function could generate negative values for the option
     price such that the formula truncates the estimates below zero.
Dynamic Hedging                                                                                   287




    FIGURE 13.5   Dynamic replication of American put option in BCC97 with profit at maturity



     On average, the dynamic hedging strategy for the American put option yields a discounted
profit of 4.34 so that its application to a large options book might be justified. In that sense,
this analysis illustrates Merton‚Äôs (1976) original assumption that jump risk can (almost) be
diversified away‚Äîinstead of being completely hedged away which is impossible here.
     It is worthwhile emphasizing that in general a pure delta hedging strategy in such a
context cannot perform as well as for a European option in a more simple model. A major
reason for this is that delta hedging cannot account for jumps or other risk factors apart from
index risk. Figure 13.8 shows a case where a delta hedging strategy performs reasonably well
until a jump in the EURO STOXX 50 index level occurs and the option is exercised right
afterwards. As a consequence of the jump, the dynamic hedging strategy breaks down since
the replication portfolio payoff after the jump is insufficient to account for the steep increase
in the put option‚Äôs value (cf. Tankov and Voltchkova (2009) for a similar numerical example).
     In summary, with regard to a single option, delta hedging is obviously not sufficient‚Äîat
least if one takes the terms ‚Äúhedging‚Äù and ‚Äúreplication‚Äù seriously. What one rather needs is
the static or dynamic addition of other (plain vanilla) options on the same underlying to the
hedge portfolio.6


6
 Again, refer to Tankov and Voltchkova (2009) for this insight as well as to Cont et al. (2007) for the
implementation of hedging strategies with options in the presence of jumps.
288                                                     DERIVATIVES ANALYTICS WITH PYTHON




 FIGURE 13.6   Dynamic replication of American put option in BCC97 with loss at maturity




      FIGURE 13.7 Frequency distribution of (discounted) P&L at exercise date of
      10,000 dynamic replications of American put option in general market model BCC97
Dynamic Hedging                                                                              289




 FIGURE 13.8 Dynamic replication of American put option in BCC97 with large loss at exercise
 due to an index jump



13.4 CONCLUSIONS

This chapter analyzes the market-based dynamic hedging and replication of American index
options. As it turns out, delta hedging works quite well in the benchmark model of BSM.
However, delta hedging may break down in the general market model of BCC97 since jumps
make this model incomplete in a wider sense leading to the impossibility of perfectly replicating
options by trading in the available underlyings (or even other options to this end).



13.5 PYTHON SCRIPTS

13.5.1 LSM Delta Hedging in BSM (Single Path)

#
# Dynamic Hedging of American Put Option in BSM Model
# with Least Squares Monte Carlo
# 13_dyh/BSM_lsm_hedging_algorithm.py
#
# (c) Dr. Yves J. Hilpisch
290                                             DERIVATIVES ANALYTICS WITH PYTHON


# Derivatives Analytics with Python
#
import math
import numpy as np
import warnings
warnings.simplefilter('ignore')
import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
import matplotlib.pyplot as plt


#
# Parameters
#
S0 = 36.0     # initial stock value
K = 40.0 # strike price
T = 1.0 # time to maturity
r = 0.06 # risk-less short rate
sigma = 0.20 # volatility of stock value
M = 50 # number of time steps
I = 50000 # number of paths


#
# Valuation
#
D = 9    # number of regression functions



def BSM_lsm_put_value(S0, M, I):
    ''' Function to value an American put option by LSM algorithm.


      Parameters
      ==========
      S0: float
          initial index level
      M: int
          number of time steps


      Returns
      =======
      V0: float
          LSM Monte Carlo estimator of American put option value
      S: NumPy array
          simulated index level paths
      ex: NumPy array
          exercise matrix
      rg: NumPy array
          regression coefficients
Dynamic Hedging                                                               291


    h: NumPy array
        inner value matrix
    dt: float
        length of time interval
    '''
    rand = np.random.standard_normal((M + 1, I))      # random numbers
    dt = T / M   # length of time interval
    df = math.exp(-r * dt) # discount factor
    S = np.zeros((M + 1, I), dtype=np.float) # stock price matrix
    S[0] = S0 # initial values
    for t in xrange(1, M + 1, 1): # stock price at t
        S[t] = S[t - 1] * (np.exp((r - sigma ** 2 / 2) * dt
                            + sigma * math.sqrt(dt) * rand[t]))
    h = np.maximum(K - S, 0) # inner values
    V = np.maximum(K - S, 0) # value matrix
    ex = np.zeros((M + 1, I), dtype=np.float)    # exercise matrix
    C = np.zeros((M + 1, I), dtype=np.float)    # continuation value matrix
    rg = np.zeros((M + 1, D + 1), dtype=np.float)
      # matrix for reg. coefficients
    for t in range(M - 1, 0, -1):
         rg[t] = np.polyfit(S[t], V[t + 1] * df, D)
         # regression in step i
         C[t] = np.polyval(rg[t], S[t])
         # estimated continuation values
         C[t] = np.where(C[t] < 0, 0., C[t])
         # correction for neg C
         V[t] = np.where(h[t] >= C[t],
                       h[t], V[t + 1] * df) # exercise decision
         ex[t] = np.where(h[t] >= C[t], 1, 0)
        # exercise decision (yes=1)
    V0 = np.sum(V[1]) / I * df
    return V0, S, ex, rg, h, dt

def BSM_hedge_run(p=0):
    ''' Implements delta hedging for a single path. '''
    np.random.seed(50000)
    #
    # Initial Delta
    #
    ds = 0.01
    V_1, S, ex, rg, h, dt = BSM_lsm_put_value(S0 + ds, M, I)
    V_2 = BSM_lsm_put_value(S0, M, I)[0]
    del_0 = (V_1 - V_2) / ds


    #
    # Dynamic Hedging
    #
292                                                   DERIVATIVES ANALYTICS WITH PYTHON


      delt = np.zeros(M + 1, dtype=np.float)     # vector for deltas
      print
      print "APPROXIMATION OF FIRST ORDER "
      print "-----------------------------"
      print " %7s | %7s | %7s " % ('step', 'S_t', 'Delta')
      for t in xrange(1, M, 1):
          if ex[t, p] == 0: # if option is alive
              St = S[t, p] # relevant index level
              diff = (np.polyval(rg[t], St + ds) -
                      np.polyval(rg[t], St))
                      # numerator of difference quotient
              delt[t] = diff / ds # delta as difference quotient
              print " %7d | %7.2f | %7.2f" % (t, St, delt[t])
              if (S[t, p] - S[t - 1, p]) * (delt[t] - delt[t - 1]) < 0:
                  print "             wrong"
          else:
              break


      delt[0] = del_0
      print
      print "DYNAMIC HEDGING OF AMERICAN PUT (BSM)"
      print "---------------------------------------"
      po = np.zeros(t, dtype=np.float) # vector for portfolio values
      vt = np.zeros(t, dtype=np.float)     # vector for option values
      vt[0] = V_1
      po[0] = V_1
      bo = V_1 - delt[0] * S0     # bond position value
      print "Initial Hedge"
      print "Stocks                %8.3f" % delt[0]
      print "Bonds                 %8.3f" % bo
      print "Cost                  %8.3f" % (delt[0] * S0 + bo)


      print
      print "Regular Rehedges "
      print 68 * "-"
      print "step|" + 7 * " %7s|" % ('S_t', 'Port', 'Put',
                            'Diff', 'Stock', 'Bond', 'Cost')
      for j in range(1, t, 1):
          vt[j] = BSM_lsm_put_value(S[j, p], M - j, I)[0]
          po[j] = delt[j - 1] * S[j, p] + bo * math.exp(r * dt)
          bo = po[j] - delt[j] * S[j, p] # bond position value
          print "%4d|" % j + 7 * " %7.3f|" % (S[j, p], po[j], vt[j],
                          (po[j] - vt[j]), delt[j], bo, delt[j] * S[j, p] + bo)


      errs = po - vt    # hedge errors
      print "MSE               %7.3f" % (np.sum(errs ** 2) / len(errs))
      print "Average Error      %7.3f" % (np.sum(errs) / len(errs))
Dynamic Hedging                                                    293


    print "Total P&L       %7.3f" % np.sum(errs)
    return S[:, p], po, vt, errs, t


def plot_hedge_path(S, po, vt, errs, t):
    #
    # Graphical Output
    #
    tl = np.arange(t)
    plt.figure(figsize=(8, 6))
    plt.subplot(311)
    plt.grid(True)
    plt.plot(tl, S[tl], 'r')
    plt.ylabel('index level')
    plt.subplot(312)
    plt.grid(True)
    plt.plot(tl, po[tl], 'r-.', label='portfolio value', lw=2)
    plt.plot(tl, vt[tl], 'b', label='option value', lw=1)
    plt.ylabel('value')
    plt.legend(loc=0)
    ax = plt.axis()
    plt.subplot(313)
    plt.grid(True)
    wi = 0.3
    diffs = po[tl] - vt[tl]
    plt.bar(tl - wi / 2, diffs, color='b', width=wi)
    plt.ylabel('difference')
    plt.xlabel('time step')
    plt.axis([ax[0], ax[1], min(diffs) * 1.1, max(diffs) * 1.1])
    plt.tight_layout()




13.5.2 LSM Delta Hedging in BSM (Multiple Paths)

#
# Dynamic Hedging of American Put Option in BSM Model
# with Least Squares Monte Carlo -- Histogram
# 13_dyh/BSM_lsm_hedging_histogram.py
#
# (c) Dr. Yves s. Hilpisch
# Derivatives Analytics with Python
#
from BSM_lsm_hedging_algorithm import *


def BSM_dynamic_hedge_mcs(M=50, I=10000):
    ''' Monte Carlo simulation of dynamic hedging paths
    for American put option in BSM model. '''
294                                              DERIVATIVES ANALYTICS WITH PYTHON


      #
      # Initial Delta
      #
      ds = 0.01
      V_1, S, ex, rg, h, dt = BSM_lsm_put_value(S0 + ds, M, I)
      V_2 = BSM_lsm_put_value(S0, M, I)[0]
      del_0 = (V_1 - V_2) / ds

      print"Value of American Put Option is %8.3f" % V_2
      print"Delta t=0 is                     %8.3f" % del_0
      #
      # Dynamic Hedging Runs
      #
      pl_list = []
      run = 0
      runs = min(I, 10000)
      for run in xrange(runs):
          p = run
          run += 1
          delta = np.zeros(M + 1, dtype=np.float)   # vector for deltas
          for t in xrange(0, M, 1):
              if ex[t - 1, p] == 0: # if option is alive
                  St = S[t, p] # relevant index level
                  diff = (np.polyval(rg[t, :], St + ds)
                        - np.polyval(rg[t, :], St))
                           # numerator of difference quotient
                  delta[t] = diff / ds   # delta as difference quotient
              else:
                  break
          delta[0] = del_0
          po = np.zeros(t, dtype=np.float)   # vector for portfolio values
          vt = np.zeros(t, dtype=np.float) # vector for option values
          vt[0] = V_2 # initial option value
          po[0] = V_2 # initial portfolio value
          bo = V_2 - delta[0] * S0 # initial bond position value
          for s in range(1, t, 1): # for all times up to i-1
              po[s] = delta[s - 1] * S[s, p] + bo * math.exp(r * dt)
                # portfolio payoff
              bo = po[s] - delta[s] * S[s, p] # bond position value
              if s == t - 1: # at exercise/expiration date
                  vt[s] = h[s, p] # option value equals inner value
                  pl = (po[s] - vt[s]) * math.exp(-r * t * dt)
                    # discounted difference between option and portfolio value
                  if run % 1000 == 0:
                      print "run %5d  p/l %8.3f" % (run, pl)
                  pl_list.append(pl) # collect all differences
      pl_list = np.array(pl_list)
Dynamic Hedging                                                  295


    #
    # Summary Results Output
    #
    print "\nSUMMARY STATISTICS FOR P&L"
    print "---------------------------------"
    print "Dynamic Replications %12d" % runs
    print "Time Steps             %12d" % M
    print "Paths for Valuation    %12d" % I
    print "Maximum                %12.3f" % max(pl_list)
    print "Average                %12.3f" % np.mean(pl_list)
    print "Median                 %12.3f" % np.median(pl_list)
    print "Minimum                %12.3f" % min(pl_list)
    print "---------------------------------"


    return pl_list

def plot_hedge_histogram(pl_list):
    ''' Plot of P/L histogram. '''
    #
    # Graphical Output
    #
    plt.figure(figsize=(8, 6))
    plt.grid()
    plt.hist(pl_list, 75)
    plt.xlabel('profit/loss')
    plt.ylabel('frequency')




13.5.3 LSM Algorithm for American Put in BCC97

#
# Delta Hedging an American Put Option in BCC97
# via Least Squares Monte Carlo (Multiple Replications)
# 13_dyh/BCC97_lsm_hedging_algorithm.py
#
# (c) Dr. Yves J. Hilpisch
# Derivatives Analytics with Python
#
import sys
sys.path.extend(['09_gmm', '11_cal', '12_val'])
import math
import numpy as np
import warnings
warnings.simplefilter('ignore')
296                                             DERIVATIVES ANALYTICS WITH PYTHON


import matplotlib as mpl
mpl.rcParams['font.family'] = 'serif'
import matplotlib.pyplot as plt
from H93_calibration import S0, kappa_r, theta_r, sigma_r, r0
from BCC97_simulation import *
from BSM_lsm_hedging_algorithm import plot_hedge_path


#
# Model Parameters
#
opt = np.load('11_cal/opt_full.npy')
kappa_v, theta_v, sigma_v, rho, v0, lamb, mu, delta = opt


#
# Simulation
#
K = S0
T = 1.0
M = 50
I = 50000
a = 1.0 # a from the interval [0.0, 2.0]
dis = 0.01 # change of S[t] in percent to estimate derivative
dt = T / M
moment_matching = True

def BCC97_lsm_put_value(S0, K, T, M, I):
      ''' Function to value American put options by LSM algorithm.

      Parameters
      ==========
      S0: float
          intial index level
      K: float
          strike of the put option
      T: float
          final date/time horizon
      M: int
          number of time steps
      I: int
          number of paths


      Returns
      =======
      V0: float
          LSM Monte Carlo estimator of American put option value
      S: NumPy array
          simulated index level paths
Dynamic Hedging                                                              297


    r: NumPy array
        simulated short rate paths
    v: NumPy array
        simulated variance paths
    ex: NumPy array
        exercise matrix
    rg: NumPy array
        regression coefficients
    h: NumPy array
        inner value matrix
    dt: float
        length of time interval
    '''
    dt = T / M
    # Cholesky Matrix
    cho_matrix = generate_cholesky(rho)
    # Random Numbers
    rand = random_number_generator(M, I, anti_paths, moment_matching)
    # Short Rate Process Simulation
    r = SRD_generate_paths(r0, kappa_r, theta_r, sigma_r, T, M, I,
                                rand, 0, cho_matrix)
    # Variance Process Simulation
    v = SRD_generate_paths(v0, kappa_v, theta_v, sigma_v, T, M, I,
                                rand, 2, cho_matrix)
    # Index Level Process Simulation
    S = B96_generate_paths(S0, r, v, lamb, mu, delta, rand, 1, 3,
                                     cho_matrix, T, M, I, moment_matching)
    h = np.maximum(K - S, 0)   # inner value matrix
    V = np.maximum(K - S, 0)   # value/cash flow matrix
    ex = np.zeros_like(V) # exercise matrix
    D = 10 # number of regression functions
    rg = np.zeros((M + 1, D + 1), dtype=np.float)
      # matrix for regression parameters
    for t in xrange(M - 1, 0, -1):
         df = np.exp(-(r[t] + r[t + 1]) / 2 * dt)
         # select only ITM paths
         itm = np.greater(h[t], 0)
         relevant = np.nonzero(itm)
         rel_S = np.compress(itm, S[t])
         no_itm = len(rel_S)
         if no_itm == 0:
             cv = np.zeros((I), dtype=np.float)
         else:
             rel_v = np.compress(itm, v[t])
             rel_r = np.compress(itm, r[t])
             rel_V = (np.compress(itm, V[t + 1])
                        * np.compress(itm, df))
298                                              DERIVATIVES ANALYTICS WITH PYTHON


              matrix = np.zeros((D + 1, no_itm), dtype=np.float)
              matrix[10] = rel_S * rel_v * rel_r
              matrix[9] = rel_S * rel_v
              matrix[8] = rel_S * rel_r
              matrix[7] = rel_v * rel_r
              matrix[6] = rel_S ** 2
              matrix[5] = rel_v ** 2
              matrix[4] = rel_r ** 2
              matrix[3] = rel_S
              matrix[2] = rel_v
              matrix[1] = rel_r
              matrix[0] = 1
              rg[t] = np.linalg.lstsq(matrix.transpose(), rel_V)[0]
              cv = np.dot(rg[t], matrix)
          erg = np.zeros((I), dtype=np.float)
          np.put(erg, relevant, cv)
          V[t] = np.where(h[t] > erg, h[t], V[t + 1] * df)
              # value array
          ex[t] = np.where(h[t] > erg, 1, 0)
              # exercise decision
      df = np.exp(-((r[0] + r[1]) / 2) * dt)
      V0 = max(np.sum(V[1, :] * df) / I, h[0, 0])      # LSM estimator
      return V0, S, r, v, ex, rg, h, dt


def BCC97_hedge_run(p):
    ''' Implements delta hedging for a single path. '''
      #
      # Initializations
      #
      np.random.seed(50000)
      po = np.zeros(M + 1, dtype=np.float)   # vector for portfolio values
      vt = np.zeros(M + 1, dtype=np.float) # vector for option values
      delt = np.zeros(M + 1, dtype=np.float) # vector for deltas
      # random path selection ('real path')
      print
      print "DYNAMIC HEDGING OF AMERICAN PUT (BCC97)"
      print "---------------------------------------"
      ds = dis * S0
      V_1, S, r, v, ex, rg, h, dt = BCC97_lsm_put_value(S0 + (2 - a) * ds,
                                                     K, T, M, I)
      # 'data basis' for delta hedging
      V_2 = BCC97_lsm_put_value(S0 - a * ds, K, T, M, I)[0]
      delt[0] = (V_1 - V_2) / (2 * ds)
      V0LSM = BCC97_lsm_put_value(S0, K, T, M, I)[0]
        # initial option value for S0
      vt[0] = V0LSM # initial option values
      po[0] = V0LSM # initial portfolio values
      bo = V0LSM - delt[0] * S0 # initial bond position value
Dynamic Hedging                                                              299


    print "Initial Hedge"
    print "Stocks               %8.3f" % delt[0]
    print "Bonds                %8.3f" % bo
    print "Cost                 %8.3f" % (delt[0] * S0 + bo)

    print
    print "Regular Rehedges "
    print 82 * "-"
    print "step|" + 7 * " %9s|" % ('S_t', 'Port', 'Put',
                          'Diff', 'Stock', 'Bond', 'Cost')
    for t in range(1, M + 1, 1):
        if ex[t, p] == 0:
             df = math.exp((r[t, p] + r[t - 1, p]) / 2 * dt)
             if t != M:
                  po[t] = delt[t - 1] * S[t, p] + bo * df
                  vt[t] = BCC97_lsm_put_value(S[t, p], K, T - t * dt,
                                              M - t, I)[0]
                  ds = dis * S[t, p]
                  sd = S[t, p] + (2 - a) * ds # disturbed index level
                  stateV_A = [sd * v[t, p] * r[t, p],
                              sd * v[t, p],
                              sd * r[t, p],
                              v[t, p] * r[t, p],
                              sd ** 2,
                              v[t, p] ** 2,
                              r[t, p] ** 2,
                              sd,
                              v[t, p],
                              r[t, p],
                              1]
                              # state vector for S[t, p] + (2.0 - a) * dis
                  stateV_A.reverse()
                  V0A = max(0, np.dot(rg[t], stateV_A))
                  # print V0A
                  # revaluation via regression
                  sd = S[t, p] - a * ds # disturbed index level
                  stateV_B = [sd * v[t, p] * r[t, p],
                              sd * v[t, p],
                              sd * r[t, p],
                              v[t, p] * r[t, p],
                              sd ** 2,
                              v[t, p] ** 2,
                              r[t, p] ** 2,
                              sd,
                              v[t, p],
                              r[t, p],
                              1]
                              # state vector for S[t, p] - a * dis
300                                               DERIVATIVES ANALYTICS WITH PYTHON


                  stateV_B.reverse()
                  V0B = max(0, np.dot(rg[t], stateV_B))
                  # print V0B
                  # revaluation via regression
                  delt[t] = (V0A - V0B) / (2 * ds)
                  bo = po[t] - delt[t] * S[t, p] # bond position value
               else:
                   po[t] = delt[t - 1] * S[t, p] + bo * df
                   vt[t] = h[t, p]
                   # inner value at final date
                   delt[t] = 0.0
               print "%4d|" % t + 7 * " %9.3f|" % (S[t, p], po[t], vt[t],
                           (po[t] - vt[t]), delt[t], bo, delt[t] * S[t, p] + bo)
          else:
               po[t] = delt[t - 1] * S[t, p] + bo * df
               vt[t] = h[t, p]
               break
      errs = po - vt # hedge errors
      print "MSE            %7.3f" % (np.sum(errs ** 2) / len(errs))
      print "Average Error  %7.3f" % (np.sum(errs) / len(errs))
      print "Total P&L       %7.3f" % np.sum(errs)
      return S[:, p], po, vt, errs, t




13.5.4 LSM Delta Hedging in BCC97 (Single Path)

#
# Delta Hedging an American Put Option in BCC97
# via Least Squares Monte Carlo (Multiple Replications)
# 13_dyh/BCC97_lsm_hedging_histogram.py
#
# (c) Dr. Yves s. Hilpisch
# Derivatives Analytics with Python
#
from BCC97_lsm_hedging_algorithm import *
from CIR_zcb_valuation_gen import B
from BSM_lsm_hedging_histogram import plot_hedge_histogram


#
# Simulation
#
T = 1.0
a = 1.0   # a from the interval [0.0, 2.0]
dis = 0.05   # change of S[t] in percent to estimate derivative
dt = T / M
np.random.seed(50000)
def BCC97_hedge_simulation(M=50, I=10000):
Dynamic Hedging                                                                   301


    ''' Monte Carlo simualtion of dynamic hedging paths
    for American put option in BSM model. '''
    #
    # Initializations
    #
    po = np.zeros(M + 1, dtype=np.float)      # vector for portfolio values
    delt = np.zeros(M + 1, dtype=np.float)      # vector for deltas
    ds = dis * S0
    V_1, S, r, v, ex, rg, h, dt = BCC97_lsm_put_value(S0 + (2 - a) * ds,
                                                          K, T, M, I)
    # 'data basis' for delta hedging
    V_2 = BCC97_lsm_put_value(S0 - a * ds, K, T, M, I)[0]
    delt[0] = (V_1 - V_2) / (2 * ds)
    V0LSM = BCC97_lsm_put_value(S0, K, T, M, I)[0]      # initial option value for S0
    po[0] = V0LSM     # initial portfolio values


    #
    # Hedge Runs
    #
    pl_list = []
    runs = min(I, 10000)
    for run in range(runs):
        bo = V0LSM - delt[0] * S0       # initial bond position value
        p = run
        run += 1
        for t in range(1, M + 1, 1):
             if ex[t, p] == 0:
                   df = math.exp((r[t, p] + r[t - 1, p]) / 2 * dt)
                   if t != M:
                      po[t] = delt[t - 1] * S[t, p] + bo * df    # portfolio payoff
                      ds = dis * S[t, p]
                      sd = S[t, p] + (2 - a) * ds    # disturbed index level
                      stateV_A = [sd * v[t, p] * r[t, p],
                                   sd * v[t, p],
                                   sd * r[t, p],
                                   v[t, p] * r[t, p],
                                   sd ** 2,
                                   v[t, p] ** 2,
                                   r[t, p] ** 2,
                                   sd,
                                   v[t, p],
                                   r[t, p],
                                   1]
                          # state vector for S[t, p] + (2.0 - a) * ds
                      stateV_A.reverse()
                      V0A = max(0, np.dot(rg[t], stateV_A))
                      # revaluation via regression
                      sd = S[t, p] - a * ds    # disturbed index level
                      stateV_B = [sd * v[t, p] * r[t, p],
302                                                   DERIVATIVES ANALYTICS WITH PYTHON


                                    sd * v[t, p],
                                    sd * r[t, p],
                                    v[t, p] * r[t, p],
                                    sd ** 2,
                                    v[t, p] ** 2,
                                    r[t, p] ** 2,
                                    sd,
                                    v[t, p],
                                    r[t, p],
                                    1]
                          # state vector for S[t, p] - a * ds
                       stateV_B.reverse()
                       V0B = max(0, np.dot(rg[t], stateV_B))
                       # revaluation via regression
                       delt[t] = (V0A - V0B) / (2 * ds)
                  else:
                       po[t] = delt[t - 1] * S[t, p] + bo * df
                       delt[t] = 0.0
                  bo = po[t] - delt[t] * S[t, p]
              else:
                  po[t] = delt[t - 1] * S[t, p] + bo * df
                  break
          alpha_t = [kappa_r, theta_r, sigma_r, r0, 0.0, t * dt]
          pl = (po[t] - h[t, p]) * B(alpha_t)
          if run % 1000 == 0:
              print "run %5d    p/l %8.3f" % (run, pl)
          pl_list.append(pl)
      pl_list = np.array(pl_list)


      #
      # Results Output
      #
      print "\nSUMMARY STATISTICS FOR P&L"
      print "---------------------------------"
      print "Dynamic Replications %12d" % runs
      print "Time Steps             %12d" % M
      print "Paths for Valuation    %12d" % I
      print "Maximum                %12.3f" % max(pl_list)
      print "Average                %12.3f" % np.mean(pl_list)
      print "Median                 %12.3f" % np.median(pl_list)
      print "Minimum                %12.3f" % min(pl_list)
      print "---------------------------------"


      return pl_list
                                                                         CHAPTER         14
                                                      Executive Summary


This book is about the market-based valuation of European and American stock index options.
It is a discipline of particular interest in derivatives analytics. To this end, it introduces‚Äîamong
a number of basic tools and approaches‚Äîthe general market model from Bakshi-Cao-Chen
(cf. Bakshi et al. (1997)) as a framework to accomplish the following goals:

   modeling market risks: the model should account for market risks generally affecting
    index options, like index level risk, volatility risk, jump risk and interest rate risk
   efficient valuation of vanilla options: as a major requirement, the market model should be

    able to value plain vanilla options, like European puts or calls on an index, in an efficient
    manner; as it turns out, the Fourier transform method in combination with numerical
    integration or Fast Fourier Transforms (FFT) offers a convenient approach to accomplish
    this
   calibration of model parameters: equipped with efficient techniques for the valuation

    of plain vanilla options, the model can then be calibrated to observed market quotes of
    such instruments in order to derive a single martingale measure for the valuation of other
    (exotic) index derivatives
   valuation by simulation: in general, numerical methods are necessary to value the

    majority of (exotic) equity derivatives; Monte Carlo simulation (MCS) is the most flexible
    one with the Least-Squares Monte Carlo (LSM) algorithm (cf. Longstaff and Schwartz
    (2001)) allowing for the incorporation of early exercise features
   dynamic delta hedging: relying on the LSM algorithm, it is possible to numerically

    estimate deltas for (exotic) equity derivatives even with American exercise; however, due
    to market incompleteness (e.g. because of jumps) delta hedging on a stand-alone basis
    is generally insufficient to hedge or replicate equity derivatives sufficiently well in the
    general market model of Bakshi-Cao-Chen (1997)

     The whole exposition is accompanied by a self-contained set of Python scripts which
allows the easy replication of the results and graphics presented throughout the book. All
Python codes and additional IPython Notebooks are provided on the Quant Platform under
http://wiley.quant-platform.com. For further resources see also http://derivatives-analytics-
with-python.com.




                                                                                               303
                                                                        APPENDIX         A
                                                   Python in a Nutshell


T   his appendix introduces into the Python language mainly by the means of simple interactive
    examples and some shorter code snippets (i.e. modules and scripts). It cannot replace any
kind of proper training in this programming language or more comprehensive treatments in
book form.
     By reading this appendix, you will NOT learn how to code in general or learn Python
from scratch to black belt level. However, for someone coming with C++ experience, for
example, the appendix illustrates fundamental aspects of Python that are useful for derivatives
analytics and financial engineering in general. For someone who starts out in these areas,
the topics covered provide a first glimpse at coding in general and for derivatives analytics
in particular. For this group, the appendix may act as a starting point for digging deeper into
areas of further interest.
     The best Python foundation for this book can be gained by reading the recent book by
the same author (Hilpisch, 2014). That book focuses on teaching Python for finance and
covers many topics of interest in this area on more than 600 pages. Another useful book is
McKinney (2012) which introduces in detail the main data analysis tools and libraries needed
for the applications presented in this book (in particular NumPy and pandas). For general
introductions to Python from a scientific point of view, you can consult either the book by
Langtangen (2009) or the freely available lecture notes of Haenel et al. (2013).


A.1 PYTHON FUNDAMENTALS

This first section is about some important, fundamental topics when it comes to Python usage.


A.1.1 Installing Python Packages
No matter what operating system you use, make sure to install at least current versions of the
following Python packages/libraries:

   Python 2.7.x (www.python.org ): the basic Python interpreter
   NumPy (http://numpy.scipy.org): library to efficiently handle (large) arrays at high speed
   SciPy (www.scipy.org): library with many useful scientific functions




                                                                                           305
    306                                                         APPENDIX A: PYTHON IN A NUTSHELL


       matplotlib (http://matplotlib.sourceforge.net): the standard 2d and 3d plotting library
       pandas (http://pandas.sourceforge.net): efficient and fast data analysis, for example, of
        financial time series
       PyTables (www.pytables.org): handling of HDF5 database files for high performance I/O

        operations
       IPython (www.ipython.org): interactive analytics and development environment (shell,

        browser-based)
       xlrd, xlwt (www.python-excel.org): functions to work with Microsoft Excel spreadsheet

        files

         Having installed these packages/libraries (and maybe additional ones on which these
    particular ones are dependent) allows to use all modules and scripts provided in the book and to
    follow this appendix. However, installing single packages and libraries might sometimes prove
    too time consuming and inefficient. It is therefore recommended to work on the Quant Platform
    (cf. http://wiley.quant-platform.com) or to at least install a complete Python distribution which
    comes in general with the most important libraries in those versions that are compatible with
    each other.
         For example, Anaconda is a distribution of a Python base system in combination with
    quite a large number of useful libraries and tools for scientific purposes. It is pretty well
    suited for financial application building and interactive financial analytics. The website
    www.continuum.io provides current downloads and further information. It is available for
    all popular operating systems. Installing a complete distribution like Anaconda is generally
    relatively easy and fast. It also greatly simplifies the updating of single libraries and the
    interpreter itself.
         One might wonder why Python version 2.7.x is used in this book and not the newest
    generation of Python which is already 3.4 at the time of this writing. There are two reasons.
    First, Python 2.7.x is current (at the end of 2014) and still maintained by the Open Source
    community. Second, some syntax has changed in 3.x such that the versions are not fully
    compatible‚Äîand most code in the financial ecosystem and documentation available is still
    based on Python 2.7.x. On the other hand, the majority of the code presented in this book is
    either executable with a Python 3.4 interpreter without any changes or relatively easy to adjust
    for this version.


    A.1.2 First Steps with Python
    After starting IPython, a popular and powerful interactive shell for Python, you should see
    something like this on your screen:


1    yhilpisch@ONE:Àú$ ipython
2    Python 2.7.8 |Anaconda 2.0.1 (64-bit)| (default, Aug 21 2014, 18:22:21)
3    Type "copyright", "credits" or "license" for more information.
4
5    IPython 2.3.0 -- An enhanced Interactive Python.
6    Anaconda is brought to you by Continuum Analytics.
7    Please check out: http://continuum.io/thanks and https://binstar.org
8    ?         -> Introduction and overview of IPython's features.
     Appendix A: Python in a Nutshell                                                                             307

 9       %quickref -> Quick reference.
10       help        -> Python's own help system.
11       object?     -> Details about 'object', use 'object??' for extra details.
12
13       In [1]:


          Before a first module (something that can be imported) or script (something that can be
     executed stand-alone) is implemented, some first and simple exercises on the shell with the
     interpreter may serve as a warm-up.

 1       In [1]: 3 + 4
 2       Out[1]: 7
 3
 4       In [2]: 3 / 4
 5       Out[2]: 0
 6
 7       In [3]:


          Addition seems to work well, but division apparently not. This is due to Python interpreting
     3 and 4 as integers such that division gives 0 instead of 0.75. Putting a dot behind either 3 or
     4 or both does the trick (i.e. one tells Python that one is working with floats).1

 1       In [3]: 3.0 / 4
 2       Out[3]: 0.75
 3
 4       In [4]:


         Obviously, types are important with Python. One has to be careful since Python is a
     dynamically typed language which means that there are default types which are used given
     a specific context. In C++, for example, you would have to assign a certain static type to
     a variable before using it. Variable names (more general: reference pointers) are defined in
     Python with the = sign:

 1       In [4]: a = 3
 2
 3       In [5]: b = 4
 4
 5       In [6]: a / b
 6       Out[6]: 0
 7


     1
      In Python 3.x, the float division is the default setting while in Python 2.x it is the floor or integer division.
     In Python 3.x, you have the following syntax for both types of division: 3 / 4 for float division and 3 // 4
     for floor division.
     308                                                          APPENDIX A: PYTHON IN A NUTSHELL


 8    In [7]: a = 3.0
 9
10    In [8]: a / b
11    Out[8]: 0.75
12
13    In [9]:




         Even if the Python interpreter has already built in lots of functionality, most of it is stored
     in modules or whole packages of different modules which have to be imported before usage.
     An example is the math module which comes with the so-called standard library and contains,
     among others, trigonometric functions.


 1    In [1]: a = 3.0
 2
 3    In [2]: sin(a)
 4    --------------------------------------------------------------------------
 5    NameError                                Traceback (most recent call last)
 6    <ipython-input-3-66bf5e82d1e2> in <module>()
 7    ----> 1 sin(a)
 8
 9    NameError: name 'sin' is not defined
10
11    In [3]: from math import sin
12
13    In [4]: sin(a)
14    Out[4]: 0.1411200080598672
15
16    In [5]:




         If you want to indicate that the sin function is from the math module (which is
     recommended), you have to import the module/library itself and not the functions that are
     contained therein.


 1    In [5]: b = 4
 2
 3    In [6]: import math
 4
 5    In [7]: math.sin(b)
 6    Out[7]: -0.7568024953079282
 7
 8    In [8]:
     Appendix A: Python in a Nutshell                                                             309


           You can easily define functions by yourself.

 1       In [8]: def f(x):
 2          ...:        return x ** 3 + x ** 2 - 2 + math.sin(x)
 3
 4       In [9]: f(2)
 5       Out[9]: 10.909297426825681
 6
 7       In [10]: f(a)
 8       Out[10]: 34.141120008059865
 9
10       In [11]:


          Here, x ** 3 stands for x3 . Generally, if you are doing something useful which you would
     like to store for later use you would not work with a command line interpreter or a shell. Rather,
     you would open a new file (module/script), store the function in it and save it on disk. Python
     modules/scripts are characterized by the .py suffix. A new module can be generated with a
     dedicated Python editor or with the most simple text editor. In fact, Python modules/scripts
     are nothing more or less than text files.
          In such a file, say with name a_first_program.py, you could store the previous code
     like this:

     #
     # First Program with Python
     # A_pyt/a_first_program.py
     #
     import math


     # Variable Definition
     a = 3.0
     b = 4


     # Function Definition



     def f(x):
           ''' Mathematical Function. '''
           return x ** 3 + x ** 2 - 2 + math.sin(x)


     # Calculation
     f_a = f(a)
     f_b = f(b)


     # Output
     print "f(a) = %6.3f" % f_a
     print "f(b) = %6.3f" % f_b
     310                                                                APPENDIX A: PYTHON IN A NUTSHELL


          The # sign allows the inclusion of comments in your code that are ignored by the Python
     interpreter. Make sure when saving Python modules to always include the suffix .py. Now you
     can run the script from IPython which should produce the following output:


 1    In [12]: %run a_first_program.py
 2    f(a) = 34.141
 3    f(b) = 77.243
 4
 5    In [13]:



         This should be enough for some very first steps with Python. This sub-section showed
     how to calculate, how to evaluate a numerical expression, how to define a function and how
     to write a script containing the function that can be executed.


     A.1.3 Array Operations
     NumPy is a powerful library that allows efficient array manipulations (linear algebra) in a
     compact form and at high speed. The speed comes from the implementation of main parts of
     the library in C. So you have the convenience of Python combined with the speed of C when
     doing array operations.


 1    In [1]: import numpy as np
 2
 3    In [2]: a = np.arange(0.0, 20.0, 1.0)                    # (start, end, step)
 4
 5    In [3]: a
 6    Out[3]:
 7    array([     0.,     1.,     2.,     3.,     4.,          5.,    6.,    7.,    8.,    9.,   10.,
 8               11.,    12.,    13.,    14.,    15.,         16.,   17.,   18.,   19.])
 9
10    In [4]: a.resize(4, 5)
11
12    In [5]: a
13    Out[5]:
14    array([[ 0.,         1.,     2.,     3.,         4.],
15              [ 5.,      6.,     7.,     8.,      9.],
16              [ 10.,    11.,    12.,    13.,     14.],
17              [ 15.,    16.,    17.,    18.,     19.]])
18
19    In [6]: a[0] # first row
20    Out[6]: array([ 0., 1., 2.,                3.,     4.])
21
22    In [7]: a[3] # fourth (=last) row
23    Out[7]: array([ 15., 16., 17., 18.,                       19.])
24
     Appendix A: Python in a Nutshell                                                           311

25    In [8]: a[1, 4]        # second row, 5th (=last) element
26    Out[8]: 9.0
27
28    In [9]: a[1, 2:4]           # second row, third & forth element
29    Out[9]: array([ 7.,           8.])
30
31    In [10]:


          The first examples of array definition and manipulation should be self-explanatory. Care
     is to be taken with the conventions regarding array indices. The best way to learn these is to
     play with arrays. In particular, note that zero-based numbering is used and that slicing (see
     input prompt 9) excludes the last value in the output.
          With NumPy, array operations are as easy to implement as operations on integers or
     floats. This is mainly due to the fact that it provides powerful vectorization and broadcasting
     capabilities (cf. chapter 4 in Hilpisch (2014)).

 1    In [10]: a * 0.5
 2    Out[10]:
 3    array([[ 0. , 0.5,            1. ,    1.5,        2. ],
 4              [ 2.5,     3. ,     3.5,    4. ,        4.5],
 5              [ 5. ,     5.5,     6. ,    6.5,        7. ],
 6              [ 7.5,     8. ,     8.5,    9. ,        9.5]])
 7
 8    In [11]: a ** 2
 9    Out[11]:
10    array([[       0.,      1.,         4.,          9.,      16.],
11           [      25.,     36.,        49.,         64.,      81.],
12              [ 100.,    121.,        144.,     169.,      196.],
13              [ 225.,    256.,        289.,     324.,      361.]])
14
15    In [12]: a + a
16    Out[12]:
17    array([[ 0.,         2.,       4.,        6.,      8.],
18              [ 10.,     12.,     14.,    16.,        18.],
19              [ 20.,     22.,     24.,    26.,        28.],
20              [ 30.,     32.,     34.,    36.,        38.]])
21
22    In [13]:


          One can also use the previously defined function f with NumPy arrays‚Äîone change is
     necessary, however: one has to now use the universal functions that NumPy provides instead
     of those of the math module.

 1    In [13]: def f(x):
 2        ...:     return x ** 3 + x ** 2 - 2 + np.sin(x)
     312                                                        APPENDIX A: PYTHON IN A NUTSHELL


 3
 4    In [14]: f(a)
 5    Out[14]:
 6    array([[ -2.00000000e+00,         8.41470985e-01,        1.09092974e+01,
 7              3.41411200e+01,         7.72431975e+01],
 8           [ 1.47041076e+02,          2.49720585e+02,        3.90656987e+02,
 9                 5.74989358e+02,      8.08412118e+02],
10             [   1.09745598e+03,      1.44900001e+03,        1.86946343e+03,
11                 2.36442017e+03,      2.93899061e+03],
12             [   3.59865029e+03,      4.34971210e+03,   5.19903860e+03,
13                 6.15324901e+03,      7.21814988e+03]])
14
15    In [15]:




        Here, the syntax e+03 is for 103 . Sometimes you need to loop over arrays to check
     something or to do some calculation. Looping is also quite intuitive in Python.



 1
 2    In [15]: for i in xrange(5):
 3       ....:     print i
 4         ....:
 5    0
 6    1
 7    2
 8    3
 9    4
10
11    In [16]: b = np.arange(0.0, 100.0, 1.0)
12
13    In [17]: for i in range(100):
14        ...:     if b[i] == 50.0:
15        ...:         print "50.0 at index no. %d" % i
16        ...:
17    50.0 at index no. 50
18
19    In [18]:




          Note that there is a difference between range and xrange: the first generates in one step
     a list object containing all the numbers while the latter instantiates a generator object which
     generates and returns values one by one (when called/needed). Like with array indexing note
     the zero-based numbering and the fact that the last value is not included in the results (i.e.
     xrange(5) starts at 0 and ends at 4).
          The difference between arange and range is that the first can produce arrays with elements
     of float type while the latter can only generate list objects containing integers; and indices
     Appendix A: Python in a Nutshell                                                             313


     of arrays are always integers which is why the loop is over integers and not over floats or
     something else.2
          In the iteration you will find something called string replacement. %d indicates that at the
     very place where it is found in the string the value of i should be shown‚Äîinstead of %d. It
     is convenient, for example, to ‚Äúparametrize‚Äù larger strings in this way. String replacement is
     also helpful when it comes to formatting:

 1       In [18]: print "%d divided by %d gives %6.3f" % (1000, 17, 1000./17)
 2       1000 divided by 17 gives 58.824
 3
 4       In [19]:


         %6.3f in the string is replaced by a 6 digit long float object (including the decimal point)
     with 3 decimals.

     A.1.4 Random Numbers
     Derivatives analytics cannot live without random numbers, be they either pseudo-random or
     quasi-random. NumPy has built in convenient functions for the generation of pseudo-random
     numbers in the sub-module random.3


 1       In [1]: import numpy as np
 2
 3       In [2]: b = np.random.standard_normal((4, 5))
 4
 5       In [3]: b
 6       Out[3]:
 7       array([[ 0.73262022, -0.32977027, -0.63735777,           0.29651912,      0.92829732],
 8                 [ 0.06622625, 1.68082578,      0.47302614, -0.44214276,         0.54175322],
 9                 [-0.66753795, -0.82754659,     0.3837979 , 0.45688461,          0.44984762],
10                 [-0.60468346,   1.84658194, -0.35433689,       0.50973071,      0.11169662]])
11
12       In [4]: np.sum(b)
13       Out[4]: 4.6144317809306132
14
15       In [5]: np.mean(b)
16       Out[5]: 0.23072158904653067
17
18       In [6]: np.std(b)
19       Out[6]: 0.7190698353463989
20
21       In [7]:



     2
      On data types and structures in Python see Chapter 4 of Hilpisch (2014).
     3
      Refer to Chapter 10 of Hilpisch (2014) for more background on generating pseudo-random numbers
     and simulating random variables as well as stochastic processes.
     314                                                         APPENDIX A: PYTHON IN A NUTSHELL


     A.1.5 Plotting
     In interactive financial analytics, one often wants to visualize results from calculations or
     simulations. The library matplotlib is quite powerful when it comes to 2d visualizations of any
     kind‚Äîbut also for 3d plotting. The most important types of graphics for derivatives analytics
     are line and dot plots as well as bar charts and histograms.


 1    In [8]: import matplotlib.pyplot as plt
 2
 3    In [9]: plt.plot(np.cumsum(b))
 4    Out[9]: [<matplotlib.lines.Line2D at 0x37c1890>]
 5
 6    In [10]: plt.xlabel('x axis')
 7    Out[10]: <matplotlib.text.Text at 0x343a210>
 8
 9    In [11]: plt.ylabel('y axis')
10    Out[11]: <matplotlib.text.Text at 0x343ec10>
11
12    In [12]: plt.grid(True)
13
14    In [13]: plt.show()
15
16    In [14]:



          cumsum calculates the running cumulative sum over an array. In this case it also flattens
     the two-dimensional array to a one-dimensional vector. Figure A.1 shows the output.




                FIGURE A.1    Example of figure with matplotlib‚Äîhere: line
     Appendix A: Python in a Nutshell                                                            315




                   FIGURE A.2     Example of figure with matplotlib‚Äîhere: dots and bars

           The next example combines a dot sub-plot with a bar sub-plot the result of which is shown
     in Figure A.2. Here, due to resizing of the array there is only a one-dimensional set of numbers
     (i.e. the array b is flattened again).


 1    In [15]: c = np.resize(b, 20)
 2
 3    In [16]: plt.figure()
 4    Out[16]: <matplotlib.figure.Figure at 0x420a710>
 5
 6    In [17]: plt.subplot(211)
 7    Out[17]: <matplotlib.axes.AxesSubplot at 0x47b2c10>
 8
 9    In [18]: plt.plot(c, 'ro') # red dots
10    Out[18]: [<matplotlib.lines.Line2D at 0x4935490>]
11
12    In [19]: plt.grid(True)
13
14    In [20]: plt.subplot(212)
15    Out[20]: <matplotlib.axes.AxesSubplot at 0x4935850>
16
17    In [21]: plt.bar(range(len(c)), c)
18    Out[21]: <Container object of 20 artists>
19
20    In [22]: plt.grid(True)
21
22    In [23]: plt.show()
23
24    In [24]:
316                                                               APPENDIX A: PYTHON IN A NUTSHELL


     This is already all one needs to implement the different European option pricing algorithms
in the next section. What may be missing will be added on the fly.


A.2 EUROPEAN OPTION PRICING

This section now illustrates Python usage by the means of specific financial algorithms. In
particular, it implements the Black-Scholes-Merton analytical option pricing formula, the
binomial option pricing model as well as a Monte Carlo valuation algorithm.


A.2.1 Black-Scholes-Merton Approach
The seminal model ÓàπBSM of Black-Scholes-Merton (cf. Black and Scholes (1973) and Merton
(1973)) is still a benchmark for the pricing of European options on stocks and stock indices.4
The analytical call option formula without dividends is

                                 C0 (K, T) = S0 ‚ãÖ N(d1 ) ‚àí e‚àírT ‚ãÖ K ‚ãÖ N(d2 )
                                                       (        )
                                             log K0 + r + ùúé2 T
                                                  S           2


                                        d1 ‚â°           ‚àö
                                                     ùúé T
                                                    ‚àö
                                        d2 ‚â° d1 ‚àí ùúé T

where N is the cumulative distribution function (cdf) of a standard normal random variable.
The single variables have the following meaning, respectively:

      C0 call option value today
      S0 index level today
      K strike price of the option

      T time-to-maturity of the call option
      r risk-less short rate
      ùúé volatility of index level (standard deviation of its returns)



     All we need additionally to implement the formula is the cdf for a standard normal
variable. We get this from the scipy library which contains a sub-library called stats.

#
# Valuation of European Call Option
# in Black-Scholes-Merton Model
# A_pyt/b_BSM_valuation.py
#
from scipy import stats
import math



4
    See Chapter 5 for details.
    Appendix A: Python in a Nutshell                                                   317


    # Option Parameters
    S0 = 105.00     # initial index level
    K = 100.00     # strike price
    T = 1.     # call option maturity
    r = 0.05     # constant short rate
    vola = 0.25     # constant volatility factor of diffusion

    # Analytical Formula

    def BSM_call_value(S0, K, T, r, vola):
         ''' Analytical European call option value for Black-Scholes-Merton (1973).

         Parameters
         ==========
         S0: float
               initial index level
         K: float
               strike price
         T: float
               time-to-maturity
         r: float
               constant short rate
         vola: float
               constant volatility factor

         Returns
         =======
         call_value: float
               European call option present value
         '''
         S0 = float(S0)      # make sure to have float type
         d1 = (math.log(S0 / K) + (r + 0.5 * vola ** 2) * T) / (vola * math.sqrt(T))
         d2 = d1 - vola * math.sqrt(T)
         call_value = (S0 * stats.norm.cdf(d1, 0.0, 1.0)
                   - K * math.exp(-r * T) * stats.norm.cdf(d2, 0.0, 1.0))
         return call_value

    # Output
    print "Value of European call option is %8.3f" \
           % BSM_call_value(S0, K, T, r, vola)


        The function BSM_call_value gives us a benchmark value for the European call option
    with the parameters as defined in the Python script:



1    In [3]: run b_BSM_valuation.py
2    Value of European call option is          15.655
3
4    In [4]:
318                                                                 APPENDIX A: PYTHON IN A NUTSHELL


A.2.2 Cox-Ross-Rubinstein Approach
To better understand how to implement the binomial option pricing model ÓàπCRR of Cox-
Ross-Rubinstein (Cox et al., 1979), a little background seems helpful.5
     There are two securities traded in the model: a risky stock index and a risk-less zero-
coupon bond. The time horizon [0, T] is divided into equidistant time intervals Œît so that one
gets M + 1 points in time t ‚àà {0, Œît, 2Œît, ..., T} with M ‚â° T‚àïŒît. The zero-coupon bond grows
p.a. in value with the risk-less short rate r, Bt = B0 ert where B0 > 0.
     Starting from a strictly positive, fixed stock index level of S0 at t = 0, the stock index
evolves according to the law


                                               St+Œît ‚â° St ‚ãÖ m

                                                                                 ‚àö
where m is selected randomly from {u, d}. Here, 0 < d < erŒît < u ‚â° eùúé Œît as well as u ‚â° d1
as a simplification which leads to a recombining tree.
     Assuming risk-neutral valuation holds, the following relationship can be derived

                                 St = e‚àírŒît ‚ãÖ EQ
                                               t [St+Œît ]
                                    = e‚àírŒît ‚ãÖ (q ‚ãÖ u ‚ãÖ St + (1 ‚àí q) ‚ãÖ d ‚ãÖ St )

Against this background, the risk-neutral (or martingale) probability is


                                                     erŒît ‚àí d
                                               q=
                                                      u‚àíd

The value of a European call option C0 is then obtained by discounting the final payoffs
CT (ST , K) ‚â° max[ST ‚àí K, 0] at t = T to t = 0:


                                           C0 = e‚àírT ‚ãÖ EQ
                                                        0
                                                          [CT ]


The discounting can be done step-by-step and node-by-node backwards starting at
t = T ‚àí Œît.
     From an algorithmical point of view, one has to first generate the index level values, then
determine the final payoffs of the call option and finally discount them back. This is what we
will do now, starting with a somewhat ‚Äúnaive‚Äù implementation. But before we do it, we generate
a Python module which contains all parameters that we will need for different implementations
afterwards. All parameters can be imported by using the import command and the respective
filename without the suffix .py (i.e. the filename is c_parameters.py and the module name is
c_parameters).


5
    See also Chapter 5 for more details.
Appendix A: Python in a Nutshell                                                   319


#
# Model Parameters for European Call Option
# and Binomial Model
# A_pyt/c_parameters.py
#
import math


# Option Parameters
S0 = 105.0     # initial index level
K = 100.0     # strike price
T = 1.    # call option maturity
r = 0.05     # constant short rate
vola = 0.25     # constant volatility factor of diffusion


# Time Parameters
M = 3    # time steps
dt = T / M     # length of time interval
df = math.exp(-r * dt)        # discount factor per time interval


# Binomial Parameters
u = math.exp(vola * math.sqrt(dt))       # up-movement
d = 1 / u     # down-movement
q = (math.exp(r * dt) - d) / (u - d)       # martingale probability




     Here is the first version of the implemented binomial model which uses nested loop
structures extensively (as would be the case, for example, in C or C++).


#
# Valuation of European Call Option in CRR1979 Model
# Loop Version (= C-like Iterations)
# A_pyt/d_CRR1979_loop.py
#
import numpy as np
from c_parameters import *


# Array Initialization for Index Levels
S = np.zeros((M + 1, M + 1), dtype=np.float)        # index level array
S[0, 0] = S0
z = 0
for j in xrange(1, M + 1, 1):
     z += 1
     for i in xrange(z + 1):
          S[i, j] = S[0, 0] * (u ** j) * (d ** (i * 2))


# Array Initialization for Inner Values
iv = np.zeros((M + 1, M + 1), dtype=np.float)        # inner value array
     320                                                             APPENDIX A: PYTHON IN A NUTSHELL


     z = 0
     for j in xrange(0, M + 1, 1):
           for i in xrange(z + 1):
               iv[i, j] = round(max(S[i, j] - K, 0), 8)
           z += 1


     # Valuation by Risk-Neutral Discounting
     pv = np.zeros((M + 1, M + 1), dtype=np.float)                # present value array
     pv[:, M] = iv[:, M]    # initialize last time step
     z = M + 1
     for j in xrange(M - 1, -1, -1):
           z -= 1
           for i in xrange(z):
               pv[i, j] = (q * pv[i, j + 1] + (1 - q) * pv[i + 1, j + 1]) * df


     # Result Output
     print "Value of European call option is %8.3f" % pv[0, 0]



          The command np.zeros((i, j), dtype=np.float) initializes a NumPy array object with shape
     i √ó j where each number is of the double float type. The execution of the script gives the
     following output and arrays where one can follow the three steps easily (index levels, inner
     values, discounting):


 1    In [3]: run d_CRR1979_Naive.py
 2    Value of European call option is               16.293
 3
 4    In [4]: S
 5    Out[4]:
 6    array([[ 105.               ,    121.30377267,       140.13909775,         161.89905958],
 7            [  0.               ,     90.88752771,       105.        ,         121.30377267],
 8             [    0.            ,      0.           ,        78.67183517,       90.88752771],
 9             [    0.            ,      0.           ,         0.        ,       68.09798666]])
10
11    In [5]: iv
12    Out[5]:
13    array([[ 5.             ,       21.30377267,     40.13909775,        61.89905958],
14             [    0.        ,        0.        ,        5.           ,   21.30377267],
15             [    0.        ,        0.        ,        0.           ,    0.        ],
16             [    0.        ,        0.        ,        0.           ,    0.        ]])
17
18    In [6]: pv
19    Out[6]:
20    array([[ 16.29293245,           26.59599847,     41.79195237,        61.89905958],
21           [ 0.         ,            5.61452766,     10.93666406,        21.30377267],
22             [    0.        ,        0.        ,        0.           ,    0.           ],
23             [    0.        ,        0.        ,        0.           ,    0.           ]])
     Appendix A: Python in a Nutshell                                                           321

24
25       In [7]:


         Our alternative version makes more use of the vectorization capabilities of NumPy‚Äîthe
     consequence is more compact code even if it is not so easy to read initially.

     #
     # Valuation of European Call Option in CRR1979 Model
     # Vectorized Version (= NumPy-level Iterations)
     # A_pyt/e_CRR1979_vectorized.py
     #
     import numpy as np
     from c_parameters import *


     # Array Initialization for Index Levels
     mu = np.arange(M + 1)
     mu = np.resize(mu, (M + 1, M + 1))
     md = np.transpose(mu)
     mu = u ** (mu - md)
     md = d ** md
     S = S0 * mu * md


     # Valuation by Risk-Neutral Discounting
     pv = np.maximum(S - K, 0)          # present value array initialized with inner values
     z = 0
     for i in xrange(M - 1, -1, -1):         # backwards induction
           pv[0:M - z, i] = (q * pv[0:M - z, i + 1]
                              + (1 - q) * pv[1:M - z + 1, i + 1]) * df
           z += 1


     # Result Output
     print "Value of European call option is %8.3f" % pv[0, 0]



         The valuation result is, as expected, the same for the parameter definitions from before.
     However, three time intervals are of course not enough to come close to the Black-Scholes-
     Merton benchmark of 15.6547. With 1,000 time intervals, however, the algorithms come quite
     close to it:

 1       In [7]: run e_CRR1979_vectorized.py
 2       Value of European call option is          15.654
 3
 4       In [8]:


           The major difference between the two algorithms is execution time. The second imple-
     mentation which avoids Python iterations as much as possible is about 10 times faster than the
     first one (for 1,000 time steps). You should make this a principle for your own coding efforts:
322                                                                   APPENDIX A: PYTHON IN A NUTSHELL


whenever possible avoid necessary iterations (e.g. nested loops) on the Python interpreter
level and delegate them to NumPy where they are executed by optimized C code in general.
Apart from time savings, you generally also get more compact and readable code. A direct
comparison illustrates this point:

#
# Loop Version --- Iterations in Python
#
# Array Initialization for Inner Values
iv = np.zeros((M + 1, M + 1), dtype=np.float)
z = 0
for j in xrange(0, M + 1, 1):
        for i in xrange(z + 1):
             iv[i, j] = max(S[i, j] - K, 0)
        z += 1


#
# Vectorized Version --- Iterations on NumPy Level
#
# Array Initialization for Inner Values
iv = maximum(S - K, 0)



     To conclude this section, the Fast Fourier Transform (FFT) algorithm is applied to the
binomial model. Nowadays, this numerical routine plays an important role in derivatives
analytics. It is used regularly for plain vanilla option pricing in productive environments in
investment banks or hedge funds. In general, however, it is not applied to a binomial model
but the application in this case is straightforward and therefore a quick win.6

#
# Valuation of European Call Option in CRR1979 Model
# FFT Version
# A_pyt/f_CRR1979_fft.py
#
import numpy as np
from numpy.fft import fft, ifft
from c_parameters import *


# Array Generation for Index Levels
md = np.arange(M + 1)
mu = np.resize(md[-1], M + 1)
mu = u ** (mu - md)
md = d ** md
S = S0 * mu * md




6
    Cf. CeÃårnyÃÅ (2004) for details of this method and its application to the binomial model. See also Chapter 6.
Appendix A: Python in a Nutshell                                                          323


# Valuation by FFT
C_T = np.maximum(S - K, 0)
Q = np.zeros(M + 1, 'd')
Q[0] = q
Q[1] = 1 - q
l = np.sqrt(M + 1)
v1 = ifft(C_T) * l
v2 = (np.sqrt(M + 1) * fft(Q) / (l * (1 + r * dt))) ** M
C_0 = fft(v1 * v2) / l


# Result Output
print "Value of European call option is %8.3f" % np.real(C_0[0])



    In this script, Python loops are entirely avoided‚Äîthis is possible since for European
options only the final payoffs are relevant (something one could also make use of for the
previous implementations). The speed advantage of this algorithm is again considerable: it is
100 times faster than the vectorized algorithm from before and 1,000 times faster than the
nested loop-based version (for 1,000 time steps).


A.2.3 Monte Carlo Approach
Finally, we apply Monte Carlo simulation (MCS) to value the same European call option in
the Black-Scholes-Merton model ÓàπBSM . Here it is where pseudo-random numbers come into
play. As with the FFT algorithm we only care about the final index level at T and simulate
it by the use of pseudo-random numbers. We get the simple simulation algorithm shown as
Algorithm 5.7
     Although the algorithm seems to imply something like ‚Äúlooping over arrays‚Äù, we can
again avoid array loops completely on the Python interpreter level. The Python/NumPy
implementation is really compact‚Äîonly five lines of code for the core algorithm. With
another five lines we can produce a histogram of the index levels at T as displayed in
Figure A.3.


#
# Valuation of European Call Option
# via Monte Carlo Simulation
# A_pyt/g_MCS.py
#
import numpy as np
import matplotlib.pyplot as plt
from c_parameters import *


# Valuation via MCS


7
 Glasserman (2004) is a comprehensive reference on the Monte Carlo method applied to financial
problems and models.
    324                                                               APPENDIX A: PYTHON IN A NUTSHELL



    Algorithm 5: Monte Carlo Valuation Algorithm
1   Consider the date of maturity T and, for zT being a standard normally distributed random
    variable, write
                                                   (            )    ‚àö
                                                       r‚àí 12 ùúé 2 ‚ãÖT+ùúé TzT
                                     ST = S0 ‚ãÖ e

  for i = 1, ..., I do
2     Draw a standard normally distributed pseudo-random number zT,i
3     Simulate the index level value ST,i given equation (A.1) and zT,i
4     Determine the inner value of the call at T as max[ST,i ‚àí K, 0]
5   Sum up all inner values at T, take the average and discount back to t = 0 to arrive at the
    Monte Carlo estimator for the option value:

                                                   1‚àë
                              C0 (K, T) ‚âà e‚àírT ‚ãÖ       max[ST (i) ‚àí K, 0]
                                                   I I




            FIGURE A.3    Histogram of simulated stock index levels at T

    I = 100000    # number of simulated values for S_T
    rand = np.random.standard_normal(I) # generate pseudo-random numbers
    ST = S0 * np.exp((r - 0.5 * vola ** 2) * T + np.sqrt(T) * vola * rand)
        # simulate I values for S_T
    pv = np.sum(np.maximum(ST - K, 0) * np.exp(-r * T)) / I                    # MCS estimator

    # Result Output
    print "Value of European call option is %8.3f" % pv
    Appendix A: Python in a Nutshell                                                               325


    # Graphical Output
    plt.figure()
    plt.hist(ST, 100)
    plt.xlabel('index level at T')
    plt.ylabel('frequency')
    plt.grid(True)




         The algorithm produces a quite accurate estimate for the European call option value
    although the implementation is rather simplistic (i.e. there are, for example, no variance
    reduction techniques involved):



1       In [10]: run g_MCS.py
2       Value of European call option is                     15.649
3
4       In [11]:




    A.3 SELECTED FINANCIAL TOPICS

    A.3.1 Approximation
    It is often the case in derivatives analytics that one has to approximate some function or object
    of interest to draw conclusions or apply the approximations within financial algorithms. Two
    important approximation techniques are regression and interpolation.8
          The type of regression we consider is called ordinary least-squares regression (OLS). In its
    most simple form, monomials x, x2 , x3 , ... are used to approximate a desired function y = f (x)
    given a number N of observations (y1 , x1 ), (y2 , x2 ), ..., (yN , xN ). Say we want to approximate
    f (x) with a polynomial of order 2, g(x) = a1 + a2 ‚ãÖ x + a3 ‚ãÖ x2 where the ai are regression
    parameters. The task is then to solve the following minimization problem:


                                                     ‚àë
                                                     N
                                                       (                                )
                                          min              yn ‚àí g(xn ; a1 , a2 , a3 )
                                        a1 ,a2 ,a3
                                                     n=1


         As an example, we want to approximate the cosine function over the interval [0, ùúã‚àï2]
    given 20 observations. The code is straightforward since NumPy has built-in functions polyfit
    and polyval. From polyfit you get the minimizing regression parameters back, while you can
    use them with polyval to generate values based on these parameters. The result is shown in
    Figure A.4 for three different regression functions.


    8
        Brandimarte (2006), sec. 3.3, introduces into these techniques.
326                                                             APPENDIX A: PYTHON IN A NUTSHELL



#
# Ordinary Least Squares Regression
# A_pyt/h_REG.py
#
import numpy as np
import matplotlib.pyplot as plt


# Regression
x = np.linspace(0.0, np.pi / 2, 20)           # x values
y = np.cos(x)     # y values, i.e. those values to regress
g1 = np.polyfit(x, y, 0)        # OLS of degree 1
g2 = np.polyfit(x, y, 1)        # OLS of degree 2
g3 = np.polyfit(x, y, 2)        # OLS of degree 3


g1y = np.polyval(g1, x)        # calculate regressed values for x vector
g2y = np.polyval(g2, x)
g3y = np.polyval(g3, x)


# Graphical Output
plt.figure()    # initialize new figure
plt.plot(x, y, 'r', lw=3, label='cosine')              # plot original function values
plt.plot(x, g1y, 'mx', label='constant')             # plot regression function values
plt.plot(x, g2y, 'bo', label='linear')
plt.plot(x, g3y, 'g>', label='quadratic')
plt.legend(loc=0)
plt.grid(True)




               FIGURE A.4 Approximation of cosine function (line) by constant
               regression (crosses), linear regression (dots) and quadratic regression
               (triangles)
Appendix A: Python in a Nutshell                                                          327




                FIGURE A.5 Approximation of cosine function (line) by cubic
                splines interpolation (red dots)



    The concept of interpolation is much more involved but nevertheless almost as straightfor-
ward in applications. The most common type of interpolation is with cubic splines for which
you find functions in the sub-library scipy.interpolate. The example remains the same and the
code is as compact as before while the result‚Äîsee Figure A.5‚Äîseems perfect.



#
# Cubic Spline Interpolation
# A_pyt/i_SPLINE.py
#
import numpy as np
import scipy.interpolate as sci
import matplotlib.pyplot as plt


# Interpolation
x = np.linspace(0.0, np.pi / 2, 20)        # x values
y = np.cos(x)     # function values to interpolate
gp = sci.splrep(x, y, k=3)         # cubic spline interpolation
gy = sci.splev(x, gp, der=0)         # calculate interpolated values


# Graphical Output
plt.figure()
plt.plot(x, y, 'b', label='cosine')        # plot original function values
plt.plot(x, gy, 'ro', label='cubic splines')
    # plot interpolated function values
plt.legend(loc=0)
plt.grid(True)
328                                                        APPENDIX A: PYTHON IN A NUTSHELL


     Roughly speaking, cubic splines interpolation is (intelligent) regression between every
two observation points with a polynomial of order 3. This is of course much more flexible
than a single regression with a polynomial of, say, order 2. Two drawbacks in algorithmic
terms are, however, that the observations have to be ordered in the x-dimension. Furthermore,
cubic splines are of limited or no use for higher dimensional problems where OLS regression
is applicable as easily as in the two-dimensional world.


A.3.2 Optimization
Strictly speaking, regression and interpolation are two special forms of optimization (some
kind of minimization). However, optimization techniques are needed much more often in
derivatives analytics. An important area is, for example, the calibration of model parameters
to a given set of market-observed option prices or implied volatilities.
     The two major approaches are global and local optimization. While the first looks for a
global minimum or maximum of a function (which does not have to exist at all), the second
looks for a local minimum or maximum. As an example, we take the sine function over
the interval [‚àíùúã, 0] with a minimum function value of ‚àí1 at ‚àíùúã‚àï2. Again, the library scipy
delivers respective functions via the sub-library optimize. The code is as follows:

#
# Finding a Minimum of a Function
# A_pyt/j_OPT.py
#
import numpy as np
import scipy.optimize as sco


# Finding a Minimum



def y(x):
      ''' Function to Minimize. '''
      if x < -np.pi or x > 0:
          return 0.0
      return np.sin(x)


gmin = sco.brute(y, ((-np.pi, 0, 0.01), ), finish=None)           # global optimization
lmin = sco.fmin(y, -0.5)      # local optimization


# Result Output
print "Global Minimum is %8.6f" % gmin
print "Local Minimum is      %8.6f" % lmin



    Both functions brute (global brute force algorithm) and fmin (local convex optimization
algorithm) also work in multi-dimensional settings. In general, the solution of the local opti-
mization is strongly dependent on the initialization; here the ‚àí0.5 did quite well in reaching
‚àíùúã/2 as the solution.
    Appendix A: Python in a Nutshell                                                            329


1       In [5]: run j_OPT.py
2       Optimization terminated successfully.
3                Current function value: -1.000000
4                Iterations: 18
5                Function evaluations: 36
6       Global Minimum is -1.571593
7       Local Minimum is -1.570801
8
9       In [6]:



    A.3.3 Numerical Integration
    It is not always possible to analytically integrate a given function. Then numerical integration
    often comes into play. We want to check numerical integration where we can do it analytically
    as well

                                                           1
                                                               ex dx
                                                      ‚à´0

    The value of the integral is e1 ‚àí e0 ‚âà 1.7182818284590451. For numerical integration, again
    scipy helps out with the sub-library integrate which contains the function quad, implementing
    a numerical quadrature scheme:9


    #
    # Numerically Integrate a Function
    # A_pyt/k_INT.py
    #
    import numpy as np
    from scipy.integrate import quad


    # Numerical Integration



    def f(x):
            ''' Function to Integrate. '''
            return np.exp(x)


    int_value = quad(lambda u: f(u), 0, 1)[0]


    # Output
    print "Value of the integral is %10.9f" % int_value




    9
        Brandimarte (2006), ch. 4, introduces into numerical integration.
    330                                                          APPENDIX A: PYTHON IN A NUTSHELL


          The output of the numerical integration equals the analytical value (with rounding):

1       In [8]: run k_INT.py
2       Value of the integral is 1.718281828
3
4       In [9]:




    A.4 ADVANCED PYTHON TOPICS

    This section briefly illustrates some advanced Python topics, in particular object-oriented
    programming, basic input-output operations and reading data from Excel files.


    A.4.1 Classes and Objects
    So far, we have looked at modules and functions. The dominating coding paradigm of our time
    is, however, object-oriented programming. For example, the popularity of C++ for derivatives
    analytics stems to a great extent from the fact that it brings with it powerful object orientation.
          On a rather basic level, almost anything is an object in Python. What we want to do now
    is to implement new classes of objects, i.e. we go one level higher. For example, we can define
    a new class for European call options. A class is characterized by its attributes which are
    stored in a function with name __init__ and so-called methods, like the valuation function of
    Black-Scholes-Merton as already implemented before. Here is a sample code for two classes:


    #
    # Two Financial Option Classes
    # A_pyt/l_CLASS.py
    #
    #
    import math
    import scipy.stats as scs


    # Class Definitions



    class Option:
          ''' Black-Scholes-Merton European call option class.


          Attributes
          ==========
          S0: float
              initial index level
          K: float
              strike price
          T: float
              time-to-maturity
    Appendix A: Python in a Nutshell                                                   331


         r: float
               constant short rate
         vola: float
               constant volatility factor
         '''


         def __init__(self, S0, K, T, r, vola):
               ''' Initialization of Object. '''
               self.S0 = float(S0)
               self.K = K
               self.T = T
               self.r = r
               self.vola = vola


         def d1(self):
               ''' Helper function. '''
               d1 = ((math.log(self.S0 / self.K) +
                     (self.r + 0.5 * self.vola ** 2) * self.T)
                   / (self.vola * math.sqrt(self.T)))
               return d1


         def value(self):
               ''' Method to value option. '''
               d1 = self.d1()
               d2 = d1 - self.vola * math.sqrt(self.T)
               call_value = (self.S0 * scs.norm.cdf(d1, 0.0, 1.0)
                             - self.K * math.exp(-self.r * self.T)
                             * scs.norm.cdf(d2, 0.0, 1.0))
               return call_value



    class OptionVega(Option):
         ''' Black-Scholes-Merton class for Vega of European call option. '''


         def vega(self):
               ''' Method to calculate the Vega of the European call option. '''
               d1 = self.d1()
               vega = self.S0 * scs.norm.pdf(d1, 0.0, 1.0) * math.sqrt(self.T)
               return vega




        The working becomes clear after executing the module and defining option objects by
    parametrizing the different classes:


1    In [12]: run l_CLASS.py
2
3    In [13]: o1 = Option(105., 100., 1.0, 0.05, 0.25)
     332                                                               APPENDIX A: PYTHON IN A NUTSHELL


 4
 5        In [14]: o1.Value()
 6        Out[14]: 15.654719726823579
 7
 8        In [15]: o1.Vega()
 9        --------------------------------------------------------------------------
10        AttributeError                           Traceback (most recent call last)
11        ./python/A_pyt/<ipython-input-15-dbb35f94473d> in <module>()
12        ----> 1 o1.Vega()
13
14        AttributeError: Option instance has no attribute 'Vega'
15
16        In [16]: o2 = Option_Vega(105., 100., 1.0, 0.05, 0.25)
17
18        In [17]: o2.value()
19        Out[17]: 15.654719726823579
20
21        In [18]: o2.vega()
22        Out[18]: 36.588656569539303
23
24        In [19]:




          The class Option contains a method called Value. The value of the option object o1 can be
     retrieved via invoking the method as in o1.Value(). However, the class Option has no method to
     calculate the vega10 of the option. This, however, is what is included in the class OptionVega.
     This class is defined on the basis of the Option class via class OptionVega(Option) and inherits
     the attributes and methods of the other class. That is why we parametrize an object of this
     class in the same way and why we can calculate its value in the same way.



     A.4.2 Basic Input-Output Operations
     Saving and loading Python modules/scripts is really simple. However, the need to save and load
     Python objects also arises frequently. In this section, we want to illustrate a fundamental way
     of storing objects permanently (via pickling or serialization). The next sub-section illustrates
     how to store data in and retrieve data from spreadsheet files. This is an important functionality
     since Excel is still one of the most popular front-office tools in investment banks, hedge
     funds, etc.
          Suppose we want to save our two option objects o1 and o2 to a file on disk. To this
     end, we can use the cPickle module. A respective session in IPython could look like the
     following:



      The vega of an option is the first derivative of the option value V with respect to the volatility ùúé, i.e.
     10

     ùúïV‚àïùúïùúé.
     Appendix A: Python in a Nutshell                                                             333


 1    In [19]: o1 = Option(105., 100., 1.0, 0.05, 0.25)
 2
 3    In [20]: o2 = OptionVega(105., 100., 1.0, 0.05, 0.25)
 4
 5    In [21]: import cPickle as cp
 6
 7    In [22]: option = open('option_container', 'w')
 8
 9    In [23]: cp.dump(o1, option)
10
11    In [24]: cp.dump(o2, option)
12
13    In [25]: option.close()
14
15    In [26]: option
16    Out[26]: <closed file 'option_container', mode 'w' at 0x1fcd270>
17
18    In [27]: options = open('option_container', 'r')
19
20    In [28]: option1 = cp.load(options)
21
22    In [29]: option2 = cp.load(options)
23
24    In [30]: option1.value()
25    Out[30]: 15.654719726823579
26
27    In [31]: option2.vega()
28    Out[31]: 73.345040765170197
29
30    In [32]: options.close()
31
32    In [33]:



          Notice that the objects are loaded in the sequence as stored (‚Äúfirst in, first out‚Äù). And you
     can never know (if you did not save the information as well) how many objects there are in
     the file. So it could be a good idea to store the two option objects not separately but as a list.


 1    In [33]: options = open('option_container_2', 'w')
 2
 3    In [34]: cp.dump([option1, option2], options)
 4
 5    In [35]: options.close()
 6
 7    In [36]: optionstore = open('option_container_2', 'r')
 8
     334                                                               APPENDIX A: PYTHON IN A NUTSHELL



 9       In [37]: olist = cp.load(optionstore)
10
11       In [38]: olist
12       Out[38]:
13       (<__main__.Option instance at 0x251b710>,
14        <__main__.OptionVega instance at 0x251b6c8>)
15
16       In [39]: len(olist)
17       Out[39]: 2
18
19       In [40]: olist[0]
20       Out[41]: <__main__.Option instance at 0x251b710>
21
22       In [42]: olist[0].value()
23       Out[43]: 15.654719726823579
24
25       In [44]: olist[1].vega()
26       Out[45]: 73.345040765170197
27
28       In [46]:



           This seems to make life a bit more convenient.


     A.4.3 Interacting with Spreadsheets
     The topic of this sub-section is how to read and write data from and to Excel spreadsheets.
     To this end, a sample Excel workbook is needed. We produced one with quite a few DAX
     index quotes (source: http://finance.yahoo.com). The name of the file is DAX_data.xlsx and it
     contains data as displayed in Figure A.6.
          The data analysis library pandas provides a number of convenient I/O tools. Among them
     is an Excel file reader which reads structured data contained in a spreadsheet into a pandas
     DataFrame object.11 To access, print and plot the data contained in the Excel file, a script like
     this does the job:

     #
     # Reading Data from Excel Spreadsheet Files
     # A_pyt/m_Excel_read.py
     #
     import pandas as pd
     import matplotlib.pyplot as plt


     11
        At the time of writing pandas is already a mighty data analysis package (cf. McKinney (2012)). This
     appendix can only give an initial impression of its capabilities. At the end of 2014, the PDF documentation
     of the library stood at more than 1,500 pages (for release 0.15.1). The subsequent section demonstrates
     how the library pandas can make life easier when it comes to handling financial time series and using
     them for valuation purposes.
    Appendix A: Python in a Nutshell                                                         335


    # Open Excel Spreadsheet and Read Date
    DAX = pd.read_excel('A_pyt/DAX_data.xlsx', 'sheet1',
                             index_col=0, parse_dates=True)


    # Print 10 Most Current Daily Data Sets
    print DAX.ix[-10:].to_string()


    # Plot Close Levels for Whole Data Set
    DAX['Close'].plot(label='DAX Index')
    plt.legend(loc=0)



        This module, once started, produces the following output:


1    In [10]: run m_Excel_read.py
2                   Open     High              Low     Close        Volume   Adj Close
3    Date
4    2014-11-17      9162.27     9331.32   9161.60   9306.35    72034400       9306.35
5    2014-11-18      9323.75     9461.53   9323.52   9456.53    73982400       9456.53
6    2014-11-19      9462.05     9521.73   9439.16   9472.80    73153500       9472.80
7    2014-11-20      9460.40     9487.69   9382.23   9483.97    82097800       9483.97
8    2014-11-21      9521.24     9736.14   9508.17   9732.55   166634400       9732.55
9    2014-11-24      9722.31     9832.41   9711.77   9785.54    97612300       9785.54




    FIGURE A.6 Sample spreadsheet in Excel format with DAX quotes (here shown with LibreOffice);
    source: finance.yahoo.com
     336                                                           APPENDIX A: PYTHON IN A NUTSHELL




              FIGURE A.7     Historic DAX index levels; source: http://finance.yahoo.com



10    2014-11-25      9790.03     9921.46    9787.26     9861.21     117773900       9861.21
11    2014-11-26      9894.60     9942.67    9868.35     9915.56      89124300       9915.56
12    2014-11-27      9934.78     9992.67    9920.86     9974.87      84700200       9974.87
13    2014-11-28      9990.70     9990.70    9902.40     9980.85      98906800       9980.85
14
15    In [11]:




           The script also generates a plot as in Figure A.7.



     A.5 RAPID FINANCIAL ENGINEERING

     This section illustrates a whole valuation process implemented in Python and using again the
     powerful library pandas as the main tool. It shows how to address the following tasks that are
     typical for derivatives analytics in particular and financial engineering in general:


        data gathering (here: quotes for the German DAX index)
        data analysis (here: calculating daily log returns)
        generating graphics (here: plotting DAX quotes and log returns)
        implementing numerical methods (here: Monte Carlo simulation)

        data storage (here: DAX quotes with daily log returns)
Appendix A: Python in a Nutshell                                                        337


    The script exhibits a rather concise form‚Äîwhich justifies the term rapid financial engi-
neering:

#
# Retrieving Financial Data from the Web and
# Doing Data Analytics with pandas
# A_pyt/n_pandas.py
#
import math
import numpy as np
import pandas as pd
import pandas.io.data as web
import matplotlib.pyplot as plt


#
# 1. Data Gathering
#
DAX = web.DataReader('ÀÜGDAXI', data_source='yahoo',
                          start='1/1/2005', end='28/11/2014')
      # reads DAX data from Yahoo Finance


#
# 2. Data Analysis
#
DAX['Returns'] = np.log(DAX['Close'] / DAX['Close'].shift(1))
      # daily log returns


#
# 3. Generating Plots
#
plt.figure(figsize=(7, 5))
plt.subplot(211)
DAX['Adj Close'].plot()
plt.title('DAX Index')
plt.subplot(212)
DAX['Returns'].plot()
plt.title('log returns')
plt.tight_layout()


#
# 4. Numerical Methods
#
# Market Parameters
S0 = DAX['Close'][-1]       # start value of DAX for simulation
vol = np.std(DAX['Returns']) * math.sqrt(252)
    # historical, annualized volatility of DAX
r = 0.01    # constant risk-free short rate
     338                                                        APPENDIX A: PYTHON IN A NUTSHELL


     # Option Parameters
     K = 10000.       # strike price of the option to value
     T = 1.0     # time-to-maturity of the option


     # Simulation Parameters
     M = 50     # number of time steps
     dt = T / M       # length of time interval
     I = 10000       # number of paths to simulate
     np.random.seed(5000)      # fixed seed value


     # Simulation
     S = np.zeros((M + 1, I), dtype=np.float)          # array for simulated DAX levels
     S[0] = S0       # initial values
     for t in xrange(1, M + 1):
           ran = np.random.standard_normal(I)       # pseudo-random numbers
           S[t] = S[t - 1] * np.exp((r - vol ** 2 / 2) * dt
                                           + vol * math.sqrt(dt) * ran)
                # difference equation to simulate DAX levels step-by-step
                # NumPy vectorization over all simulated paths


     # Valuation
     V0 = math.exp(-r * T) * np.sum(np.maximum(S[-1] - K, 0)) / I            # MCS estimator
     print "MCS call value estimate is %8.3f" % V0


     #
     # 5. Data Storage
     #
     h5file = pd.HDFStore('DAX_data.h5')        # open HDF5 file as database
     h5file['DAX'] = DAX       # write pandas.DataFrame DAX into HDFStore
     h5file.close()      # close file



           Here is some output from the script and from interacting with objects generated by it:

 1       In [24]: run n_pandas.py
 2       MCS call value estimate is      912.050
 3
 4       In [25]: DAX
 5       Out[25]:
 6       <class 'pandas.core.frame.DataFrame'>
 7       DatetimeIndex: 2535 entries, 2005-01-03 00:00:00 to 2014-11-28 00:00:00
 8       Data columns (total 7 columns):
 9       Open            2535 non-null float64
10       High            2535 non-null float64
11       Low             2535 non-null float64
12       Close           2535 non-null float64
13       Volume          2535 non-null int64
14       Adj Close       2535 non-null float64
     Appendix A: Python in a Nutshell                                                         339

15    Returns           2534 non-null float64
16    dtypes: float64(6), int64(1)
17    memory usage: 158.4 KB
18
19    In [26]: S0
20    Out[26]: 9980.8500000000004
21
22    In [27]: vol
23    Out[27]: 0.22005937913242066
24
25    In [28]: S
26    Out[28]:
27    array([[ 9980.85                  ,    9980.85     ,    9980.85       , ...,
28                 9980.85      ,            9980.85      ,    9980.85      ],
29              [ 10109.14261197,           10120.31053148,    9914.05151453, ...,
30                 9623.88640669,           10528.55645662,   10060.46805893],
31              [   9969.89401753,           9980.25807455,    9689.45433757, ...,
32                  9459.14482363,           9892.4452775 ,   10298.72443737],
33              ...,
34              [ 8634.23391906,             8220.4710566 ,    7563.57734092, ...,
35                11602.42496642,           10136.19939927,   11625.19646252],




     FIGURE A.8 DAX index quotes from 03. January 2005 to 28. November 2014 and daily log returns;
     source: http://finance.yahoo.com
     340                                                        APPENDIX A: PYTHON IN A NUTSHELL


36             [   8721.89783607,      8067.9006704 ,       7344.93794989, ...,
37              11615.52504255,       10339.54117202,      10668.75438809],
38             [ 8922.38372072,        8529.03134822,       7334.99586935, ...,
39              11576.12919096,       10343.39920151,      10297.9093708 ]])
40
41    In [29]:


          As one can see, the pandas DataFrame object DAX has stored 2, 535 different sets of
     daily quotes for the DAX index and 2, 534 daily log returns. The starting index level for the
     simulation is 9, 980.85 while the annualized volatility is calculated as 22.0%. Via simulation,
     the value for a European call option with strike K = 10, 000 and time-to-maturity of T = 1.0
     years is estimated as 913.334. Figure A.8 shows the graphical output of the script.
          This concludes this appendix on the Python programming language for financial analytics.
                                                                        Bibliography


Andersen, Leif (2008) Simple and Efficient Simulation of the Heston Stochastic Volatility Model, Journal
     of Computational Finance, 11(3), 1‚Äì42.
Andersen, Leif, Peter JaÃàckel and Christian Kahl (2010) Simulation of Square-Root Processes, in Ency-
     clopedia of Quantitative Finance, Rama Cont (ed. in chief), John Wiley & Sons, Hoboken, New
     Jersey.
Andersen, Torben and Luca Benzoni (2009) Realized Volatility, in Handbook of Financial Time Series,
     Torben Andersen, Richard Davis, Jens-Peter Krie√ü, Thomas Mikosch (eds), Springer Verlag, Berlin,
     555‚Äì575.
Bakshi, Gurdip, Charles Cao and Zhiwu Chen (1997) Empirical Performance of Alternative Option
     Pricing Models, Journal of Finance, 52(5), 2003‚Äì2049.
Bali, Turan and Liuren Wu (2006) A Comprehensive Analysis of the Short-Term Interest-Rate Dynamics,
     Journal of Banking & Finance, 30, 1269‚Äì1290.
Bates, David (1996) Jumps and Stochastic Volatility: Exchange Rates Processes Implicit in Deutsche
     Mark Options, Review of Financial Studies, 9(1), 69‚Äì107.
Baxter, Martin and Andrew Rennie (1996) Financial Calculus‚ÄîAn Introduction to Derivative Pricing,
     Cambridge University Press, Cambridge.
Bhattacharya, Rabi and Edward Waymire (2007) A Basic Course in Probability Theory, Springer Verlag,
     New York.
Bittman, James (2009) Trading Options as a Professional, McGraw-Hill, New York.
BjoÃàrk, Tomas (2004) Arbitrage Theory in Continuous Time, 2nd ed., Oxford University Press, Oxford.
BjoÃàrk, Tomas (2009) An Overview of Interest Rate Theory, in Handbook of Financial Time Series, Torben
     Andersen, Richard Davis, Jens-Peter Krie√ü, Thomas Mikosch (eds), Springer Verlag, Berlin, 615‚Äì
     651.
Black, Fischer and Myron Scholes (1973) The Pricing of Options and Corporate Liabilities, Journal of
     Political Economy, 81(3), 638‚Äì659.
Boyle, Phelim (1977) Options: A Monte Carlo Approach, Journal of Financial Economics, 4(4), 322‚Äì
     338.
Brandimarte, Paolo (2006) Numerical Methods in Finance and Economics, 2nd ed., John Wiley & Sons,
     Hoboken, New Jersey.
Brigo, Damiano and Fabio Mercurio (2001) On Deterministic-Shift Extensions of Short-Rate Models,
     Working Paper, Banca IMI, Milano, www.damianobrigo.it.
Brigo, Damiano and Fabio Mercurio (2006) Interest Rate Models‚ÄîTheory and Practice, 2nd ed., Springer
     Verlag, Berlin.
Broadie, Mark and OÃàzguÃàr Kaya (2006) Exact Simulation of Stochastic Volatility and Other Affine Jump
     Diffusion Processes, Operations Research, 54(2), 217‚Äì231.
Carr, Peter and Dilip Madan (1999) Option Valuation using the Fast Fourier Transform, Journal of
     Computational Finance, 2(4), 61‚Äì73.
CeÃårnyÃÅ, AlesÃå (2004) Introduction to Fast Fourier Transform in Finance, Journal of Derivatives, 12(1),
     73‚Äì88.



                                                                                                   341
342                                                                                    BIBLIOGRAPHY


Cetin, Umut, Robert Jarrow and Philip Protter (2004) Liquidity Risk and Arbitrage Pricing Theory,
     Finance and Stochastics, 8(3), 1‚Äì31.
Chaudhury, Mo (2014) Option Bid-Ask Spread and Liquidity, Working Paper, McGill University, Desau-
     tels Faculty of Management, www.ssrn.com.
Cheng, Peng and Olivier Scaillet (2007) Linear-Quadratic Jump-Diffusion Modeling, Mathematical
     Finance, 17(4), 575‚Äì598.
Cherubini, Umberto, Giovanni Della Lunga, Sabrina Mulinacci and Pietro Rossi (2009) Fourier Trans-
     form Methods in Finance, John Wiley & Sons, Chichester.
Christoffersen, Peter and Kris Jacobs (2004) The Importance of the Loss Function in Option Valuation,
     Journal of Financial Economics, 72, 291‚Äì318.
Cipra, Barry (2000) The Best of the 20th Century: Editors Name Top 10 Algorithms, SIAM News, 33(4),
     1‚Äì2.
CleÃÅment, Emmanuelle, Damien Lamberton and Philip Protter (2002) An Analysis of a Least
     Squares Regression Algorithm for American Option Pricing, Finance and Stochastics, 17,
     448‚Äì471.
Cont, Rama (2001) Empirical Properties of Asset Returns: Stylized Facts and Statistical Issues, Quanti-
     tative Finance, 1, 223‚Äì236.
Cont, Rama and Peter Tankov (2004a) Financial Modelling With Jump Processes, 2nd ed., CRC Press
     UK, London.
Cont, Rama and Peter Tankov (2004b) Non-Parametric Calibration of Jump-Diffusion Option Pricing
     Models, Journal of Computational Finance, 7(3), 1‚Äì49.
Cont, Rama, Peter Tankov and Ekaterina Voltchkova (2007) Hedging with Options in Models with Jumps,
     in Stochastic Analysis and Applications‚Äîthe Abel Symposium 2005, Springer Verlag, Berlin.
Cooley, James and John Tukey (1965) An Algorithm for the Machine Calculation of Complex Fourier
     Series, Mathematics of Computation, 19(90), 297‚Äì301.
Cox, John, Jonathan Ingersoll and Stephen Ross (1985) A Theory of the Term Structure of Interest Rates,
     Econometrica, 53(2), 385‚Äì407.
Cox, John, Stephen Ross and Mark Rubinstein (1979) Option Pricing: A Simplified Approach, Journal
     of Financial Economics, 7(3), 229‚Äì263.
CreÃÅpey, SteÃÅphane (2009) Tikhonov Regularization, in Encyclopedia of Quantitative Finance, Rama Cont
     (ed. in chief), John Wiley & Sons, Hoboken, 1807‚Äì1811.
Dai, Qiang and Kenneth Singleton (2000) Specification Analysis of Affine Term Structure Models,
     Journal of Finance, 55(5), 1943‚Äì1978.
Delbaen, Freddy and Walter Schachermayer (1994) A General Version of the Fundamental Theorem of
     Asset Pricing, Mathematische Annalen, 300, 463‚Äì520.
Delbaen, Freddy and Walter Schachermayer (1998) The Fundamental Theorem of Asset Pricing for
     Unbounded Stochastic Processes, Mathematische Annalen, 312, 215‚Äì250.
Delbaen, Freddy and Walter Schachermayer (2004) The Mathematics of Arbitrage, Springer Verlag,
     Berlin.
Detemple, Jerome (2006) American-Style Derivatives‚ÄîValuation and Computation, Chapman & Hal-
     l/CRC, Boca Raton.
Detlefsen, Kai (2005) Hedging Exotic Options in Stochastic Volatility and Jump Diffusion Models,
     Master‚Äôs Thesis, Humboldt-University Berlin, Berlin.
de Weert, Frans (2008) Exotic Options Trading, John Wiley & Sons, Chichester.
Duffie, Darrell, Jun Pan and Kenneth Singleton (2000) Transform Analysis and Asset Pricing for Affine
     Jump-Diffusions, Econometrica, 68(6), 1343‚Äì1376.
Duffie, Darrell and Kenneth Singleton (2003) Credit Risk‚ÄîPricing, Measurement and Management,
     Princeton University Press, Princeton, New Jersey.
Elliot, Robert and Ekkehard Kopp (2005) Mathematics of Financial Markets, 2nd ed., Springer Verlag,
     New York.
Bibliography                                                                                     343


Fengler, Matthias (2005) Semi-Parametric Modeling of Implied Volatility, Springer Verlag, Berlin.
FilipovicÃÅ, Damir (2009) Term Structure Models‚ÄîA Graduate Course, Springer Verlag, Dordrecht.
Fletcher, Shayner and Christopher Gardener (2009) Financial Modelling in Python, John Wiley & Sons,
     Chichester.
Frey, RuÃàdiger (2000) Market Illiquidity as a Source of Model Risk in Dynamic Hedging, in Model Risk:
     Concepts, Calibration and Pricing, Rajna Gibson (ed.), Risk Publications, London, 125‚Äì136.
Fries, Christian (2008) Foresight Bias and Suboptimality Correction in Monte Carlo Pricing of Options
     with Early Exercise, Mathematics in Industry, 12, 645‚Äì649.
Galluccio, Stefano and Yann Le Cam (2008) Implied Calibration and Moments Asymptotics in Stochastic
     Volatility Jump Diffusion Models, Working Paper, BNP Paribas, London, www.ssrn.com.
Gatheral, Jim (2006) The Volatility Surface‚ÄîA Practitioner‚Äôs Guide, John Wiley & Sons, Hoboken, New
     Jersey.
Gilbert, Charles, K. Ravindran and Robert Reitano (2007) Results of the Survey on Variable Annuity
     Hedging Programs for Life Insurance Companies, Report, Society of Actuaries, www.soa.org.
Glasserman, Paul (2004) Monte Carlo Methods in Financial Engineering, Springer Verlag, New York.
Grzelak, Lech, Cornelis Oosterlee and Sacha van Weeren (2012) Extension of Stochastic Volatility
     Equity Models with Hull-White Interest Rate Process, Quantitative Finance, 12(1), 89‚Äì105.
Haastrecht, Alexander and Antoon Pelsser (2010) Efficient, Almost Exact Simulation of the Heston
     Stochastic Volatility Model, International Journal of Theoretical and Applied Finance, 13(1),
     1‚Äì43.
Haenel, Valentin, Emmanuelle Gouillart and GaeÃàl Varoquaux (2013) Python Scientific Lecture Notes,
     http://scipy-lectures.github.com.
Hansen, Lars and Eric Renault (2009) Pricing Kernels and Stochastic Discount Factors, in Encyclopedia
     of Quantitative Finance, Rama Cont (ed. in chief), John Wiley & Sons, Hoboken, 1418‚Äì1427.
Harrison, Michael and David Kreps (1979) Martingales and Arbitrage in Multiperiod Securities Markets,
     Journal of Economic Theory, 20, 381‚Äì408.
Harrison, Michael and Stanley Pliska (1981) Martingales and Stochastic Integrals in the Theory of
     Continuous Trading, Stochastic Processes and their Applications, 11, 215‚Äì260.
Haugh, Martin and Leonid Kogan (2004) Pricing American Options: A Duality Approach, Operations
     Research, 52(2), 258‚Äì270.
Heath, David, Robert Jarrow and Andrew Morton (1992) Bond Pricing and the Term Structure of Interest
     Rates: A New Methodology for Contingent Claims Valuation, Econometrica, 60(1), 77‚Äì105.
Heston, Steven (1993) A Closed-Form Solution for Options with Stochastic Volatility with Applications
     to Bond and Currency Options, The Review of Financial Studies, 6(2), 327‚Äì343.
Hilpisch, Yves (2001) Dynamic Hedging, Positive Feedback, and General Equilibrium, Dissertation
     Thesis, Saarland University, Saarbruecken, www.hilpisch.com.
Hilpisch, Yves (2014) Python for Finance‚ÄîAnalyze Big Financial Data, O‚ÄôReilly, Beijing.
Hull, John and Alan White (2013) LIBOR vs. OIS: The Derivatives Discounting Dilemma, Journal of
     Investment Management, 11(3), 14‚Äì27.
Jarrow, Robert (1999) In Honor of the Nobel Laureates Robert C. Merton and Myron S. Scholes: A
     Partial Differential Equation that Changed the World, Journal of Economic Perspectives, 13(4),
     229‚Äì248.
Jarrow, Robert (2005) Liquidity Risk and Classical Option Pricing Theory, in Mathematical Modeling
     of Market Liquidity Risk, P. Neu and L. Matz (eds), John Wiley & Sons, Singapore.
Kahale, Nabil (2004) An Arbitrage-Free Interpolation of Volatilities, Risk Magazine, 17(May), 102‚Äì106.
Kahl, Christian (2007) Modelling and Simulation of Stochastic Volatility in Finance, Dissertation.com,
     Boca Raton.
KloÃàssner, Stefan (2010) Grasping Economic Jumps by Sparse Sampling Using Intradaily Highs
     and Lows, Working Paper, Saarland University, Saarbruecken, http://econ.duke.edu/brossi/
     NBERNSF/Klossner.pdf.
344                                                                                      BIBLIOGRAPHY


Kohler, Michael (2009) A Review on Regression-based Monte Carlo Methods for Pricing Ameri-
     can Options, Working Paper, Technical University of Darmstadt, Darmstadt, www.mathematik
     .tu-darmstadt.de.
Lamberton, Damien and Bernard Lapeyre (1996) Introduction to Stochastic Calculus Applied to Finance,
     Chapman & Hall, London.
Langtangen, Hans Petter (2009) A Primer on Scientific Programming with Python, Springer Verlag,
     Berlin.
Lee, Eileen (2010) Python takes a Bite, WILMOTT Magazine, March.
Lewis, Alan (2001) A Simple Option Formula for General Jump-Diffusion and Other Exponential LeÃÅvy
     Processes, Working Paper, OptionCity, www.optioncity.net.
Liberti, Leo (2008) Introduction to Global Optimization, Working Paper, EÃÅcole Polytechnique, Palaiseau,
     www.lix.polytechnique.fr.
London, Justin (2005) Modeling Derivatives in C++, John Wiley & Sons, Hoboken, New Jersey.
Longstaff, Francis and Eduardo Schwartz (2001) Valuing American Options by Simulation: A Simple
     Least Squares Approach, Review of Financial Studies, 14(1), 113‚Äì147.
Lord, Roger, Remmert Koekkoek and Dick van Dijk (2006) A Comparison of Biased Simulation Schemes
     for Stochastic Volatility Models, Working Paper, Erasmus University, Rotterdam, www.ssrn.com.
McKinney, Wes (2012) Python for Data Analysis, O‚ÄôReilly, Beijing.
Medvedev, Alexey and Olivier Scaillet (2010) Pricing American Options Under Stochastic Volatility and
     Stochastic Interest Rates, Journal of Financial Economics, 98, 145‚Äì159.
Merton, Robert (1973) Theory of Rational Option Pricing, Bell Journal of Economics and Management
     Science, 4, 141‚Äì183.
Merton, Robert (1976) Option Pricing when the Underlying Stock Returns are Discontinuous, Journal
     of Financial Economics, 3(3), 125‚Äì144.
Mikhailov, Sergei and Ulrich NoÃàgel (2003) Heston‚Äôs Stochastic Volatility Model‚ÄîImplementation,
     Calibration and Some Extensions, WILMOTT Magazine, July, 74‚Äì79.
Moodley, Nimalin (2005) The Heston Model: A Practical Approach‚ÄîWith Matlab Code, Bachelor‚Äôs
     Thesis, University of the Witwatersrand, Johannesburg, math.nyu.edu.
Nandi, Saikat and Daniel Waggoner (2000) Issues in Hedging Options Positions, Economic Review, 1st
     Qu., Federal Reserve Bank of Atlanta.
Pliska, Stanley (1997) Introduction to Mathematical Finance, Blackwell Publishers, Malden and Oxford.
Protter, Philip (2001) A Partial Introduction to Financial Asset Pricing Theory, Stochastic Processes and
     their Applications, 91, 169‚Äì203.
Protter, Philip (2005) Stochastic Integration and Differenatial Equations, 2nd ed., 3rd printing, Springer
     Verlag, Berlin.
Rebonato, Riccardo (2004) Volatility and Correlation, 2nd ed., John Wiley & Sons, Chichester.
Reinsberg, Rene (2006) Pricing Options on the DAX‚ÄîAn Empirical Investigation, Thesis, WHU‚ÄìOtto
     Beisheim School of Management, Vallendar, www.ssrn.com.
Rudin, Walter (1970) Real and Complex Analysis, International Student Edition, McGraw-Hill, London.
Schmelzele, Martin (2010) Option Pricing Formulae using Fourier Transform: Theory and Application,
     Working Paper, www.pfadintegral.com.
Schoutens, Wim, Erwin Simons and Jurgen Tistaert (2004) A Perfect Calibration! Now What?, WILLMOT
     Magazine, March, 66‚Äì78.
Stentoft, Lars (2004) Least Squares Monte-Carlo and GARCH Methods for American
     Options: Theory and Applications, Dissertation Thesis, University of Aarhus, Denmark,
     www.samfundsvidenskab.au.dk.
Svoboda, Simona (2002) An Investigation of Various Interest Rate Models and Their Calibration in
     the South African Market, Dissertation Thesis, University of the Witwatersrand, Johannesburg,
     http://janroman.dhis.org.
Bibliography                                                                                   345


Tankov, Peter and Ekaterina Voltchkova (2009) Jump-Diffusion Models: A Practitioner‚Äôs Guide, BanqueÃÅ
     et MarcheÃÅs, 99, March‚ÄìApril.
Tsitsiklis, John and Benjamin Van Roy (2001) Regression Methods for Pricing Complex American-Style
     Options, IEEE Transactions on Neural Networks, 12, 694‚Äì730.
Wallner, Christian and Uwe Wystup (2004) Efficient Computation of Option Price Sensitivities for
     Options of American Style, WILMOTT Magazine, November, 2‚Äì11.
Wang, Yang and Russel Calfisch (2010) Pricing and Hedging American-Style Options: A Simple
     Simulation-based Approach, Journal of Computational Finance, 13(4), 95‚Äì125.
Williams, David (1991) Probability with Martingales, reprint 2001, Cambridge University Press,
     Cambridge.
Wilmott, Paul, Sam Howison and Jeff Dewynne (1995) The Mathematics of Financial Derivatives,
     Cambridge University Press, Cambridge.
                                                                                                Index


3D plotting, the Greeks 92                               arbitrage-free factors (NA) 1‚Äì2, 49, 57‚Äì61, 64‚Äì6, 68‚Äì9,
                                                               73‚Äì81, 128‚Äì30, 173‚Äì4, 224‚Äì6
Absorption, Euler schemes 193‚Äì6, 210‚Äì22                  array, concepts 118‚Äì26, 142‚Äì4, 164‚Äì8, 212‚Äì22, 245‚Äì61,
accounting issues 16                                           272‚Äì8, 290‚Äì302, 310‚Äì14, 320‚Äì4
adaptation to filtrations 52‚Äì66                          array operations 4, 39‚Äì40, 82‚Äì94, 118‚Äì26, 141‚Äì4,
admissible trading strategies 56‚Äì61, 63‚Äì6, 69                  164‚Äì8, 187‚Äì222, 245‚Äì61, 272‚Äì8, 290‚Äì302, 305‚Äì6,
advanced topics, Python 330‚Äì6                                  310‚Äì14, 315‚Äì16, 319‚Äì24
algebras 50‚Äì69, 72‚Äì94, 128, 138‚Äì44, 169‚Äì72, 178‚Äì80          concepts 4, 82, 93‚Äì4, 124‚Äì6, 187, 212‚Äì22, 245‚Äì61,
   concepts 50‚Äì66, 72‚Äì3, 169‚Äì72                                305‚Äì6, 310‚Äì13, 315‚Äì16, 319‚Äì24
   definition 50‚Äì1, 52‚Äì3                                    indices 311‚Äì13
   generation 52‚Äì3                                       Arrow-Debreu securities 60‚Äì1
American option pricing 2‚Äì3, 9‚Äì13, 66, 71, 84, 127‚Äì44,   Asian options 13‚Äì14, 176‚Äì7
      176‚Äì7, 187, 196‚Äì203, 215‚Äì22, 263, 268‚Äì78,          at-the-money options (ATM) 10, 31‚Äì3, 78‚Äì81, 149,
      279‚Äì302, 303                                             228‚Äì30
   conclusions 136, 203, 269, 303                        attainable contingent claims 57‚Äì61, 128‚Äì30
   continuation values 130‚Äì2, 136‚Äì44                     attributes, classes 330‚Äì6
   dual formulations 129‚Äì36, 140‚Äì4                       autocorrelation 30
   dynamic delta hedging 280‚Äì302, 303
   financial model 128                                   B96 model see Bates stochastic volatility jump model‚Ä¶
   MCS 127‚Äì44, 187, 196‚Äì203, 215‚Äì22, 263, 268‚Äì78,        Bachelier model, definition 63
      279‚Äì302                                            backwards induction 127, 138‚Äì44, 321‚Äì4
   numerical results 132‚Äì6                               Bakshi-Cao-Chen general market model (BCC97
   primal formulations 129‚Äì36, 139‚Äì44                         model) 2, 107, 108, 169‚Äì85, 192‚Äì6, 203, 223‚Äì8,
   problem formulations 128‚Äì30                                229‚Äì30, 233‚Äì43, 244, 248‚Äì61, 263‚Äì78, 280,
   put options 132‚Äì6, 137‚Äì44, 196‚Äì203, 215‚Äì22,                285‚Äì9, 295‚Äì302, 303
      268‚Äì78, 280‚Äì302                                      calibration 233‚Äì43, 244, 248‚Äì61, 263‚Äì78
   Python fundamentals 127, 129, 131, 133‚Äì4, 136‚Äì44,       definition 169‚Äì74, 224‚Äì5
      199‚Äì200, 215‚Äì22, 268‚Äì78, 280‚Äì8, 289‚Äì302              dynamic delta hedging study 280, 285‚Äì9, 295‚Äì302
   valuation algorithms 130‚Äì2, 196‚Äì203, 215‚Äì22             features of the framework 170‚Äì2
American short condor spreads 135‚Äì6, 137‚Äì44                MCS 263‚Äì78, 285‚Äì9
Anaconda 306‚Äì7                                             problems 239‚Äì40, 280
appendix 3, 305‚Äì40                                         Python fundamentals 180‚Äì5, 239‚Äì40, 248‚Äì61, 264‚Äì6,
approximations                                                269‚Äì78, 286‚Äì8, 295‚Äì302
   see also interpolations; regression‚Ä¶                  Bank of America 4
   concepts 96, 105‚Äì6, 119‚Äì20, 127‚Äì44, 224‚Äì6,            bar charts, concepts 255‚Äì61, 314‚Äì16
      280‚Äì302, 325‚Äì8                                     bar plots, concepts 315‚Äì16
   Python fundamentals 105, 119‚Äì20, 140‚Äì4, 280‚Äì5,        barrier options 13‚Äì14
      292‚Äì302, 325‚Äì8                                     baskets 176‚Äì7
arange 38‚Äì45, 93‚Äì4, 117‚Äì26, 138‚Äì44, 293‚Äì302,             Bates stochastic volatility jump model (B96 model) 63,
      312‚Äì13                                                  169‚Äì72, 181‚Äì5, 226‚Äì7, 272‚Äì8
arbitrage opportunities 58‚Äì61, 63‚Äì9                      BCC97 see Bakshi-Cao-Chen general market model‚Ä¶
arbitrage pricing theory 2, 5, 15, 16‚Äì17, 49‚Äì69, 71,     Bermudan options 84, 127, 176‚Äì7
      96‚Äì7, 128‚Äì30, 173‚Äì4                                bid/ask spreads 17, 30‚Äì3, 137, 194‚Äì6, 228‚Äì30



                                                                                                           347
348                                                                                                       INDEX


binomial option pricing models 2, 71, 81‚Äì5, 92‚Äì4, 96,          see also option‚Ä¶
     110‚Äì13, 122‚Äì6, 129, 133‚Äì44, 318‚Äì24                        put-call parity 74‚Äì81, 95‚Äì6
  see also Cox-Ross-Rubinstein‚Ä¶                                Python fundamentals 9‚Äì17, 114‚Äì26, 148, 155‚Äì68,
  concepts 2, 71, 81‚Äì5, 92‚Äì4, 96, 110‚Äì13, 122, 129,               180‚Äì5, 209‚Äì22, 268‚Äì78, 289‚Äì302, 316‚Äì25,
     133‚Äì44, 318‚Äì24                                               330‚Äì2
  Python fundamentals 81, 82, 92‚Äì4, 122, 124‚Äì5, 129,        Carr-Madan model (CM99) 2, 95‚Äì6, 101‚Äì3, 105‚Äì9,
     133‚Äì4, 137‚Äì9, 318‚Äì24                                         152‚Äì5, 158‚Äì68, 175‚Äì85, 253‚Äì61
Black-Scholes-Merton option pricing model (BSM) 2,          characteristic function 98‚Äì101, 107‚Äì26, 148, 157‚Äì68,
     5, 11‚Äì13, 19‚Äì30, 31‚Äì3, 41‚Äì5, 71‚Äì94, 95, 107‚Äì9,               175‚Äì85, 236
     114‚Äì19, 127‚Äì30, 155, 169, 171‚Äì85, 223, 224‚Äì6,          Cherubini et al. 239
     228‚Äì30, 279‚Äì302, 316‚Äì17, 321, 323‚Äì5, 330‚Äì2             chi-squared random variables 188‚Äì91, 192‚Äì6, 207‚Äì22
  see also implied volatilities                             Cholesky decomposition 210‚Äì22, 270‚Äì8, 297‚Äì302
  conclusions 84, 280                                       Christoffersen and Jacobs 227‚Äì8
  definition 71‚Äì5, 107‚Äì9, 128, 223                          CIR85 see Cox-Ingersoll-Ross interest-rate model
  dynamic delta hedging study 280‚Äì5, 289‚Äì95                 classes, object-oriented programming concepts 330‚Äì2
  popularity 73‚Äì5, 84                                       closed-form solutions 71‚Äì94, 96‚Äì7, 114
  Python fundamentals 11‚Äì13, 21‚Äì5, 32‚Äì3, 41‚Äì5, 75,             see also Black-Scholes-Merton‚Ä¶
     78, 85‚Äì92, 94, 107, 114‚Äì19, 280‚Äì5, 289‚Äì95,             clustering 2, 26‚Äì30, 36, 171‚Äì85
     316‚Äì17, 321, 323‚Äì5, 330‚Äì2                                 definition 26
bonds 14, 33‚Äì6, 55‚Äì61, 71‚Äì94, 96‚Äì7, 128‚Äì30, 169‚Äì85,         CM99 see Carr-Madan model
     187‚Äì91, 226‚Äì7, 228‚Äì30, 279‚Äì80, 281‚Äì5, 292‚Äì302,         coding guidelines, loops 322
     318‚Äì24                                                 commodities 33
boundary conditions 74‚Äì81                                   compiled languages, interpreted languages 4
Boyle, Phelim 187                                           complete market models 2, 16‚Äì17, 33‚Äì6, 57‚Äì61, 66‚Äì9,
Brownian motion 5, 19, 21‚Äì5, 37‚Äì40, 62‚Äì6, 72‚Äì81,                  71‚Äì94, 128‚Äì30, 224‚Äì6, 303
     108‚Äì9, 128, 147‚Äì68, 170‚Äì85, 192‚Äì6                         see also Black-Scholes-Merton‚Ä¶;
  see also Black-Scholes-Merton‚Ä¶; geometric‚Ä¶                      Cox-Ross-Rubinstein‚Ä¶
  concepts 62‚Äì6, 72‚Äì81, 108‚Äì9, 128, 147‚Äì68, 170‚Äì2,             conclusions 84, 225‚Äì6, 303
     192‚Äì6                                                     definition 60‚Äì1, 66, 71‚Äì84, 224‚Äì6
  definition 62‚Äì3                                           complex numbers 120‚Äì1
brute, concepts 162‚Äì8, 254‚Äì61, 328‚Äì9                        conditional expectations, concepts 53‚Äì61
BSM see Black-Scholes-Merton option pricing model           contingent claims 57‚Äì61, 65‚Äì9, 71‚Äì94, 128‚Äì44
buy-side parties, definition 13                             continuation values, American option pricing 130‚Äì2,
                                                                  136‚Äì44
C 3, 4, 5, 305, 310‚Äì13, 319, 322, 330                       continuous time 2, 5, 16‚Äì17, 49‚Äì54, 61‚Äì9, 71‚Äì81,
caÃÄdlaÃÄgs 62‚Äì4                                                    84‚Äì94, 96‚Äì126, 128, 147‚Äì68, 169‚Äì85, 232‚Äì3
calibration 1‚Äì5, 14, 17, 60, 95‚Äì6, 107‚Äì9, 147, 149‚Äì68,      continuous-time market models 61‚Äì6, 71‚Äì81, 84‚Äì94,
       169, 171‚Äì2, 173‚Äì85, 223‚Äì61, 263‚Äì78, 279‚Äì302,               96‚Äì126, 128, 147‚Äì68, 169‚Äì85
       303, 328‚Äì9                                              see also Black-Scholes-Merton‚Ä¶; jump-diffusion‚Ä¶
   see also implied volatilities; market-based valuations      concepts 61‚Äì6, 71‚Äì81, 84‚Äì94, 96‚Äì7, 147‚Äì9
   conclusions 243, 268‚Äì9, 303                                 definition 65‚Äì6
   definition 1‚Äì2, 14, 223‚Äì30                               Continuum Analytics 306
   equity component 229, 233‚Äì43                             convolution 111‚Äì13, 121‚Äì2, 123‚Äì6
   general considerations 223‚Äì30                            correlation risks, definition 14‚Äì15
   jump-diffusion models 237‚Äì43, 252‚Äì61, 263‚Äì78             correlations 14‚Äì15, 19, 21, 24‚Äì5, 29‚Äì30, 40, 171‚Äì85,
   objective functions 227‚Äì30, 256‚Äì61                             192‚Äì6, 219‚Äì22, 226‚Äì7, 249‚Äì61, 270‚Äì8
   optimization algorithms 162‚Äì8, 229‚Äì30, 239‚Äì43,              definition 21
       254‚Äì61, 328‚Äì9                                           stylized facts 19, 21, 24‚Äì5, 29‚Äì30, 172
   problems 237‚Äì43                                          cosine 325‚Äì8
   Python fundamentals 149, 160‚Äì8, 232, 236‚Äì7,              coupons 231‚Äì3
       239‚Äì42, 243‚Äì61, 269‚Äì78, 286‚Äì8                        covariance 213‚Äì14, 270‚Äì8
   reasons 224‚Äì6                                            Cox-Ingersoll-Ross interest-rate model (CIR85) 3,
   short-rate component 229‚Äì33                                    170‚Äì3, 176‚Äì85, 187‚Äì222, 223, 226‚Äì7, 230‚Äì48,
call options 9‚Äì17, 30‚Äì45, 72‚Äì94, 95‚Äì126, 128‚Äì44,                  253‚Äì4, 264‚Äì5, 271‚Äì8, 300‚Äì2
       148‚Äì68, 171‚Äì85, 192‚Äì222, 223‚Äì61, 263‚Äì78,                calibration 230‚Äì48, 264‚Äì5, 271‚Äì8
       279‚Äì302, 316‚Äì25, 330‚Äì2                                  Python fundamentals 243‚Äì8, 253‚Äì4, 271‚Äì8
Index                                                                                                     349


Cox-Ross-Rubinstein binomial option pricing model        dividends 17, 72‚Äì3, 107, 223, 316
     (CRR) 2, 71, 81‚Äì94, 96, 110‚Äì13, 129, 137‚Äì9,         division, Python 307‚Äì10
     318‚Äì24                                              dot plots, concepts 194‚Äì6, 299‚Äì302, 314‚Äì16
  benefits 71, 84                                        Dow Jones Industrial Average (DJIA) 31‚Äì3
  concepts 2, 71, 81‚Äì5, 92‚Äì4, 96, 110‚Äì13, 129, 137‚Äì9,    drift 72, 147‚Äì8, 170‚Äì85, 194‚Äì6
     318‚Äì24                                              dual formulations, American option pricing 129‚Äì36,
  conclusions 84                                               140‚Äì4
  definition 71, 81‚Äì4                                    dynamic code compiling 4
  Python fundamentals 81, 82, 92‚Äì4, 129, 137‚Äì9,          dynamic delta hedging 3, 14‚Äì15, 16‚Äì17, 279‚Äì302,
     318‚Äì24                                                    303
CRR1979 319‚Äì24                                              BCC97 study 280, 285‚Äì9, 295‚Äì302
cubic splines interpolation 232‚Äì3, 245‚Äì8, 327‚Äì8             BSM study 280‚Äì5, 289‚Äì302
cumsum 38‚Äì45, 314‚Äì16                                        conclusions 287‚Äì9, 303
cumulative distribution function (CDF) 42‚Äì5, 109, 148,      definition 16, 279‚Äì80
     316‚Äì17                                                 Python fundamentals 280‚Äì8, 289‚Äì302

data analytics, rapid financial engineering 26‚Äì7, 41,    economic risks 16‚Äì17
     193, 303, 336‚Äì40                                    editor 309‚Äì10
databases 26‚Äì7, 228‚Äì30, 245‚Äì52, 253‚Äì4, 306, 334‚Äì40       efficient markets 13‚Äì14, 223, 303
DataFrame 140‚Äì4, 168, 194‚Äì6, 213‚Äì22, 334‚Äì6               empirical facts 1‚Äì2, 19‚Äì45, 169‚Äì85, 227‚Äì61
DAX 19‚Äì45, 334‚Äì40                                        Eonia rate 229, 231‚Äì3, 245‚Äì53
decomposable processes, definition 62                    equity component, calibration 229, 233‚Äì43
default risks, definition 15                             equity index options see index options
degeneracy calibration problems 237‚Äì43                   equivalent martingale measures (EMMs) 49‚Äì69, 96‚Äì7
Delbaen and Schachermayer proof 64‚Äì5                     Euler formulas 103‚Äì7, 128, 166‚Äì7, 189‚Äì96, 199‚Äì203,
delta 3, 71‚Äì81, 88‚Äì92, 106, 156‚Äì7, 159‚Äì68, 181‚Äì5,              207‚Äì22, 268
     254‚Äì61, 269‚Äì78, 279‚Äì302, 303                        Eurex 149, 161‚Äì8, 229‚Äì30, 253
   see also dynamic‚Ä¶; gamma                              Euribor 34‚Äì6, 45, 223, 229‚Äì30, 231‚Äì4, 243‚Äì8
   definition 73‚Äì4, 76‚Äì8, 88‚Äì92, 279‚Äì85                     definition 34
   Python fundamentals 88‚Äì92, 156‚Äì7, 159‚Äì68, 181‚Äì2,         Python scripts 45, 243‚Äì8
     254‚Äì61, 269‚Äì78, 280‚Äì5, 289‚Äì302                      EURO STOXX 50 stock index 19‚Äì45, 149‚Äì68, 223,
‚Äòdelta neutral‚Äô positions 79‚Äì80                                228‚Äì30, 236‚Äì43, 244, 248‚Äì61, 265, 274, 286‚Äì9
derivatives 1‚Äì5, 9‚Äì17, 19‚Äì45, 305‚Äì6, 313‚Äì14, 322‚Äì4,         Python implied volatility scripts 43‚Äì5, 259‚Äì61
     328, 336‚Äì40                                         European option pricing 1‚Äì5, 9‚Äì13, 19‚Äì45, 49‚Äì69,
   see also futures; option‚Ä¶; swaps                            71‚Äì94, 95‚Äì126, 129, 147‚Äì68, 169‚Äì85, 187, 192‚Äì6,
DFT see discrete Fourier transforms                            203, 209‚Äì15, 223‚Äì61, 263‚Äì78, 303, 316‚Äì25,
diffusion processes 2, 20, 26, 30, 63‚Äì6, 84, 96, 107,          328‚Äì34, 338‚Äì40
     108‚Äì9, 114‚Äì26, 169‚Äì85, 187‚Äì96, 203, 206‚Äì22             see also options‚Ä¶
   see also Brownian motion                                 MCS 187, 192‚Äì6, 203, 209‚Äì15, 263‚Äì78
discounting 14‚Äì15, 33‚Äì6, 38‚Äì40, 49‚Äì69, 82‚Äì94, 96‚Äì7,         Python fundamentals 41‚Äì5, 75, 85‚Äì94, 105, 107,
     122, 138‚Äì44, 152‚Äì68, 173‚Äì85, 189‚Äì91, 194‚Äì6,               112‚Äì13, 114‚Äì26, 148, 151, 155‚Äì68, 173, 177‚Äì85,
     204‚Äì22, 283‚Äì5, 318‚Äì24                                     193‚Äì6, 209‚Äì15, 235, 264‚Äì6, 268‚Äì78, 316‚Äì25,
discrete Fourier transforms (DFT) 110‚Äì13, 124‚Äì6                328‚Äì9, 330‚Äì4
   definition 110‚Äì13                                     event trees, definition 61
   Python fundamentals 112‚Äì13, 124‚Äì6                     events, discrete-time uncertainties 50‚Äì61
   speed tests 125‚Äì6                                     Excel 34‚Äì6, 45, 306, 330, 332, 334‚Äì6
discrete market models 54‚Äì61, 71, 81‚Äì94, 96, 110‚Äì13,     executive summary 303
     128, 149‚Äì50, 173‚Äì4, 187‚Äì222, 263‚Äì78                 exotic options 1‚Äì3, 13‚Äì17, 31‚Äì3, 84, 203, 223, 225‚Äì6,
   see also Cox-Ross-Rubinstein‚Ä¶                               303
   central results 57‚Äì61                                    see also American‚Ä¶; Asian‚Ä¶; barrier‚Ä¶
   definition 54, 56‚Äì7, 128                                 concepts 13‚Äì14, 17, 31, 84, 203, 225‚Äì6, 303
   Fourier-based option pricing 110‚Äì13                      definition 13
discrete time 2‚Äì3, 49‚Äì69, 71, 81‚Äì94, 110‚Äì13, 128         exp 37‚Äì40, 85‚Äì94, 138‚Äì44, 204‚Äì22, 299‚Äì302, 319‚Äì24
discrete-time uncertainties 50‚Äì61                        expectations 51‚Äì61, 66‚Äì9, 128‚Äì32
dispersion concepts 19‚Äì25                                explicit analytical solutions 74‚Äì81
   see also volatilities                                    see also Black-Scholes-Merton‚Ä¶
350                                                                                                       INDEX


Fast Fourier Transform (FFT) 2, 96, 105‚Äì9, 114‚Äì26,        gains process, definition 56, 62‚Äì4
       148‚Äì9, 152‚Äì5, 157‚Äì68, 173‚Äì85, 253‚Äì61, 303,         gamma 76‚Äì81, 89‚Äì92, 179‚Äì80, 204‚Äì22
       322‚Äì4                                                 see also delta
    conclusions 303                                          definition 76‚Äì9, 89‚Äì92
    definition 105‚Äì6                                         Python fundamentals 89‚Äì92, 179‚Äì80, 204‚Äì8
    Python fundamentals 114‚Äì26, 148, 149, 157‚Äì68,         GBM see geometric Brownian motion
       253‚Äì61, 322‚Äì4                                      general market model 2‚Äì3, 49‚Äì69, 98‚Äì126, 169‚Äì85,
fat tails 20‚Äì1, 26‚Äì30                                          192‚Äì222, 223‚Äì61, 263‚Äì78, 303
    see also kurtosis                                        see also Bakshi‚Ä¶; market models
Feller condition 189‚Äì91                                      concepts 2‚Äì3, 169‚Äì85, 192‚Äì6, 197‚Äì203, 223‚Äì8,
FFT see Fast Fourier Transform                                 229‚Äì30, 233‚Äì43, 244, 248‚Äì61, 263‚Äì78, 303
filtrations 52‚Äì69, 72‚Äì94, 128, 169‚Äì85                        conclusions 177, 225‚Äì6, 268‚Äì9, 303
financial crisis from 2007 36                             geometric Brownian motion (GBM) 19, 21‚Äì5, 37‚Äì41,
financial engineering 305‚Äì6, 336‚Äì40                            84, 128
first steps with Python 306‚Äì10                               see also Black-Scholes-Merton‚Ä¶
float division, Python 307‚Äì10                                Python fundamentals 37‚Äì41
floats 37‚Äì40, 41‚Äì5, 86‚Äì94, 115‚Äì26, 138‚Äì44, 156‚Äì68,        German Bund yields 231
       181‚Äì5, 205‚Äì22, 246‚Äì61, 270‚Äì8, 297‚Äì302, 307‚Äì10,     global optimization 162‚Äì8, 229‚Äì30, 241‚Äì3, 254‚Äì61,
       311‚Äì13, 317, 330‚Äì2                                      328‚Äì9
floor division, Python 307‚Äì10                             the Greeks 71, 73‚Äì81, 88‚Äì92
fmin, concepts 162‚Äì8, 245‚Äì61, 328‚Äì9                          see also delta; gamma; rho; theta; vega
for, concepts 312‚Äì13, 320‚Äì4                                  concepts 76‚Äì81, 88‚Äì92
formatting concepts 313                                      definition 76‚Äì7
forward rates 34‚Äì6, 44‚Äì5, 230‚Äì4, 245‚Äì8                       long-term factors 79
Fourier inversion 97‚Äì126                                     plotting 91‚Äì2
Fourier series 103‚Äì7, 119‚Äì26                                 Python fundamentals 78, 88‚Äì92
    definition 103‚Äì4, 105‚Äì6, 119‚Äì20                          short-term factors 78‚Äì9
    Python fundamentals 119‚Äì20
Fourier transforms 97‚Äì126, 173‚Äì85, 235‚Äì43, 249‚Äì52,        H93 see Heston‚Äôs stochastic volatility model‚Ä¶
       278                                                hardware 1‚Äì2, 95, 113, 131, 201‚Äì3, 283‚Äì5
    see also discrete‚Ä¶                                    Harrison-Kreps-Pliska paradigm 2, 58‚Äì61, 65‚Äì9
    definition 97‚Äì8, 110‚Äì12, 175‚Äì6, 236‚Äì7                    see also HK79; HP81
Fourier-based option pricing 2, 5, 95‚Äì126, 147, 148‚Äì68,   Haugh and Kogan proposal 127‚Äì8
       173‚Äì85, 195‚Äì6, 235‚Äì43, 249‚Äì52, 257‚Äì61, 278,        HDF5 files 44, 144, 161, 194‚Äì6, 215, 222, 248‚Äì52, 306,
       303                                                     338‚Äì40
    see also Carr-Madan‚Ä¶; Fast‚Ä¶; Lewis‚Ä¶                   Heath, Jarrow and Morton 231
    applications 107‚Äì14, 147, 148‚Äì9, 235‚Äì43, 303          hedge errors 16‚Äì17, 224‚Äì6, 284‚Äì5, 300‚Äì2
    benefits 95‚Äì6, 113‚Äì14, 303                            hedge funds 4, 322
    conclusions 303                                       hedging 1‚Äì2, 4, 13‚Äì15, 16‚Äì17, 76‚Äì7, 79‚Äì81, 172,
    definition 95‚Äì6, 97‚Äì104, 175‚Äì6, 236‚Äì7                      224‚Äì6, 228‚Äì30, 243, 279‚Äì302, 303
    discrete market models 110‚Äì13                            see also dynamic delta‚Ä¶
    numerical evaluation 103‚Äì7                               definition 16
    Python fundamentals 105, 112‚Äì13, 114‚Äì26, 148,            rebalancings 16‚Äì17
       156‚Äì68, 182‚Äì5, 235, 249‚Äì52, 257‚Äì61, 278            help 85‚Äì6, 307, 331
Fubini-Tonello theorem 98, 102‚Äì3                          Heston‚Äôs stochastic volatility model (H93) 2‚Äì3, 84, 96,
Full Truncation, Euler schemes 192‚Äì6, 202‚Äì3, 207‚Äì8,            171‚Äì85, 187, 190‚Äì1, 192‚Äì203, 209‚Äì22, 224‚Äì7,
       209‚Äì22                                                  229‚Äì30, 235‚Äì43, 248‚Äì52, 256‚Äì61, 296‚Äì302
functions, Python 308‚Äì10                                     calibration 235‚Äì43, 248‚Äì52
Fundamental Theorem of Asset Pricing 49‚Äì69, 128‚Äì30,          Python fundamentals 209‚Äì22, 236, 248‚Äì52, 256‚Äì61,
       225‚Äì6                                                   296‚Äì302
    see also risk-neutral valuations                      Higham-Mao, Euler schemes 193‚Äì6, 210‚Äì22
    conclusions 66                                        histograms, concepts 22‚Äì5, 27, 34‚Äì6, 39‚Äì40, 293‚Äì302,
    definitions 59, 64‚Äì6, 68‚Äì9, 128‚Äì9, 225                     314‚Äì16, 323‚Äì5
    multi dimensional version 65‚Äì6                        historical correlations, definition 21
    one dimensional version 64‚Äì5                          historical volatilities 19‚Äì20, 24‚Äì5, 29‚Äì30
futures 15                                                   see also realized‚Ä¶
Index                                                                                                        351


HK79 58, 60‚Äì1                                              interpolate 245‚Äì61, 327‚Äì8
  see also Harrison-Kreps-Pliska paradigm                  interpolations
HP81 58‚Äì61, 65‚Äì6, 67‚Äì9                                         see also cubic spline‚Ä¶
  see also Harrison-Kreps-Pliska paradigm                      concepts 107‚Äì9, 140‚Äì4, 232‚Äì3, 245‚Äì61, 325‚Äì8
Hull and White 229                                         interpreter, Python 3‚Äì4, 305‚Äì10, 323
hybrids 14, 176‚Äì7                                          intrinsic values see inner values
                                                           investment banks 1‚Äì2, 279‚Äì80
if, concepts 312‚Äì13                                        IPython, concepts 3‚Äì4, 5, 306‚Äì7
implied volatilities 2, 14, 20‚Äì1, 30‚Äì3, 36, 41‚Äì5, 84,      ItoÃÇ‚Äôs lemma 72‚Äì81, 84, 177‚Äì8
       95‚Äì6, 171‚Äì85, 227‚Äì30, 237‚Äì43, 244, 251‚Äì2,               see also stochastic‚Ä¶; Taylor expansion
       258‚Äì61, 328‚Äì9                                           Python fundamentals 84, 177‚Äì8
    see also calibration; smiles
    definition 20, 31‚Äì2, 84                                Jarrow, Robert 74
    Python scripts 41‚Äì5, 237, 251‚Äì2, 258‚Äì61                Java 3
    stylized facts 30‚Äì3, 36                                J.P. Morgan 4
implied volatility surface 31‚Äì3                            jump risks 169‚Äì85, 224‚Äì6, 287‚Äì9, 303
in-the-money options (ITM) 10, 31‚Äì3, 75‚Äì81,                jump-diffusion 2, 26, 30, 63‚Äì6, 84, 96, 107, 108‚Äì9,
       101‚Äì3, 117‚Äì19, 131‚Äì2, 134‚Äì44, 159‚Äì68,                    114‚Äì26, 147‚Äì68, 169‚Äì85, 188‚Äì91, 203, 224‚Äì6,
       201‚Äì3, 220‚Äì2, 229‚Äì30, 241‚Äì3, 249‚Äì61, 276‚Äì8,              229‚Äì30, 235‚Äì43, 252‚Äì61, 263‚Äì78
       297‚Äì302                                                see also Brownian motion; Merton‚Äôs‚Ä¶; Poisson
indeterminacy calibration problems 237‚Äì43                       process
index options 1‚Äì5, 9‚Äì17, 19‚Äì45                                calibration 237‚Äì43, 252‚Äì61, 263‚Äì78
    see also options‚Ä¶                                         concepts 63, 84, 108‚Äì9, 147‚Äì68, 169, 184‚Äì5, 188‚Äì91,
indices 1‚Äì5, 17, 19‚Äì45, 316‚Äì17, 334‚Äì6                           224‚Äì6, 235‚Äì43, 252‚Äì61
    array operations 311‚Äì13                                jump/crash risks, definition 14‚Äì15
    stylized facts 25‚Äì30                                   jumps 2, 5, 16‚Äì17, 26‚Äì30, 36, 41, 63, 84, 96, 108‚Äì9,
inner values 9‚Äì17, 31‚Äì3, 44‚Äì5, 75‚Äì81, 93‚Äì4, 101‚Äì3,              147‚Äì68, 169‚Äì85, 207‚Äì22, 224‚Äì7, 229‚Äì30, 235‚Äì43,
       117‚Äì19, 138‚Äì44, 174‚Äì85, 228‚Äì30, 241‚Äì3,                   253‚Äì61, 263‚Äì78, 287, 289, 303
       294‚Äì302                                                see also Poisson process
    see also moneyness of options                             definition 26
    definition 9‚Äì10
input-output operations 41, 43‚Äì5, 140‚Äì4, 330,              kappa 178‚Äì85, 204‚Äì22, 246‚Äì61, 269‚Äì78, 297‚Äì302
       332‚Äì6                                               Kronecker delta function 106‚Äì7
    see also pickling; serialization                       kurtosis 20‚Äì1, 23‚Äì5, 26‚Äì30, 39‚Äì40
    Excel 34‚Äì6, 45, 334‚Äì6                                    see also fat tails; peakedness‚Ä¶
    Python fundamentals 41, 43‚Äì5, 140‚Äì4, 332‚Äì6               definition 20‚Äì1, 24
installation of packages, Python 305‚Äì6
instantaneous correlations, definition 21                  lambda 85‚Äì94, 116‚Äì26, 156‚Äì7, 181‚Äì5, 252‚Äì61, 269‚Äì78,
instantaneous volatilities 20, 23‚Äì5, 38‚Äì40                       297‚Äì302
integers, concepts 115‚Äì26, 138‚Äì44, 307‚Äì10, 311‚Äì13          least-squares Monte Carlo algorithm (LSM) 2, 127‚Äì44,
integrate, concepts 85‚Äì94, 329‚Äì30                                187, 197‚Äì203, 215, 219, 221‚Äì2, 268‚Äì78, 280‚Äì302,
Intel Xeon E3-1231 v3 201                                        303
interbank lending rates 34‚Äì6, 45                              conclusions 136, 203, 303
    see also Euribor; LIBOR                                   Python fundamentals 139‚Äì44, 221‚Äì2, 268‚Äì78, 280‚Äì5,
interest rate risks 14‚Äì15, 172, 303                              289‚Äì302
interest-rate modelling 3, 170‚Äì85, 187‚Äì222, 223, 226‚Äì7,    leverage effects 26, 29‚Äì30, 36, 171‚Äì85
       230‚Äì48, 253‚Äì4, 264‚Äì5                                LeÃÅvy processes 63, 99‚Äì101
    see also Cox-Ingersoll-Ross‚Ä¶                              see also jump-diffusion
interest rates 2‚Äì3, 11‚Äì17, 19, 33‚Äì6, 42‚Äì5, 75‚Äì81, 107‚Äì9,      definition 63
       114‚Äì26, 132‚Äì44, 147‚Äì68, 169‚Äì85, 187‚Äì222, 223,       Lewis model 2, 95‚Äì6, 98‚Äì101, 108, 115‚Äì19, 148,
       228‚Äì61, 264‚Äì78, 303                                       152‚Äì5, 156‚Äì7, 175‚Äì85, 249‚Äì52, 257‚Äì61
    see also Euribor; interbank‚Ä¶; rho; short‚Ä¶              LIBOR 231
    concepts 3, 14‚Äì15, 33‚Äì6, 75‚Äì81, 107‚Äì9, 114‚Äì19,         libraries 4, 5, 305‚Äì6
       169‚Äì85, 223, 228‚Äì61, 264‚Äì5                          life insurance 226
    forward rates 34‚Äì6, 44‚Äì5, 230‚Äì4, 245‚Äì8                 line plots, concepts 314‚Äì16
    stylized facts 33‚Äì6, 169‚Äì85                            linear price systems 57‚Äì61, 68‚Äì9
352                                                                                                   INDEX


Linux 201                                              math 37‚Äì40, 85‚Äì94, 114‚Äì26, 137‚Äì44, 156‚Äì68, 178‚Äì85,
liquidity 13‚Äì15, 17                                         204‚Äì22, 245‚Äì61, 269‚Äì78, 290‚Äì302, 308‚Äì10,
liquidity risks, definition 14‚Äì15                           311‚Äì13, 316‚Äì17, 319‚Äì24, 330‚Äì2, 337‚Äì40
list 312‚Äì13                                            Matlab 3, 5, 198‚Äì203
lists, concepts 312‚Äì13, 333‚Äì4                          matplotlib 5, 9‚Äì17, 37‚Äì40, 43‚Äì5, 85‚Äì94, 114‚Äì26, 160‚Äì8,
local optimization 162‚Äì8, 229‚Äì30, 239‚Äì43, 254‚Äì61,           206‚Äì22, 245‚Äì61, 269‚Äì78, 290‚Äì302, 306, 314‚Äì16,
       328‚Äì9                                                323‚Äì5, 337‚Äì40
log returns                                            MCS see Monte Carlo simulations
   concepts 19‚Äì45, 71, 106‚Äì9, 128, 336‚Äì40              mean returns 19‚Äì45, 141‚Äì4
   definition 19                                       mean reversion 26, 29‚Äì30, 34‚Äì6, 171‚Äì85, 205‚Äì22,
London market, Python developer contracts 4                 246‚Äì8, 249‚Äì61
long positions, American short condor spreads 135‚Äì6,   mean squared error (MSE) 149, 161‚Äì8, 227‚Äì30, 233,
       137‚Äì44                                               236‚Äì43, 246‚Äì61, 292‚Äì302
Longstaff-Schwartz least-squares Monte Carlo           Medvedev and Scaillet 198‚Äì203, 215‚Äì22
       algorithm                                       Merrill Lynch 4
   concepts 2, 127‚Äì44, 187, 197‚Äì203, 280‚Äì5, 289‚Äì95,    Merton‚Äôs jump-diffusion model (M76 model) 2, 63, 84,
       303                                                  107, 108‚Äì9, 147‚Äì68, 169, 171‚Äì2, 175‚Äì85, 224‚Äì6,
   conclusions 136, 203, 303                                235‚Äì43, 252‚Äì61, 287‚Äì9
lookback features 176‚Äì7                                  algorithms 152
loops                                                    conclusions 155, 226, 237‚Äì8
   array operations 312‚Äì13, 319‚Äì25                       problems 237‚Äì8
   coding guidelines 322                                 Python fundamentals 155‚Äì68, 184‚Äì5, 252‚Äì61
lower bounds, option values 127‚Äì8                      methods, classes 330‚Äì2
LSM see least-squares Monte Carlo algorithm            model risks, definition 15‚Äì16
                                                       modules, Python 3‚Äì4, 307‚Äì10, 332‚Äì3, 335‚Äì6
M76 model see Merton‚Äôs jump-diffusion model‚Ä¶           moments of distribution
market incompleteness issues 16, 33‚Äì6, 60‚Äì1, 66,         see also kurtosis; mean‚Ä¶; skew; volatilities
     224‚Äì6, 303                                          concepts 19‚Äì21, 23‚Äì5, 140‚Äì1
market models 2‚Äì3, 16‚Äì17, 33‚Äì6, 49‚Äì69, 71‚Äì94,          moneyness of options 10‚Äì13, 31‚Äì3, 44‚Äì5, 75‚Äì81,
     96‚Äì126, 128, 147‚Äì8, 169‚Äì85, 223‚Äì61, 263‚Äì78,            101‚Äì3, 117‚Äì19, 131‚Äì2, 134‚Äì44, 159‚Äì68, 198‚Äì203,
     303                                                    220‚Äì2, 228‚Äì30, 241‚Äì3, 276‚Äì8, 297‚Äì302
 see also complete‚Ä¶; general‚Ä¶                            see also at-the‚Ä¶; in-the‚Ä¶; out-of-the‚Ä¶
 continuous-time market models 61‚Äì6, 71‚Äì81, 84‚Äì94,     Monte Carlo simulations (MCS) 1‚Äì3, 13, 17, 66, 95,
     96‚Äì126, 128, 147‚Äì68, 169‚Äì85                            127‚Äì44, 149‚Äì68, 173‚Äì85, 187‚Äì222, 263‚Äì78,
 discrete market models 54‚Äì61, 71, 81‚Äì94, 96,               279‚Äì302, 303, 323‚Äì5, 336‚Äì40
     110‚Äì13, 128, 149‚Äì50, 173‚Äì4, 187‚Äì222, 263‚Äì78         see also least-squares‚Ä¶; Longstaff-Schwartz‚Ä¶
market risks 14‚Äì16, 303                                  American option pricing 127‚Äì44, 187, 196‚Äì203,
market-based valuations 1‚Äì5, 9‚Äì17, 49‚Äì50, 145‚Äì68,           215‚Äì22, 263, 268‚Äì78, 279‚Äì302
     223‚Äì61, 263‚Äì78, 303                                 conclusions 136, 203, 268‚Äì9, 303
 see also calibration; Merton‚Äôs jump-diffusion           definition 127‚Äì8, 176‚Äì7, 187, 263
     model‚Ä¶                                              European option pricing 187, 192‚Äì6, 203, 209‚Äì15,
 conclusions 155, 243, 268‚Äì9, 303                           263‚Äì78
 definition 1‚Äì2, 49, 223                                 limitations 187, 189, 201‚Äì3, 266
 fundamental considerations 17                           numerical results 198‚Äì203
 overview of areas 1‚Äì2, 303                              Python fundamentals 133‚Äì4, 139‚Äì44, 151, 166‚Äì8,
markets 1‚Äì3, 7‚Äì45, 49‚Äì69, 71‚Äì94, 96‚Äì126, 128, 147‚Äì8,        189‚Äì90, 193‚Äì6, 199‚Äì200, 203, 204‚Äì22, 264‚Äì6,
     169‚Äì85, 223‚Äì61                                         268‚Äì78, 280‚Äì5, 289‚Äì302, 323‚Äì5, 336‚Äì40
 concepts 1‚Äì2, 7‚Äì45, 71‚Äì94, 169‚Äì85                       zero-coupon bonds 187‚Äì91, 203, 204‚Äì8
 definition 13‚Äì14                                      MSE see mean squared error
 realities 1‚Äì2, 17, 19‚Äì45, 71, 129‚Äì30, 169‚Äì85          multi dimensional version, Fundamental Theorem of
 stylized facts 2, 19‚Äì45, 169‚Äì85                            Asset Pricing 65‚Äì6
Markov property 129‚Äì30                                 multi-paradigm benefits of Python 3‚Äì4
martingales 49‚Äì69, 72‚Äì81, 93‚Äì4, 99‚Äì126, 129‚Äì30,
     138‚Äì44, 225‚Äì6, 303, 318‚Äì24                        naive Euler discretization 192‚Äì6
 see also risk-neutrality; stochastic processes        no free lunches with vanishing risk (NFLVR) 49, 64‚Äì6,
 definition 49‚Äì50, 53‚Äì4, 225                                96‚Äì7, 170
Index                                                                                                      353


normal distributions 20‚Äì5, 34‚Äì6, 38‚Äì40, 42‚Äì5, 62‚Äì3,      p-values 23‚Äì5, 28‚Äì30, 38‚Äì40
    85‚Äì94, 109, 128, 141‚Äì4, 151, 170‚Äì2, 192‚Äì6,           packages 305‚Äì6
    207‚Äì22, 264‚Äì78, 280‚Äì5, 291‚Äì302, 313‚Äì14,              pandas 4, 5, 41, 44‚Äì5, 140‚Äì4, 160‚Äì8, 193‚Äì6, 209‚Äì22,
    316‚Äì18, 324‚Äì5, 337‚Äì40                                      248‚Äì61, 306, 334‚Äì40
normal returns, concepts 21‚Äì30, 38‚Äì40, 42‚Äì5              Parseval‚Äôs Relation, definition 97‚Äì8
Notebook, concepts 4                                     partial differential equations (PDEs) 71‚Äì81, 84‚Äì94,
numerical expressions, Python 305, 306‚Äì10                      173‚Äì85, 232‚Äì3
numerical integration 107‚Äì9, 115‚Äì26, 155‚Äì7, 181‚Äì5,          see also Black-Scholes-Merton‚Ä¶
    248‚Äì61, 303, 329‚Äì30                                     concepts 71‚Äì81, 173‚Äì85
  see also Merton‚Äôs jump-diffusion model‚Ä¶                   definition 72‚Äì4, 173‚Äì5
numerical quadrature schemes 329‚Äì30                      Partial Truncation, Euler schemes 193‚Äì6, 209‚Äì22
numerical techniques 1‚Äì2, 5, 13, 17, 66, 95‚Äì6, 103‚Äì7,    path dependency 176‚Äì7
    127‚Äì44, 173‚Äì85, 187‚Äì222, 303, 323‚Äì5, 336‚Äì40          payoffs see inner values
  see also binomial‚Ä¶; Monte Carlo simulations            pdfs see probability density functions
NumPy 4, 5, 9‚Äì17, 20, 37‚Äì40, 43‚Äì5, 85‚Äì94, 114‚Äì26,        peakedness of distributions 20‚Äì1, 26‚Äì30
    137‚Äì44, 156‚Äì68, 178‚Äì85, 201, 204‚Äì22, 245‚Äì61,            see also kurtosis
    269‚Äì78, 290‚Äì302, 305‚Äì6, 310‚Äì14, 319‚Äì24, 337‚Äì40       performance yardsticks 216‚Äì22
                                                         pickling, concepts 332‚Äì6
object-oriented programming                              plain vanilla options
  see also classes                                          see also European‚Ä¶; options‚Ä¶
  concepts 3‚Äì4, 330‚Äì2                                       definition 13, 17, 149, 223‚Äì6, 303
objective functions, calibration 227‚Äì30, 256‚Äì61          plotting
OIS 231                                                     concepts 5, 9‚Äì17, 21‚Äì5, 28, 37‚Äì40, 43‚Äì5, 87‚Äì94, 120,
OLS see ordinary least-squares regression                      162‚Äì8, 207‚Äì22, 245‚Äì61, 273‚Äì8, 293‚Äì302, 306,
one dimensional version, Fundamental Theorem of                314‚Äì16, 323‚Äì5, 337‚Äì40
     Asset Pricing 64‚Äì5                                     the Greeks 91‚Äì2
open-source benefits of Python 3‚Äì4                       Poisson process 108‚Äì9, 148‚Äì68, 170‚Äì85, 188‚Äì91,
operational risks, definition 15‚Äì16                            207‚Äì8, 264‚Äì78
optimal exercise, American option pricing 129‚Äì44         polyfit, concepts 140‚Äì4, 291‚Äì302, 325‚Äì8
optimization                                             polyval, concepts 140‚Äì4, 291‚Äì302, 325‚Äì8
  see also global‚Ä¶; interpolations; local‚Ä¶; regression   portfolios 55‚Äì69, 71‚Äì94, 279‚Äì302
     analysis                                               definition 55‚Äì6
  concepts 229‚Äì30, 239‚Äì43, 254‚Äì61, 328‚Äì9                    predictability 55‚Äì66, 128‚Äì30
optimize, concepts 328‚Äì9                                    values 55‚Äì61
option holders/writers, definitions 9                    positivity issues, short-term interest rates 33‚Äì6,
options                                                        171‚Äì2
  concepts 9‚Äì17, 30‚Äì3, 75‚Äì94, 127‚Äì44, 226‚Äì7              predictability 55‚Äì66, 128‚Äì30
  definition 9‚Äì10, 75‚Äì6                                  present values 10‚Äì17, 66, 99‚Äì126, 139‚Äì44, 159‚Äì68,
  stylized facts 30‚Äì3                                          181‚Äì5, 317‚Äì18, 324‚Äì5
  swaptions 226‚Äì7                                        price risks, definition 14‚Äì15
options pricing 1‚Äì5, 9‚Äì17, 19‚Äì45, 49‚Äì69, 71‚Äì94,          primal formulations, American option pricing 129‚Äì36,
     95‚Äì126, 127‚Äì44, 147‚Äì68, 169‚Äì85, 187, 192‚Äì222,             139‚Äì44
     223‚Äì61, 263‚Äì78, 279‚Äì302, 303, 316‚Äì25, 328‚Äì34,       primitives, discrete market models 54‚Äì61
     338‚Äì40                                              print 160‚Äì8, 211‚Äì22, 245‚Äì61, 278, 292‚Äì302, 309‚Äì10,
  see also American‚Ä¶; Black-Scholes-Merton‚Ä¶;                   312‚Äì13
     call‚Ä¶; Cox-Ross-Rubinstein‚Ä¶; European‚Ä¶;             probability density functions (pdfs) 37‚Äì45, 85‚Äì94,
     exotic‚Ä¶; Fourier-based‚Ä¶; index‚Ä¶; moneyness‚Ä¶;              96‚Äì7, 252
     Monte Carlo simulations; put‚Ä¶                       probability measures 50‚Äì61, 65‚Äì9, 71, 72‚Äì94, 128
  present value influencing factors 10‚Äì12, 31‚Äì3             concepts 50‚Äì61, 65‚Äì6, 71, 72‚Äì81, 128
  risk-neutral valuations 2, 14‚Äì15, 16, 49‚Äì69, 318‚Äì19,      definition 50‚Äì1
     320‚Äì4                                               probability spaces 50‚Äì61, 72‚Äì94, 128
ordinary least-squares regression (OLS) 127‚Äì44,          probability vectors, definition 112‚Äì13
     187‚Äì222, 325‚Äì8                                      procedural programming concepts 3‚Äì4
out-of-the-money options (OTM) 10, 31‚Äì3, 75‚Äì81,          prototyping uses 3‚Äì4
     102‚Äì3, 117‚Äì19, 201‚Äì3, 229‚Äì30, 241‚Äì3, 249‚Äì61         pseudo-random numbers 132‚Äì44, 152‚Äì68, 173‚Äì85,
overview of the book 1‚Äì5                                       194‚Äì222, 270‚Äì8, 313‚Äì14, 323‚Äì5, 338‚Äì40
354                                                                                                       INDEX


put options 9‚Äì10, 31‚Äì3, 74‚Äì81, 95, 129, 132‚Äì6, 137‚Äì44,   qualitative model features 13‚Äì14, 19‚Äì45
      163‚Äì4, 171‚Äì2, 187, 192‚Äì222, 248‚Äì61, 268‚Äì78,        quantile-quantile plots (Q-Q plots) 23‚Äì5, 28‚Äì9, 34‚Äì6,
      279‚Äì302                                                 39‚Äì40
  see also option‚Ä¶                                       quantitative model features 14
  American option pricing 132‚Äì6, 137‚Äì44, 196‚Äì203,        quasi-random numbers 132‚Äì44, 173‚Äì85, 313‚Äì14
      215‚Äì22, 268‚Äì78, 280‚Äì302
put-call parity 74‚Äì81, 95‚Äì6                              R4
py suffix 309‚Äì10, 318‚Äì19                                 Radon-Nikodym derivative, definition 53‚Äì4
PyTables 5, 306                                          random 194‚Äì6, 207‚Äì22, 269‚Äì78, 297‚Äì302, 313‚Äì14,
Python 3‚Äì5, 9‚Äì17, 303, 305‚Äì40                                  324‚Äì5
  advanced topics 330‚Äì6                                  random numbers 132‚Äì44, 152‚Äì68, 173‚Äì85, 187‚Äì222,
  American option pricing fundamentals 127, 129, 131,          269‚Äì78, 297‚Äì302, 313‚Äì14, 323‚Äì5, 338‚Äì40
      133‚Äì4, 136‚Äì44, 199‚Äì200, 268‚Äì78, 280‚Äì8, 289‚Äì302     random variables, concepts 51‚Äì61
  approximation fundamentals 105, 119‚Äì20, 140‚Äì4,         random vectors, concepts 51‚Äì61
      280‚Äì5, 325‚Äì8                                       range, concepts 312‚Äì13
  benefits 3‚Äì4                                           rapid financial engineering 26‚Äì7, 41, 193, 303,
  BSM fundamentals 11‚Äì13, 21‚Äì5, 32‚Äì3, 75, 78,                  336‚Äì40
      85‚Äì92, 94, 107, 114‚Äì19, 280‚Äì5, 289‚Äì95, 316‚Äì17,     reading recommendations 3, 4‚Äì5, 305
      321, 323‚Äì5, 330‚Äì2                                  realities, markets 1‚Äì2, 17, 19‚Äì45, 71, 129‚Äì30, 169‚Äì85
  calibration 149, 160‚Äì8, 232, 236‚Äì7, 239‚Äì42, 243‚Äì61,    realized volatilities 24‚Äì5, 26‚Äì30, 38‚Äì40
      286‚Äì8                                                 see also historical‚Ä¶
  concepts 3‚Äì5, 9‚Äì17, 303, 305‚Äì40                           definition 24‚Äì5, 26
  CRR fundamentals 81, 82, 92‚Äì4, 129, 137‚Äì9, 318‚Äì24      rebalancings, hedging 16‚Äì17
  definition 3‚Äì4                                         recombining trees 71, 81‚Äì94, 318‚Äì24
  dynamic delta hedging 280‚Äì8, 289‚Äì302                      see also binomial‚Ä¶
  European option pricing fundamentals 9‚Äì13, 75, 107,    Reflection, Euler schemes 193‚Äì6, 210‚Äì22
      112, 114‚Äì26, 148, 149, 151, 155‚Äì68, 173, 177‚Äì85,   regression analysis, concepts 127‚Äì44, 187, 325‚Äì8
      193‚Äì6, 209‚Äì15, 235, 264‚Äì6, 268‚Äì78, 316‚Äì25,         relative price differences, MSE 227‚Äì30
      328‚Äì9, 330‚Äì4, 338‚Äì40                               replicable contingent claims 57‚Äì61, 65‚Äì6, 170‚Äì85,
  FFT fundamentals 114‚Äì26, 148, 149, 157‚Äì68,                   223‚Äì6, 279‚Äì302, 303
      253‚Äì61, 322‚Äì4                                      residue calculus 100‚Äì1
  first steps 306‚Äì10                                     rho 77‚Äì81, 90‚Äì2, 181‚Äì5, 213‚Äì22, 249‚Äì61, 269‚Äì78,
  Fourier-based option pricing 105, 112‚Äì13, 114‚Äì26,            297‚Äì302
      148, 156‚Äì68, 235, 249‚Äì52, 257‚Äì61, 278                 see also interest rates
  fundamentals 3, 9‚Äì17, 37‚Äì45, 75, 305‚Äì40                   definition 77‚Äì80, 90‚Äì2
  the Greeks 78, 88‚Äì92                                      Python fundamentals 90‚Äì2, 181‚Äì5, 213‚Äì14, 219‚Äì22,
  implied volatilities 41‚Äì5, 237, 251‚Äì2, 258‚Äì61                249‚Äì61, 269‚Äì78, 297‚Äì302
  input-output operations 41, 43‚Äì5, 140‚Äì4, 330, 332‚Äì6    risk analyses 2, 3, 4, 14‚Äì17, 49‚Äì69, 169‚Äì77, 224‚Äì6,
  installation of packages 305‚Äì6                               303
  ItoÃÇ‚Äôs lemma 84, 177‚Äì8                                    see also market‚Ä¶; model‚Ä¶; operational‚Ä¶
  MCS fundamentals 133‚Äì4, 139‚Äì44, 151, 166‚Äì8,               concepts 14‚Äì17, 224‚Äì6
      189‚Äì90, 193‚Äì6, 199‚Äì200, 203, 204‚Äì22, 264‚Äì6,        risk management 1‚Äì2, 4, 13, 14‚Äì17, 76‚Äì7, 203, 224‚Äì6,
      268‚Äì78, 280‚Äì5, 289‚Äì95, 323‚Äì5, 336‚Äì40                     279‚Äì302, 303
  object-oriented programming concepts 3‚Äì4, 330‚Äì2           see also hedging
  rapid financial engineering 336‚Äì40                     risk-less interest rates 11‚Äì17, 38‚Äì40, 42‚Äì5, 49‚Äì69,
  reading recommendations 3, 4‚Äì5, 305                          71‚Äì97, 107‚Äì9, 114‚Äì19, 122‚Äì6, 128, 147‚Äì8,
  scripts 9‚Äì13, 19, 21‚Äì5, 28‚Äì30, 32‚Äì3, 37‚Äì45, 84‚Äì94,           152‚Äì68, 181‚Äì5, 223‚Äì6, 279‚Äì80, 316‚Äì24, 331‚Äì2,
      114‚Äì26, 129, 133‚Äì44, 149, 151, 155‚Äì68, 177‚Äì85,           337‚Äì40
      193‚Äì6, 199‚Äì200, 204‚Äì22, 235, 239‚Äì61, 263‚Äì4,           BSM 11‚Äì13, 42‚Äì5, 72‚Äì81, 85‚Äì92, 107‚Äì9, 114‚Äì19,
      268‚Äì78, 280‚Äì303, 309‚Äì10                                  128, 223, 280‚Äì302, 316‚Äì17, 331‚Äì2, 337‚Äì40
  selected financial topics 325‚Äì8                           definition 55
  versions 306                                           risk-neutral valuations 2, 14‚Äì15, 16, 49‚Äì69, 72‚Äì81, 96,
Python Quant Platform 4, 303                                   98‚Äì126, 147‚Äì68, 173‚Äì85, 197‚Äì203, 224‚Äì6,
                                                               318‚Äì19, 320‚Äì4
quad, concepts 85‚Äì94, 114‚Äì26, 157‚Äì68, 180‚Äì5, 329‚Äì30         see also continuous‚Ä¶; discrete‚Ä¶; Fundamental
quadratic regression 326‚Äì8                                     Theorem of Asset Pricing
Index                                                                                                        355


   concepts 49‚Äì69, 72‚Äì81, 96, 98‚Äì126, 129‚Äì30, 147‚Äì68,     slicing, array operations 311‚Äì13
      173‚Äì85, 224‚Äì6                                       SMI 228‚Äì30
   powers 66                                              smiles 2, 19, 32‚Äì3, 36, 171‚Äì85, 226‚Äì7
risk-neutrality 2, 14‚Äì16, 20, 49‚Äì69, 72‚Äì81, 96, 98‚Äì126,      see also implied volatilities
      129‚Äì44, 147‚Äì68, 173‚Äì85, 192‚Äì6, 197‚Äì203, 224‚Äì6,      software 1‚Äì5, 95, 113, 131, 201‚Äì3, 283‚Äì5
      318‚Äì19, 320‚Äì4                                          see also Excel; Python
   see also martingales                                   speculation 228‚Äì30
   definition 53, 225‚Äì6                                   speed benefits of Python 4
RMSE see root mean squared error                          speed tests of DFT 125‚Äì6
rolling correlations 24‚Äì5, 29‚Äì30, 40                      spot prices 10‚Äì17, 41‚Äì5, 73‚Äì81, 85‚Äì92, 107‚Äì9, 114‚Äì19,
rolling mean log returns 24‚Äì5, 29‚Äì30, 40                        128, 223, 280‚Äì302, 316‚Äì17, 330‚Äì2
rolling volatilities 24‚Äì5, 29‚Äì30, 40                      spreadsheets 306, 332, 334‚Äì6
root mean squared error (RMSE) 149, 161‚Äì8, 228‚Äì30            see also Excel
roots of unity 110‚Äì13, 120‚Äì6                              sqrt 38‚Äì45, 85‚Äì94, 115‚Äì26, 142‚Äì4, 157‚Äì68, 179‚Äì85,
                                                                194‚Äì6, 204‚Äì22, 246‚Äì61, 271‚Äì8, 319‚Äì24, 337‚Äì40
S&P 500 index 228‚Äì30                                      square-root diffusion, concepts 188‚Äì96, 203, 206‚Äì22,
scientific functions 305‚Äì6                                      263, 271‚Äì8
SciPy 37‚Äì40, 41‚Äì5, 85‚Äì94, 114‚Äì26, 156‚Äì68, 180‚Äì5,          standard deviations 11‚Äì17, 20‚Äì1, 23‚Äì5, 26‚Äì30, 34‚Äì6,
      245‚Äì61, 305‚Äì6, 316‚Äì17, 327‚Äì9, 330‚Äì2                       37‚Äì45, 132‚Äì44, 156‚Äì68, 181‚Äì5, 200‚Äì3, 254‚Äì61
scripts, Python 9‚Äì13, 19, 21‚Äì5, 28‚Äì30, 32‚Äì3, 37‚Äì45,          see also volatilities
      84‚Äì94, 114‚Äì26, 129, 133‚Äì4, 136‚Äì44, 149, 151,           concepts 20‚Äì1, 23‚Äì5, 26‚Äì30, 34‚Äì6, 200‚Äì3
      155‚Äì68, 177‚Äì85, 193‚Äì6, 199‚Äì200, 204‚Äì22, 235,        standard library 308‚Äì10
      239‚Äì42, 243‚Äì61, 263‚Äì4, 268‚Äì78, 280‚Äì8, 289‚Äì302,      standard normal distributions 85‚Äì94, 109, 128, 141‚Äì4,
      303, 309‚Äì10                                               151, 170‚Äì2, 192‚Äì6, 207‚Äì22, 264‚Äì78, 280‚Äì5,
self-financing trading strategies 56‚Äì61, 63‚Äì6, 69,              291‚Äì302, 313‚Äì14, 338‚Äì40
      128‚Äì30, 280                                         static hedging
sell-side parties, definition 13                             concepts 14, 16‚Äì17, 287
semi-analytic formulas 2, 5, 95‚Äì126, 148‚Äì68, 173‚Äì85,         definition 16
      192, 195‚Äì6, 214‚Äì22                                  stats, concepts 37‚Äì40, 114‚Äì26, 316‚Äì17
   see also Fourier-based‚Ä¶                                statsmodels 37‚Äì40
semimartingales 62‚Äì6, 96‚Äì126                              stochastic differential equations (SDEs) 20, 21‚Äì5, 72‚Äì3,
sensitivities see Greeks                                        128, 176‚Äì85, 188‚Äì222, 230‚Äì3, 263‚Äì78
Separating Hyperplane Theorem 68‚Äì9                        stochastic integration 50‚Äì69, 180‚Äì5
serialization concepts 332‚Äì6                              stochastic interest rates 33‚Äì6, 169‚Äì85, 187‚Äì222,
settlement of options 9, 229‚Äì30                                 226‚Äì30
short positions, American short condor spreads 135‚Äì6,     stochastic processes 2, 19‚Äì21, 33‚Äì6, 49‚Äì69, 72‚Äì81, 128,
      137‚Äì44                                                    187‚Äì222, 313
short-term interest rates 33‚Äì6, 42‚Äì5, 49‚Äì69, 75‚Äì81,          see also martingales
      96‚Äì7, 107‚Äì9, 114‚Äì26, 132‚Äì44, 147‚Äì68, 169‚Äì85,           concepts 49‚Äì69, 72‚Äì81, 128
      187‚Äì222, 223, 226‚Äì33, 249‚Äì61, 264‚Äì78, 286‚Äì302          definition 52‚Äì3
   concepts 33‚Äì6, 45, 75‚Äì81, 96‚Äì7, 107‚Äì9, 114‚Äì19,         stochastic volatilities 2‚Äì3, 20‚Äì1, 26‚Äì30, 36, 63‚Äì4, 84,
      169‚Äì85, 187‚Äì92, 205‚Äì22, 223, 226‚Äì33, 249‚Äì52,              96, 149, 169‚Äì85, 187‚Äì222, 224‚Äì7, 229‚Äì30,
      286‚Äì9, 297‚Äì302                                            235‚Äì43, 248‚Äì52, 256‚Äì61, 296‚Äì302
   stylized facts 33‚Äì6, 169‚Äì85                               see also Bates‚Ä¶; Heston‚Äôs‚Ä¶
sigma algebras 61, 65‚Äì9, 72‚Äì3, 85‚Äì94, 128, 138‚Äì44,           definition 26
      169‚Äì72, 178‚Äì80, 204‚Äì22, 246‚Äì8, 250‚Äì61, 269‚Äì78,      stock index options see index options
      297‚Äì302                                             stock indices 1‚Äì5, 17, 19‚Äì45, 61‚Äì9, 71‚Äì94, 109‚Äì26,
Simple Reflection Euler schemes 193‚Äì6, 210‚Äì22                   132‚Äì44, 147‚Äì68, 169‚Äì85, 224‚Äì6, 233‚Äì43, 263‚Äì78,
Simpson‚Äôs rule 106‚Äì7, 118, 160                                  279‚Äì302, 303, 316‚Äì17, 334‚Äì6
simulations 1‚Äì3, 13, 17, 21‚Äì5, 38‚Äì40, 95, 127‚Äì44, 147,    stopping times
      149‚Äì68, 173‚Äì85, 187‚Äì222, 263‚Äì78, 279‚Äì302, 303,         concepts 53‚Äì61, 129‚Äì30
      323‚Äì5, 336‚Äì40                                          definition 53
   see also Monte Carlo‚Ä¶                                  strike prices 9‚Äì17, 32‚Äì3, 36, 41‚Äì5, 74‚Äì81, 85‚Äì92, 96‚Äì7,
sin 308‚Äì9                                                       106‚Äì9, 114‚Äì19, 122‚Äì6, 128‚Äì44, 149‚Äì68, 181‚Äì5,
sine 328‚Äì9                                                      193‚Äì6, 223, 229‚Äì30, 249‚Äì61, 274‚Äì302, 316‚Äì24,
skew 19, 20‚Äì1, 23‚Äì5, 38‚Äì40                                      330‚Äì2, 338‚Äì40
356                                                                                                     INDEX


string replacements, concepts 313                       valuation practices
stylized facts 2, 19‚Äì45, 169‚Äì85                           see also options pricing
   conclusions 36                                         concepts 55‚Äì61, 223
   definition 25‚Äì6                                      Value, concepts 332
super-replicable contingent claims 57‚Äì61, 65‚Äì6          value process, definition 56
   concepts 57‚Äì61                                       variance 20‚Äì1, 23‚Äì5, 38‚Äì40, 45, 62‚Äì6, 133‚Äì44, 170‚Äì85,
   definition 57                                             192‚Äì6, 203, 216‚Äì22, 249‚Äì52, 260‚Äì1, 264‚Äì78,
swaps 38, 171‚Äì2, 226‚Äì7, 231‚Äì3                                286‚Äì302, 325
swaptions 226‚Äì7                                         variance matrices 62‚Äì3
syntax benefits of Python 3‚Äì4                           variance reduction techniques 133‚Äì44, 192‚Äì6, 203,
                                                             264‚Äì78, 325
Taylor expansion 84, 178                                VBA 3
technology issues 1‚Äì2, 15‚Äì16, 95‚Äì6, 113, 131‚Äì44,        vectorization and broadcasting capabilities, array
      187‚Äì91, 201‚Äì3, 283‚Äì5                                   operations 311‚Äì13, 321‚Äì4
   see also hardware; software                          vega 31‚Äì2, 42‚Äì5, 77‚Äì81, 91‚Äì2, 228‚Äì30, 241‚Äì3, 331‚Äì4
term structures                                           see also volatilities
   short-term interest rates 34‚Äì6, 45, 233, 245‚Äì8         definition 31, 77‚Äì80, 91‚Äì2, 332
   volatilities 32‚Äì3, 36, 171‚Äì85                          Python fundamentals 91‚Äì2, 241‚Äì3
terminal dates, market models 56‚Äì61, 65‚Äì9               ‚Äòvega hedged‚Äô positions 79‚Äì80
test routines 21‚Äì5, 29‚Äì30, 38‚Äì40, 193‚Äì4                 versions of Python 306
theoretical valuations                                  vola 331‚Äì2
   concepts 1‚Äì2, 5, 15, 47‚Äì69, 223, 227, 230‚Äì3, 263‚Äì4   volatilities 2‚Äì3, 11‚Äì45, 74‚Äì81, 85‚Äì92, 107‚Äì9, 114‚Äì19,
   definition 1‚Äì2, 223                                       122‚Äì6, 128, 137‚Äì44, 147‚Äì68, 169‚Äì85, 187‚Äì222,
theta 71, 77‚Äì81, 90‚Äì2, 178‚Äì80, 181‚Äì5, 204‚Äì22, 246‚Äì8,         223, 228‚Äì30, 241‚Äì61, 264‚Äì78, 279‚Äì302, 316‚Äì24,
      249‚Äì61, 269‚Äì78, 297‚Äì302                                328‚Äì9, 331‚Äì2, 337‚Äì40
   see also time to maturity                              see also clustering; historical‚Ä¶; implied‚Ä¶;
   definition 77‚Äì81, 90‚Äì2                                    instantaneous‚Ä¶; smiles; standard deviations;
   Python fundamentals 90‚Äì2, 178‚Äì85, 204‚Äì8, 214‚Äì22,          stochastic‚Ä¶; vega
      246‚Äì8, 249‚Äì61, 269‚Äì78, 297‚Äì302                      concepts 2‚Äì3, 11‚Äì13, 14‚Äì15, 19‚Äì21, 23‚Äì33, 36,
tick sizes 31‚Äì3, 194‚Äì6                                       147‚Äì68, 169‚Äì85, 223, 264‚Äì5
time series 4, 19‚Äì45, 306                                 definitions 19‚Äì21, 23, 26
time to maturity 9‚Äì17, 32‚Äì3, 36‚Äì40, 41‚Äì5, 72‚Äì81,          stylized facts 19‚Äì21, 23‚Äì33, 36
      85‚Äì92, 107‚Äì9, 114‚Äì19, 122‚Äì6, 128, 137‚Äì44,           term structures 32‚Äì3, 36, 171‚Äì85
      149‚Äì68, 181‚Äì5, 193‚Äì203, 223, 226‚Äì30, 249‚Äì61,      volatility risks 14‚Äì15, 172, 224‚Äì6, 303
      274‚Äì8, 280‚Äì302, 316‚Äì24, 330‚Äì2, 338‚Äì40
   see also theta                                       weak arbitrage opportunities 58‚Äì61, 66‚Äì7
time values, concepts 11‚Äì13                             the Web, data analytics 4‚Äì5, 26‚Äì7, 41, 334‚Äì40
total semimartingales, definition 62‚Äì3
trading activities 1‚Äì2, 55‚Äì61                           xlrd 306
trading strategies 56‚Äì69, 71‚Äì94, 128‚Äì30                 xlwt 306
   see also admissible‚Ä¶; arbitrage‚Ä¶; contingent         xrange 140‚Äì4, 207‚Äì22, 294‚Äì302, 312‚Äì13, 319‚Äì24
      claims; self-financing‚Ä¶
   definitions 56‚Äì7, 61‚Äì2, 63‚Äì4, 128                    Yahoo 26‚Äì7, 41, 334‚Äì40
trigonometric functions 308‚Äì10                          yield curves 171‚Äì2, 228‚Äì33, 247‚Äì8, 254‚Äì5
Truncation, Euler schemes 193‚Äì6, 209‚Äì22
                                                        zero-based numbering, array operations 311‚Äì13
uncertainties 50‚Äì69, 72‚Äì94, 169‚Äì85                      zero-coupon bonds 72‚Äì94, 128‚Äì30, 169‚Äì85, 187‚Äì91,
uncorrected (biased) sample standard deviation,              203, 204‚Äì8, 230‚Äì4, 318‚Äì24
    definition 20                                         BCC97 172‚Äì85
underlying assets 2‚Äì5, 9‚Äì17, 41‚Äì5, 71‚Äì94, 107‚Äì9,          MCS 187‚Äì91, 203, 204‚Äì8
    114‚Äì19, 128, 176‚Äì85, 223, 279‚Äì302, 316‚Äì17             Python fundamentals 178‚Äì80, 189‚Äì90, 204‚Äì8
upper bounds, option values 127‚Äì8, 143‚Äì4                  valuations 172‚Äì85, 187‚Äì91, 204‚Äì8, 230‚Äì4
US Treasury yields 231                                  zeros 143‚Äì4, 167‚Äì8, 206‚Äì8, 291‚Äì302, 320‚Äì4

                                                                              Index compiled by Terry Halliday
    WILEY END USER LICENSE
          AGREEMENT
Go to www.wiley.com/go/eula to access Wiley‚Äôs ebook
EULA.
